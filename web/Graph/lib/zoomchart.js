// Zoomcharts library, Full Edition. Version 1.1.0
// (c) 2013 - 2014 Data Visualization Software Lab
//
// http://zoomcharts.com
//
//
// 3rd party software license acknowledgement:
// moment.js
// version : 2.0.0
// author : Tim Wood
// license : MIT
// momentjs.com

(function() {
var Netchart_Selection;
        Netchart_Selection = (function() {
        Netchart_Selection.prototype.scene = null;
                Netchart_Selection.prototype.events = null;
                Netchart_Selection.prototype.currentObject = null;
                Netchart_Selection.prototype.currentSlice = null;
                function Netchart_Selection(chart) {
                this.chart = chart;
                        this.scene = chart.scene;
                        this.events = chart.events;
                        this.navigator = chart.navigator;
                        this.dragPointers = {}
                }
        Netchart_Selection.prototype.onPointerMove = function(event) {
        var item, n;
                if (!this.scene.xyInChart(event.x, event.y)) {
        return
        }
        n = this.scene.findLinkOrNodeAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                item = n ? this.scene.findItem(event.x, event.y, n, this.scene.settings.interaction.selection.tolerance) : null;
                return this.switchCurrentObject(n, item, event)
        };
                Netchart_Selection.prototype.onPointerOut = function(event) {
                return this.switchCurrentObject(null, null, event)
                };
                Netchart_Selection.prototype.onPointerDown = function(event) {
                var item, n;
                        if (!this.scene.xyInChart(event.x, event.y)) {
                return
                }
                n = this.scene.findLinkOrNodeAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        item = n ? this.scene.findItem(event.x, event.y, n, this.scene.settings.interaction.selection.tolerance) : null;
                        this.switchCurrentObject(n, item, event);
                        if (n instanceof Netchart_Node) {
                this.updateSelection(event, n, true);
                        this.setPointerNode(event, n);
                        return event.consumed = true
                }
                };
                Netchart_Selection.prototype.onPointerUp = function(event) {
                if (this.dragPointers[event.identifier]) {
                if (this.dragPointers[event.identifier].dragging) {
                event.consumed = true
                }
                return this.setPointerNode(event, null)
                }
                };
                Netchart_Selection.prototype.onPointerCancel = function(event) {
                return this.onPointerUp(event)
                };
                Netchart_Selection.prototype.onPointerDrag = function(event) {
                var newX, newY, p, _ref;
                        p = this.dragPointers[event.identifier];
                        if (!p) {
                return
                }
                _ref = this.scene.fromDisplay(event.x, event.y), newX = _ref[0], newY = _ref[1];
                        p.mouseX = event.x;
                        p.mouseY = event.y;
                        p.dragging = true;
                        this.dragNodes(p, newX, newY, this.scene.settings.interaction.selection.lockNodesOnMove);
                        return event.consumed = true
                };
                Netchart_Selection.prototype.onClick = function(event) {
                var e, n;
                        if (!this.scene.xyInChart(event.x, event.y)) {
                return
                }
                n = this.scene.findLinkOrNodeAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        event.clickItem = n ? this.scene.findItem(event.x, event.y, n, this.scene.settings.interaction.selection.tolerance) : null;
                        this.updateSelection(event, n, false);
                        if (n instanceof Netchart_Node) {
                event.clickNode = n
                } else {
                event.clickLink = n
                }
                e = this.chart.notifyClick(event);
                        if (e.defaultPrevented) {
                return event.consumed = true
                }
                };
                Netchart_Selection.prototype.onRightClick = function(event) {
                var e, n;
                        if (!this.scene.xyInChart(event.x, event.y)) {
                return
                }
                n = this.scene.findLinkOrNodeAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        event.clickItem = n ? this.scene.findItem(event.x, event.y, n, this.scene.settings.interaction.selection.tolerance) : null;
                        this.updateSelection(event, n, false);
                        if (n instanceof Netchart_Node) {
                event.clickNode = n
                } else {
                event.clickLink = n
                }
                e = this.chart.notifyRightClick(event);
                        if (e.defaultPrevented) {
                return event.consumed = true
                }
                };
                Netchart_Selection.prototype.onDoubleClick = function(event) {
                var e, n;
                        n = this.scene.findLinkOrNodeAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        event.clickItem = n ? this.scene.findItem(event.x, event.y, n, this.scene.settings.interaction.selection.tolerance) : null;
                        if (n instanceof Netchart_Node) {
                event.clickNode = n
                } else {
                event.clickLink = n
                }
                e = this.chart.notifyDoubleClick(event);
                        if (e.defaultPrevented) {
                return event.consumed = true
                }
                };
                Netchart_Selection.prototype.doAnimations = function(event) {
                var id, newX, newY, p, _ref, _ref1, _results;
                        _ref = this.dragPointers;
                        _results = [];
                        for (id in _ref) {
                p = _ref[id];
                        _ref1 = this.scene.fromDisplay(p.mouseX, p.mouseY), newX = _ref1[0], newY = _ref1[1];
                        this.dragNodes(p, newX, newY, false);
                        _results.push(event.changes.coordinates = true)
                }
                return _results
                };
                Netchart_Selection.prototype.updateSelection = function(event, target, softDeselect) {
                if (!this.scene.settings.interaction.selection.enabled) {
                return
                }
                if (!event.shiftKey && (!target || (!this.scene.settings.interaction.selection.nodesSelectable && target.isNode) || (!this.scene.settings.interaction.selection.linksSelectable && target.isLink))) {
                return this.chart.setSelection([])
                } else {
                if (target && event.shiftKey || (softDeselect && Base_Helpers.arrayContains(this.scene.selection, target))) {
                if (!Base_Helpers.arrayContains(this.scene.selection, target)) {
                this.scene.selection.push(target);
                        return this.chart.setSelection(this.scene.selection, true)
                }
                } else {
                if (target) {
                return this.chart.setSelection([target])
                }
                }
                }
                };
                Netchart_Selection.prototype.dragNodes = function(p, newX, newY, lock) {
                var dx, dy, n, _i, _len, _ref;
                        dx = newX + p.x - p.node.x;
                        dy = newY + p.y - p.node.y;
                        if (Base_Helpers.countProperties(this.dragPointers) === 1 && this.scene.selection.length > 0) {
                _ref = this.scene.selection;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                n = _ref[_i];
                        if (n.isNode) {
                this.moveNode(n, dx, dy, lock)
                }
                }
                } else {
                this.moveNode(p.node, dx, dy, lock)
                }
                return this.events.notifySceneChanges({coordinates: true})
                };
                Netchart_Selection.prototype.moveNode = function(node, dx, dy, lock) {
                var bottom, left, right, sizeX, sizeY, top, _ref;
                        node.x += dx;
                        node.y += dy;
                        if (lock) {
                node.userLock = true
                }
                if (!this.scene.settings.interaction.selection.allowMoveNodesOffscreen) {
                _ref = this.scene.getVisibleBounds(), left = _ref[0], top = _ref[1], right = _ref[2], bottom = _ref[3];
                        sizeX = node.currentHwidth * 1.2;
                        sizeY = node.currentRadius * 1.2;
                        node.x = Math.min(Math.max(node.x, left + sizeX), right - sizeX);
                        return node.y = Math.min(Math.max(node.y, top + sizeY), bottom - sizeY)
                }
                };
                Netchart_Selection.prototype.setPointerNode = function(event, node) {
                var id, oldP, x, y, _ref;
                        id = event.identifier;
                        oldP = this.dragPointers[id];
                        if (oldP) {
                oldP.node.locks -= 1;
                        delete this.dragPointers[id]
                }
                if (node) {
                _ref = this.scene.fromDisplay(event.x, event.y), x = _ref[0], y = _ref[1];
                        this.dragPointers[event.identifier] = {x: node.x - x, y: node.y - y, node: node, mouseX: event.x, mouseY: event.y};
                        return node.locks += 1
                }
                };
                Netchart_Selection.prototype.switchCurrentObject = function(obj, item, event) {
                if (obj === this.currentObject && item === this.currentItem) {
                return
                }
                event.changes.current = true;
                        this.scene.setActiveObject(obj, item);
                        if (this.currentObject instanceof Netchart_Node) {
                this.currentObject.locks -= 1
                }
                this.currentObject = obj;
                        this.currentItem = item;
                        if (this.currentObject instanceof Netchart_Node) {
                this.currentObject.locks += 1
                }
                return this.chart.notifyHoverChanged(event)
                };
                return Netchart_Selection
        })();
        var Netchart_Data, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        };
        Netchart_Data = (function() {
        Netchart_Data.prototype.settings = null;
                Netchart_Data.prototype.removed = false;
                Netchart_Data.prototype.requestScheduled = false;
                Netchart_Data.prototype.cleanupScheduled = false;
                Netchart_Data.prototype.dataFunc = null;
                Netchart_Data.prototype.nextLinkId = 0;
                function Netchart_Data(chart) {
                this.chart = chart;
                        this.runRequests = __bind(this.runRequests, this);
                        this.settings = chart.settings;
                        this.nodes = {};
                        this.links = {};
                        this.nodeToLinks = {};
                        this.requests = [];
                        this.pendingNodes = {};
                        this.requestedNodes = {};
                        this.dataFunc = this.getDataFunction()
                }
        Netchart_Data.prototype.applyPreloadedData = function() {
        var r;
                if (this.settings.data.randomNodes > 0) {
        r = this.genRandomGraph(this.settings.data);
                return this.dataArrived(null, r)
        } else {
        if (this.settings.data.preloaded) {
        return this.dataArrived(null, this.settings.data.preloaded)
        }
        }
        };
                Netchart_Data.otherEnd = function(linkData, nodeId) {
                if (nodeId === linkData.from) {
                return linkData.to
                }
                if (nodeId === linkData.to) {
                return linkData.from
                }
                return null
                };
                Netchart_Data.multiLinkId = function(linkData) {
                if (linkData.from < linkData.to) {
                return linkData.from + "#" + linkData.to
                } else {
                return linkData.to + "#" + linkData.from
                }
                };
                Netchart_Data.prototype.remove = function() {
                return this.removed = true
                };
                Netchart_Data.prototype.getQueueLength = function() {
                return Base_Helpers.countProperties(this.pendingNodes) + Base_Helpers.countProperties(this.requestedNodes)
                };
                Netchart_Data.prototype.getNodeData = function(id) {
                if (this.nodes.hasOwnProperty(id)) {
                return this.nodes[id]
                } else {
                if (this.dataFunc != null) {
                this.requestNodeData(id)
                }
                }
                return null
                };
                Netchart_Data.prototype.nodeRemoved = function(id) {
                delete this.pendingNodes[id];
                        return delete this.requestedNodes[id]
                };
                Netchart_Data.prototype.getLinkData = function(id) {
                return this.links[id]
                };
                Netchart_Data.prototype.getNodeLinks = function(id) {
                if (this.nodes.hasOwnProperty(id) && this.nodes[id].loaded) {
                return this.applyLinkFilter(id)
                } else {
                if (this.dataFunc != null) {
                this.requestNodeData(id)
                }
                }
                return null
                };
                Netchart_Data.prototype.getNodeCollectedLinks = function(id) {
                return this.applyLinkFilter(id)
                };
                Netchart_Data.prototype.isLoaded = function(id) {
                return this.nodes.hasOwnProperty(id) && this.nodes[id].loaded
                };
                Netchart_Data.prototype.isFilteredNode = function(id) {
                var nodeData, nodeFilter;
                        nodeFilter = this.settings.filters.nodeFilter;
                        nodeData = this.nodes[id];
                        if (!nodeFilter || !nodeData) {
                return false
                }
                return !nodeFilter(nodeData, this.isLoaded(id) ? this.nodeToLinks[id] : null)
                };
                Netchart_Data.prototype.getNodes = function() {
                var id, nodeData, nodeFilter, result, _ref;
                        nodeFilter = this.settings.filters.nodeFilter;
                        if (!nodeFilter) {
                return this.nodes
                }
                result = {};
                        _ref = this.nodes;
                        for (id in _ref) {
                nodeData = _ref[id];
                        if (nodeFilter(nodeData, this.isLoaded(id) ? this.nodeToLinks[id] : null)) {
                result[id] = nodeData
                }
                }
                return result
                };
                Netchart_Data.prototype.applyLinkFilter = function(nodeId) {
                var d1, d2, filtered, id, l, link, linkFilter, links, multiId, multiIds, multiLinkProcessor, multiLists, nodeData, nodeFilter, nodeLinksProcessor, otherNodeData, otherNodeId, otherNodes, processedLinks, _i, _j, _k, _l, _len, _len1, _len2, _len3;
                        nodeData = this.nodes[nodeId];
                        links = this.nodeToLinks[nodeId];
                        if (!(links && links.length > 0)) {
                return[]
                }
                linkFilter = this.settings.filters.linkFilter;
                        nodeFilter = this.settings.filters.nodeFilter;
                        nodeLinksProcessor = this.settings.filters.nodeLinksProcessor;
                        multiLinkProcessor = this.settings.filters.multilinkProcessor;
                        if (nodeFilter && !nodeFilter(nodeData, nodeData.loaded ? links : null)) {
                return[]
                }
                if (nodeFilter || linkFilter) {
                filtered = [];
                        for (_i = 0, _len = links.length; _i < _len; _i++) {
                link = links[_i];
                        otherNodeId = Netchart_Data.otherEnd(link, nodeId);
                        otherNodeData = this.nodes[otherNodeId];
                        if (linkFilter) {
                if (link.from === nodeId) {
                d1 = nodeData;
                        d2 = otherNodeData
                } else {
                d1 = otherNodeData;
                        d2 = nodeData
                }
                if (!linkFilter(link, d1, d2)) {
                continue
                }
                }
                if (nodeFilter && !nodeFilter(otherNodeData, otherNodeData.loaded ? this.nodeToLinks[otherNodeId] : null)) {
                continue
                }
                filtered.push(link)
                }
                links = filtered
                }
                if (nodeLinksProcessor) {
                links = nodeLinksProcessor(nodeData, links)
                }
                if (multiLinkProcessor) {
                otherNodes = {};
                        for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
                link = links[_j];
                        otherNodes[Netchart_Data.otherEnd(link, nodeId)] = true
                }
                if (Base_Helpers.countProperties(otherNodes) < links.length) {
                filtered = [];
                        multiIds = {};
                        multiLists = {};
                        for (_k = 0, _len2 = links.length; _k < _len2; _k++) {
                l = links[_k];
                        multiId = Netchart_Data.multiLinkId(l);
                        if (multiIds.hasOwnProperty(multiId)) {
                if (!multiLists.hasOwnProperty(multiId)) {
                multiLists[multiId] = [multiIds[multiId], l]
                } else {
                multiLists[multiId].push(l)
                }
                } else {
                multiIds[multiId] = l
                }
                }
                for (_l = 0, _len3 = links.length; _l < _len3; _l++) {
                l = links[_l];
                        multiId = Netchart_Data.multiLinkId(l);
                        if (!multiLists.hasOwnProperty(multiId)) {
                filtered.push(l)
                }
                }
                for (id in multiLists) {
                links = multiLists[id];
                        l = links[0];
                        processedLinks = multiLinkProcessor(links, this.nodes[l.from], this.nodes[l.to]);
                        if (Base_Helpers.isArray(processedLinks)) {
                filtered.concat(processedLinks)
                } else {
                if (processedLinks) {
                filtered.push(processedLinks)
                }
                }
                }
                links = filtered
                }
                }
                return links
                };
                Netchart_Data.prototype.getAllNodes = function(callback) {
                var id, n, nodes, res;
                        if (!this.dataFunc) {
                nodes = (function() {
                var _ref, _results;
                        _ref = this.nodes;
                        _results = [];
                        for (id in _ref) {
                n = _ref[id];
                        _results.push(id)
                }
                return _results
                }).call(this);
                        if (callback) {
                callback(nodes)
                }
                return false
                } else {
                res = (function(_this) {
                return function(data) {
                _this.dataArrived(null, data);
                        nodes = (function() {
                        var _ref, _results;
                                _ref = this.nodes;
                                _results = [];
                                for (id in _ref) {
                        n = _ref[id];
                                _results.push(id)
                        }
                        return _results
                        }).call(_this);
                        if (callback) {
                return callback(nodes)
                }
                }
                })(this);
                        this.dataFunc(null, res, this.dataError);
                        return true
                }
                };
                Netchart_Data.prototype.requestNodeData = function(nodeId) {
                if (this.pendingNodes.hasOwnProperty(nodeId) || this.requestedNodes.hasOwnProperty(nodeId)) {
                return
                }
                this.pendingNodes[nodeId] = true;
                        if ((this.dataFunc != null) && !this.requestScheduled) {
                this.requestScheduled = true;
                        return setTimeout(this.runRequests, 0)
                }
                };
                Netchart_Data.prototype.runRequests = function() {
                var id, r, remainingRequests, time, timeout, _i, _j, _len, _len1, _ref, _ref1;
                        if (this.removed) {
                return
                }
                this.requestScheduled = false;
                        time = new Date().getTime();
                        timeout = this.settings.data.requestTimeout;
                        if (this.cleanupScheduled) {
                this.cleanupScheduled = false;
                        remainingRequests = [];
                        _ref = this.requests;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                r = _ref[_i];
                        if (r.time + timeout > time) {
                remainingRequests.push(r)
                } else {
                _ref1 = r.nodes;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                id = _ref1[_j];
                        if (this.requestedNodes[id]) {
                delete this.requestedNodes[id];
                        this.pendingNodes[id] = true
                }
                }
                if (r.time !== 0) {
                this.chart.error("Data request timed out, timeout " + timeout + " ms")
                }
                }
                }
                this.requests = remainingRequests
                }
                while (Base_Helpers.hasProperties(this.pendingNodes) && this.requests.length < this.settings.data.numberOfParralelRequests) {
                (function(_this) {
                return(function() {
                var failFunc, nodes, okFunc, request, _, _ref2;
                        nodes = [];
                        _ref2 = _this.pendingNodes;
                        for (id in _ref2) {
                _ = _ref2[id];
                        nodes.push(id);
                        delete _this.pendingNodes[id];
                        _this.requestedNodes[id] = true;
                        if (nodes.length > _this.settings.data.requestMaxUnits) {
                break
                }
                }
                _this.chart.log("Requesting data on " + nodes);
                        request = {time: time, nodes: nodes};
                        okFunc = function(data) {
                        return _this.dataArrived(request, data)
                        };
                        failFunc = function() {
                        return _this.dataError(request)
                        };
                        _this.dataFunc(nodes, okFunc, failFunc);
                        return _this.requests.push(request)
                })
                })(this)()
                }
                if (this.requests.length > 0 && !this.cleanupScheduled) {
                this.cleanupScheduled = true;
                        return setTimeout(this.runRequests, timeout)
                }
                };
                Netchart_Data.prototype.dataError = function(request) {
                if (this.removed) {
                return
                }
                this.chart.error("Data request failed for nodes: " + request.nodes);
                        request.time = 0;
                        this.cleanupScheduled = true;
                        return this.runRequests()
                };
                Netchart_Data.prototype.dataArrived = function(request, rawData) {
                var allOk, data, hasLoadedRequestedNodes, hasResultsOnRequestedNodes, id, ids, key, loaded, n, nodes, obj, required, updatedLinks, updatedNodes, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _m, _n, _o, _p, _q, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
                        if (this.removed) {
                return
                }
                allOk = false;
                        if (rawData) {
                data = Base_Helpers.parseData(rawData, this.settings.data.format, this.chart);
                        if (data.error != null) {
                this.chart.error(data.error)
                }
                allOk = true;
                        _ref = ["links", "nodes"];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                required = _ref[_i];
                        if (!data.hasOwnProperty(required)) {
                data[required] = []
                }
                }
                if (allOk) {
                if (!Base_Helpers.isArray(data.nodes)) {
                obj = data.nodes;
                        data.nodes = [];
                        for (key in obj) {
                value = obj[key];
                        value.id = key;
                        data.nodes.push(value)
                }
                }
                if (!Base_Helpers.isArray(data.links)) {
                obj = data.links;
                        data.links = [];
                        for (key in obj) {
                value = obj[key];
                        value.id = key;
                        data.links.push(value)
                }
                }
                if (request) {
                this.chart.log("Got " + data.nodes.length + " data on  " + request.nodes)
                } else {
                this.chart.log("Got " + data.nodes.length + " data on all nodes")
                }
                hasResultsOnRequestedNodes = !(request && data.nodes.length > 0);
                        hasLoadedRequestedNodes = !(request && data.nodes.length > 0);
                        ids = {};
                        _ref1 = data.nodes;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                n = _ref1[_j];
                        if (ids.hasOwnProperty(n.id)) {
                this.chart.error("Data response: Multiple nodes with the same ID: " + n.id)
                }
                ids[n.id] = true;
                        if (request && Base_Helpers.arrayContains(request.nodes, n.id)) {
                hasResultsOnRequestedNodes = true;
                        hasLoadedRequestedNodes || (hasLoadedRequestedNodes = n.loaded)
                }
                }
                ids = {};
                        _ref2 = data.links;
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                n = _ref2[_k];
                        if (n.hasOwnProperty("id") && ids.hasOwnProperty(n.id)) {
                this.chart.error("Data response: Multiple links with the same ID: " + n.id)
                }
                ids[n.id] = true
                }
                if (!hasResultsOnRequestedNodes) {
                this.chart.error("Data response: Results set did not contain requested nodes")
                } else {
                if (!hasLoadedRequestedNodes) {
                this.chart.error("Data response: loaded field was not set on any of the requested nodes, adding manually");
                        _ref3 = data.nodes;
                        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                n = _ref3[_l];
                        if (Base_Helpers.arrayContains(request.nodes, n.id)) {
                n.loaded = true
                }
                }
                }
                }
                }
                } else {
                this.chart.error("Got empty response")
                }
                loaded = {};
                        if (!allOk) {
                nodes = [];
                        _ref4 = request.nodes;
                        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
                id = _ref4[_m];
                        nodes.push({id: id, error: "Bad response", loaded: true})
                }
                data = {nodes: nodes, links: []}
                }
                this.updateGraph(data, request);
                        _ref5 = data.nodes;
                        for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
                n = _ref5[_n];
                        if (n.loaded) {
                loaded[n.id] = true;
                        delete this.requestedNodes[n.id]
                }
                if (n.error) {
                delete this.requestedNodes[n.id];
                        loaded[n.id] = true
                }
                }
                updatedNodes = {};
                        updatedLinks = {};
                        _ref6 = data.nodes;
                        for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
                n = _ref6[_o];
                        if (!this.isFilteredNode(n.id)) {
                updatedNodes[n.id] = true
                }
                }
                _ref7 = data.links;
                        for (_p = 0, _len7 = _ref7.length; _p < _len7; _p++) {
                n = _ref7[_p];
                        updatedLinks[n.id] = true
                }
                this.chart.events.notifySceneChanges({dataArrived: true, dataLoadedNodesIds: loaded, dataNodesIds: updatedNodes, dataLinksIds: updatedLinks});
                        if (request) {
                Base_Helpers.removeFromArray(this.requests, request);
                        _ref8 = request.nodes;
                        for (_q = 0, _len8 = _ref8.length; _q < _len8; _q++) {
                n = _ref8[_q];
                        if (this.requestedNodes[n]) {
                this.pendingNodes[n] = true;
                        delete this.requestedNodes[n]
                }
                }
                return this.runRequests()
                }
                };
                Netchart_Data.prototype.updateGraph = function(data, request) {
                var n, orig, _i, _j, _len, _len1, _ref, _ref1;
                        _ref = data.nodes;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                n = _ref[_i];
                        n.id = n.id.toString();
                        if (!request) {
                n.loaded = true
                }
                if (this.nodes.hasOwnProperty(n.id)) {
                if (!n.error && n.loaded) {
                delete this.nodes[n.id]["_noData"];
                        Base_Helpers.extendDeep(this.nodes[n.id], n)
                }
                } else {
                this.nodes[n.id] = n;
                        this.nodeToLinks[n.id] = []
                }
                }
                _ref1 = data.links;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                n = _ref1[_j];
                        if (n.hasOwnProperty("id")) {
                n.id = n.id.toString()
                } else {
                n.id = "°" + this.nextLinkId;
                        this.nextLinkId += 1
                }
                if (this.links.hasOwnProperty(n.id)) {
                orig = this.links[n.id];
                        if (n.hasOwnProperty("from")) {
                n.from = n.from.toString()
                }
                if (n.hasOwnProperty("to")) {
                n.to = n.to.toString()
                }
                if ((n.from && orig.from !== n.from) || (n.to && orig.to !== n.to)) {
                this.chart.error("Changing link from,to not supported")
                } else {
                Base_Helpers.extendDeep(orig, n)
                }
                } else {
                if (!n.hasOwnProperty("from")) {
                this.chart.error("Link.from missing for link " + n.id);
                        continue
                } else {
                n.from = n.from.toString()
                }
                if (!n.hasOwnProperty("to")) {
                this.chart.error("Link.to missing for link " + n.id);
                        continue
                } else {
                n.to = n.to.toString()
                }
                if (!this.nodes.hasOwnProperty(n.from)) {
                this.nodes[n.from] = {id: n.from, _noData: true};
                        this.nodeToLinks[n.from] = [];
                        if (!request) {
                this.nodes[n.from].loaded = true
                }
                }
                if (!this.nodes.hasOwnProperty(n.to)) {
                this.nodes[n.to] = {id: n.to, _noData: true};
                        this.nodeToLinks[n.to] = [];
                        if (!request) {
                this.nodes[n.to].loaded = true
                }
                }
                this.links[n.id] = n;
                        this.nodeToLinks[n.from].push(n);
                        this.nodeToLinks[n.to].push(n)
                }
                }
                };
                Netchart_Data.prototype.removeData = function(data) {
                var l, link, linksToRemove, node, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
                        linksToRemove = [];
                        if (data.nodes) {
                _ref = data.nodes;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        this.removeNode(node.id, linksToRemove)
                }
                }
                if (data.links) {
                _ref1 = data.links;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                link = _ref1[_j];
                        l = this.links[link.id];
                        if (l) {
                this.removeLink(l)
                }
                }
                }
                _results = [];
                        for (_k = 0, _len2 = linksToRemove.length; _k < _len2; _k++) {
                link = linksToRemove[_k];
                        _results.push(this.removeLink(link))
                }
                return _results
                };
                Netchart_Data.prototype.removeNode = function(nodeId, linksToRemove) {
                var link, links, n, _i, _len, _results;
                        this.chart.graph.removeNode(nodeId);
                        delete this.pendingNodes[nodeId];
                        delete this.requestedNodes[nodeId];
                        n = this.nodes[nodeId];
                        if (!n) {
                return
                }
                delete this.nodes[nodeId];
                        links = this.nodeToLinks[nodeId];
                        if (links) {
                delete this.nodeToLinks[nodeId];
                        _results = [];
                        for (_i = 0, _len = links.length; _i < _len; _i++) {
                link = links[_i];
                        _results.push(linksToRemove.push(link))
                }
                return _results
                }
                };
                Netchart_Data.prototype.removeLink = function(link) {
                this.chart.graph.removeLink(link.id);
                        delete this.links[link.id];
                        if (this.nodeToLinks[link.from]) {
                Base_Helpers.removeFromArray(this.nodeToLinks[link.from], link)
                }
                if (this.nodeToLinks[link.to]) {
                return Base_Helpers.removeFromArray(this.nodeToLinks[link.to], link)
                }
                };
                Netchart_Data.prototype.genRandomGraph = function(settings) {
                var data, link, node, numLinks, numNodes, _i, _j, _len, _len1, _ref, _ref1;
                        numNodes = settings.randomNodes;
                        numLinks = settings.randomLinks;
                        if (settings.random === "grid") {
                data = this.genRandomGrid(numNodes, settings.randomGridLinkProbability)
                } else {
                data = this.genRandomUniform(numNodes, numLinks)
                }
                _ref = data.nodes;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        node.style = {label: "Node " + node.id};
                        node.value = 10 + Math.random() * 40
                }
                _ref1 = data.links;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                link = _ref1[_j];
                        link.style = {label: "Link " + link.id};
                        link.value = 1 + Math.random() * 5
                }
                return data
                };
                Netchart_Data.prototype.genRandomGrid = function(numNodes, linkProbability) {
                var gridSize, i, ind, l, links, n, nodes, x, y, _i, _j, _k, _l, _len, _ref, _ref1, _ref2;
                        nodes = [];
                        links = [];
                        for (i = _i = 0, _ref = numNodes - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
                n = {id: "n" + i, loaded: true};
                        nodes.push(n)
                }
                gridSize = Math.ceil(Math.sqrt(numNodes));
                        for (y = _j = 0, _ref1 = gridSize - 1; _j <= _ref1; y = _j += 1) {
                for (x = _k = 0, _ref2 = gridSize - 1; _k <= _ref2; x = _k += 1) {
                ind = x + y * gridSize;
                        if (ind >= numNodes) {
                continue
                }
                if (x > 0 && Math.random() <= linkProbability) {
                links.push({from: "n" + ind, to: "n" + (ind - 1)})
                }
                if (y > 0 && Math.random() <= linkProbability) {
                links.push({from: "n" + ind, to: "n" + (ind - gridSize)})
                }
                }
                }
                for (ind = _l = 0, _len = links.length; _l < _len; ind = ++_l) {
                l = links[ind];
                        l.id = "" + ind
                }
                return{nodes: nodes, links: links}
                };
                Netchart_Data.prototype.genRandomUniform = function(numNodes, numLinks) {
                var i, l, links, n, nodes, _i, _j, _ref, _ref1, _ref2;
                        nodes = [];
                        links = [];
                        for (i = _i = 0, _ref = numNodes - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
                n = {id: "n" + i, loaded: true};
                        if (nodes.length > 0) {
                l = {id: "l" + i, from: n.id, to: nodes[Math.random() * nodes.length | 0].id};
                        links.push(l)
                }
                nodes.push(n)
                }
                for (i = _j = _ref1 = links.length, _ref2 = numLinks - 1; _j <= _ref2; i = _j += 1) {
                l = {id: "l" + (i + 1), from: nodes[Math.random() * nodes.length | 0].id, to: nodes[Math.random() * nodes.length | 0].id};
                        links.push(l)
                }
                return{nodes: nodes, links: links}
                };
                Netchart_Data.prototype.getDataFunction = function() {
                var config;
                        config = this.settings.data;
                        if (config.dataFunction) {
                return config.dataFunction
                } else {
                if (config.url) {
                return function(nodes, success, fail) {
                var params;
                        params = [];
                        if (nodes != null) {
                params.push(["nodes", nodes.toString()])
                }
                return Base_Helpers.doRequest(config.url, params, success, fail)
                }
                } else {
                return null
                }
                }
                };
                Netchart_Data.prototype.exportData = function() {
                var id, l, links, n, nodes, _ref, _ref1;
                        nodes = [];
                        links = [];
                        _ref = this.nodes;
                        for (id in _ref) {
                n = _ref[id];
                        nodes.push(n)
                }
                _ref1 = this.links;
                        for (id in _ref1) {
                l = _ref1[id];
                        links.push(l)
                }
                return{nodes: nodes, links: links}
                };
                return Netchart_Data
        })();
        var Netchart_Graph;
        Netchart_Graph = (function() {
        function Netchart_Graph(chart) {
        this.chart = chart;
                this.settings = this.chart.settings;
                this.scene = this.chart.scene;
                this.idToNode = {};
                this.idToLink = {};
                this.state = {};
                this.userLoading = false
        }
        Netchart_Graph.prototype.exportCoordinates = function(nodesDataList) {
        var n, node, _i, _len;
                for (_i = 0, _len = nodesDataList.length; _i < _len; _i++) {
        node = nodesDataList[_i];
                n = this.idToNode[node.id];
                if (n) {
        node.x = n.x;
                node.y = n.y
        }
        }
        };
                Netchart_Graph.prototype.save = function() {
                var id, node, state, _ref;
                        state = {};
                        _ref = this.idToNode;
                        for (id in _ref) {
                node = _ref[id];
                        state[node.id] = {x: node.x, y: node.y, r: node.currentRadius, w: node.currentHwidth}
                }
                return state
                };
                Netchart_Graph.prototype.restore = function(state) {
                var id, n, s;
                        this.state = {};
                        for (id in state) {
                s = state[id];
                        if (this.idToNode.hasOwnProperty(id)) {
                n = this.idToNode[id];
                        n.x = s.x;
                        n.y = s.y;
                        n.currentRadius = s.r;
                        n.currentHwidth = s.w ? s.w : s.r
                } else {
                this.state[id] = s
                }
                }
                };
                Netchart_Graph.prototype.lockNode = function(nodeId, x, y) {
                var n;
                        if (!this.idToNode.hasOwnProperty(nodeId)) {
                return this.chart.error("Locking nonexistant node: " + nodeId)
                } else {
                n = this.idToNode[nodeId];
                        n.userLock = true;
                        if (x !== void 0 && y !== void 0) {
                n.x = x;
                        n.y = y
                }
                return this.scene.touchNode(n)
                }
                };
                Netchart_Graph.prototype.unlockNode = function(nodeId) {
                var n;
                        if (!this.idToNode.hasOwnProperty(nodeId)) {
                return this.chart.error("Locking nonexistant node: " + nodeId)
                } else {
                n = this.idToNode[nodeId];
                        n.userLock = false;
                        return this.scene.touchNode(n)
                }
                };
                Netchart_Graph.prototype.addNode = function(nodeId) {
                var data, n, s;
                        n = this.scene.addNode(nodeId);
                        n.dataLinks = [];
                        this.idToNode[nodeId] = n;
                        data = this.scene.data.getNodeData(nodeId);
                        if (!data) {
                throw"Internal error"
                }
                n.data = data;
                        if (data.x != null) {
                n.x = data.x
                }
                if (data.y != null) {
                n.y = data.y
                }
                if (this.state.hasOwnProperty(nodeId)) {
                s = this.state[nodeId];
                        delete this.state[nodeId];
                        n.x = s.x;
                        n.y = s.y;
                        n.currentRadius = s.r;
                        n.currentHwidth = s.w ? s.w : s.r
                }
                return n
                };
                Netchart_Graph.prototype.tryAddLink = function(linkData) {
                var link;
                        if (this.idToLink.hasOwnProperty(linkData.id)) {
                link = this.idToLink[linkData.id];
                        if (link.data !== linkData) {
                link.data = linkData;
                        this.scene.touchLink(link)
                }
                return link
                }
                if (this.idToNode.hasOwnProperty(linkData.from) && this.idToNode.hasOwnProperty(linkData.to)) {
                link = this.scene.addLink(linkData.id, linkData.from, linkData.to);
                        link.data = linkData;
                        this.idToLink[linkData.id] = link;
                        link.from = this.idToNode[linkData.from];
                        link.from.links.push(link);
                        this.scene.touchNode(link.from);
                        link.to = this.idToNode[linkData.to];
                        link.to.links.push(link);
                        this.scene.touchNode(link.to);
                        return link
                } else {
                return null
                }
                };
                Netchart_Graph.prototype.removeNode = function(nodeId) {
                var link, node, other, _i, _len, _ref;
                        if (!this.idToNode.hasOwnProperty(nodeId)) {
                return
                }
                node = this.idToNode[nodeId];
                        _ref = node.links;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                link = _ref[_i];
                        delete this.idToLink[link.id];
                        other = link.otherEnd(node);
                        if (other !== node) {
                Base_Helpers.removeFromArray(other.links, link);
                        this.scene.touchNode(other)
                }
                this.scene.removeLink(link)
                }
                node.links = [];
                        delete this.idToNode[nodeId];
                        this.scene.removeNode(node);
                        return this.scene.data.nodeRemoved(nodeId)
                };
                Netchart_Graph.prototype.removeLink = function(linkId) {
                var link;
                        if (this.idToLink.hasOwnProperty(linkId)) {
                link = this.idToLink[linkId];
                        delete this.idToLink[linkId];
                        Base_Helpers.removeFromArray(link.from.links, link);
                        Base_Helpers.removeFromArray(link.to.links, link);
                        this.scene.touchNode(link.from);
                        this.scene.touchNode(link.to);
                        return this.scene.removeLink(link)
                }
                };
                Netchart_Graph.prototype.removeAll = function() {
                return this.replaceGraph({}, {})
                };
                Netchart_Graph.prototype.exportData = function() {
                var id, l, links, n, nodes, _ref, _ref1;
                        nodes = [];
                        links = [];
                        _ref = this.idToNode;
                        for (id in _ref) {
                n = _ref[id];
                        nodes.push(n.data)
                }
                _ref1 = this.idToLink;
                        for (id in _ref1) {
                l = _ref1[id];
                        links.push(l.data)
                }
                return{nodes: nodes, links: links}
                };
                Netchart_Graph.prototype.replaceGraph = function(nodesSet, expandedLinks) {
                var existingLink, existingNode, fromId, id, idToLink, idToNode, isNewGraph, l, link, linkData, links, newIdToLink, node, oldLinks, oldNodes, toId, _, _i, _len;
                        isNewGraph = true;
                        newIdToLink = {};
                        oldNodes = this.idToNode;
                        this.idToNode = idToNode = {};
                        for (id in nodesSet) {
                _ = nodesSet[id];
                        existingNode = oldNodes[id];
                        if (existingNode) {
                isNewGraph = false;
                        idToNode[id] = existingNode;
                        l = existingNode.links;
                        while (l.length > 0) {
                l.pop()
                }
                } else {
                existingNode = this.addNode(id)
                }
                if (expandedLinks.hasOwnProperty(id)) {
                existingNode.dataLinks = links = expandedLinks[id];
                        for (_i = 0, _len = links.length; _i < _len; _i++) {
                l = links[_i];
                        newIdToLink[l.id] = l
                }
                }
                }
                oldLinks = this.idToLink;
                        this.idToLink = idToLink = {};
                        for (id in newIdToLink) {
                linkData = newIdToLink[id];
                        existingLink = oldLinks[id];
                        if (existingLink) {
                fromId = linkData.from;
                        toId = linkData.to;
                        if (idToNode.hasOwnProperty(fromId) && idToNode.hasOwnProperty(toId)) {
                idToNode[fromId].links.push(existingLink);
                        idToNode[toId].links.push(existingLink);
                        idToLink[id] = existingLink
                }
                } else {
                this.tryAddLink(linkData)
                }
                }
                for (id in oldLinks) {
                link = oldLinks[id];
                        if (!idToLink.hasOwnProperty(id)) {
                this.scene.touchNode(link.from);
                        this.scene.touchNode(link.to);
                        this.scene.removeLink(link)
                }
                }
                for (id in oldNodes) {
                node = oldNodes[id];
                        if (!idToNode.hasOwnProperty(id)) {
                this.scene.removeNode(node)
                }
                }
                return isNewGraph
                };
                Netchart_Graph.prototype.updateNodesWithNewData = function(nodesWithNewData) {
                var id, node, _, _results;
                        _results = [];
                        for (id in nodesWithNewData) {
                _ = nodesWithNewData[id];
                        if (this.idToNode.hasOwnProperty(id)) {
                node = this.idToNode[id];
                        node.data = this.scene.data.getNodeData(id);
                        _results.push(this.scene.touchNode(node))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                Netchart_Graph.prototype.updateLinksWithNewData = function(linksWithNewData) {
                var data, id, link, _results;
                        _results = [];
                        for (id in linksWithNewData) {
                data = linksWithNewData[id];
                        if (this.idToLink.hasOwnProperty(id)) {
                link = this.idToLink[id];
                        link.data = this.scene.data.getLinkData(id);
                        _results.push(this.scene.touchLink(link))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                return Netchart_Graph
        })();
        var Netchart_Navigator;
        Netchart_Navigator = (function() {
        Netchart_Navigator.prototype.FocusNode = (function() {
        function _Class() {
        }
        _Class.prototype.id = null;
                _Class.prototype.relevance = - 1;
                _Class.prototype.initial = false;
                _Class.prototype.stopped = false;
                _Class.prototype.hidden = false;
                _Class.prototype.expanded = false;
                _Class.prototype.collapsed = false;
                _Class.prototype.actionId = 0;
                return _Class
        })();
                Netchart_Navigator.prototype.lastExpandTime = 0;
                Netchart_Navigator.prototype.nextId = 0;
                Netchart_Navigator.prototype.animationPriority = 1005;
                Netchart_Navigator.prototype.otherEnd = Netchart_Data.otherEnd;
                Netchart_Navigator.prototype.hasData = false;
                function Netchart_Navigator(chart) {
                this.chart = chart;
                        this.graph = this.chart.graph;
                        this.scene = this.chart.scene;
                        this.nodes = {}
                }
        Netchart_Navigator.prototype.clear = function() {
        this.chart.events.notifySceneChanges({navigation: true});
                return this.nodes = {}
        };
                Netchart_Navigator.prototype.addAction = function(nodeId, params) {
                var a;
                        this.chart.events.notifySceneChanges({navigation: true});
                        a = new this.FocusNode();
                        a.id = nodeId;
                        a.actionId = this.nextId;
                        this.nextId += 1;
                        Base_Helpers.extend(a, params);
                        this.nodes[nodeId] = a;
                        return a
                };
                Netchart_Navigator.prototype.updateAction = function(nodeId, params) {
                var a;
                        this.chart.events.notifySceneChanges({navigation: true});
                        a = this.nodes[nodeId];
                        a.actionId = this.nextId;
                        this.nextId += 1;
                        Base_Helpers.extend(a, params);
                        return a
                };
                
                
                Netchart_Navigator.prototype.addAction1 = function(nodeId, params) {
                        var a;
                        this.chart.events.notifySceneChanges({navigation: true});
                        a = new this.FocusNode();
                        a.id = nodeId;
                        a.actionId = this.nextId;
                        this.nextId += 1;
                        Base_Helpers.extend1(a, params);
                        this.nodes[nodeId] = a;
                        return a
                };
                Netchart_Navigator.prototype.updateAction1 = function(nodeId, params) {
                        var a;
                        this.chart.events.notifySceneChanges({navigation: true});
                        a = this.nodes[nodeId];
                        a.actionId = this.nextId;
                        this.nextId += 1;
                        Base_Helpers.extend1(a, params);
                        return a
                };
                
                
                
                Netchart_Navigator.prototype.hideNode = function(nodeId) {
                return this.addAction(nodeId, {hidden: true})
                };
                Netchart_Navigator.prototype.collapseNode = function(nodeId) {
                return this.addAction(nodeId, {collapsed: true, expanded: false})
                };
                // ???????????????
                Netchart_Navigator.prototype.runMovingMessage = function(nodeId1, nodeId2, messageType, tick) { 
                    

                    if (this.nodes[nodeId1]) {// && this.nodes[nodeId1].initial) {
                        //console.log("update     " + "id1:" + nodeId1 + ", id2:" + nodeId2);
                        this.updateAction1(nodeId1, {ifSendingMessageIndex: true, toNodeIdIndex: nodeId2, runMovingMessageType: messageType, movingMessageSpeed:tick});
                    } else {
                        //console.log("add        " + "id1:" + nodeId1 + ", id2:" + nodeId2);
                        this.addAction1(nodeId1, {ifSendingMessageIndex: true, toNodeIdIndex: nodeId2, runMovingMessageType: messageType, movingMessageSpeed:tick});
                    }
                    
                    return;
                };
                Netchart_Navigator.prototype.addFocusNode = function(nodeId, relevance) {
                if (relevance == null) {
                relevance = - 1
                }
                return this.addAction(nodeId, {relevance: relevance, initial: true})
                };
                Netchart_Navigator.prototype.expandNode = function(nodeId) {
                if (this.nodes[nodeId] && this.nodes[nodeId].initial) {
                return this.updateAction(nodeId, {expanded: true})
                } else {
                return this.addAction(nodeId, {expanded: true})
                }
                };
                Netchart_Navigator.prototype.unexpandNode = function(nodeId) {
                if (this.nodes[nodeId]) {
                return this.updateAction(nodeId, {initial: false})
                }
                };
                Netchart_Navigator.prototype.save = function() {
                return this.nodes
                };
                Netchart_Navigator.prototype.restore = function(state) {
                var a, nodeId, _ref;
                        this.nodes = state;
                        this.nextId = 0;
                        _ref = this.nodes;
                        for (nodeId in _ref) {
                a = _ref[nodeId];
                        this.nextId = Math.max(a.actionId, this.nextId)
                }
                this.nextId++;
                        return this.chart.events.notifySceneChanges({navigation: true})
                };
                Netchart_Navigator.prototype.onNewDataObject = function() {
                this.hasData = false;
                        if (this.scene.settings.navigation.mode === "showall") {
                return this.scene.loading = this.scene.data.getAllNodes()
                } else {
                return this.scene.loading = false
                }
                };
                Netchart_Navigator.prototype.showInitialNodes = function() {
                var id, initialNodes, settings, _i, _j, _len, _len1, _results, _results1;
                        this.clear();
                        this.graph.removeAll();
                        settings = this.scene.settings.navigation;
                        initialNodes = settings.initialNodes;
                        if (Base_Helpers.isString(initialNodes)) {
                initialNodes = [initialNodes]
                } else {
                if (!Base_Helpers.isArray(initialNodes)) {
                initialNodes = []
                }
                }
                if (settings.mode === "focusnodes") {
                _results = [];
                        for (_i = 0, _len = initialNodes.length; _i < _len; _i++) {
                id = initialNodes[_i];
                        this.scene.userNodeIds[id] = true;
                        _results.push(this.addFocusNode(id, - 1))
                }
                return _results
                } else {
                if (settings.mode === "manual") {
                _results1 = [];
                        for (_j = 0, _len1 = initialNodes.length; _j < _len1; _j++) {
                id = initialNodes[_j];
                        this.scene.userNodeIds[id] = true;
                        _results1.push(this.addFocusNode(id, 1))
                }
                return _results1
                } else {
                if (settings.mode === "showall" || true) {
                return 1
                }
                }
                }
                };
                Netchart_Navigator.prototype.commitChanges = function(changes) {
                return this.onSceneChange({changes: changes})
                };
                Netchart_Navigator.prototype.onSceneChange = function(event) {
                var exp, expandUnfinished, expandedLinks, linksWithNewData, loadingNodes, nodesWithNewData, rel, time, visibleNodes, _ref;
                        if (!(event.changes.navigation || event.changes.dataArrived || this.scene.hasTopologyChanges() || event.changes.settings || event.changes.data)) {
                return
                }
                this.scene.loading = false;
                        time = new Date().getTime();
                        if (this.scene.settings.navigation.expandDelay && this.lastExpandTime > time - this.scene.settings.navigation.expandDelay && !event.changes.filters && this.hasData && !this.dataArrived) {
                this.chart.events.notifySceneChanges({navigation: true});
                        return
                }
                if (event.changes.dataArrived) {
                this.hasData = true
                }
                this.resolveConflicts();
                        _ref = this.computeRelevances(), rel = _ref[0], exp = _ref[1], expandedLinks = _ref[2], expandUnfinished = _ref[3], loadingNodes = _ref[4];
                        visibleNodes = rel;
                        if (!this.hasData) {
                this.scene.loading = Base_Helpers.hasProperties(rel);
                        return
                }
                if (expandUnfinished && this.scene.settings.navigation.expandDelay) {
                this.lastExpandTime = time;
                        this.chart.events.notifySceneChanges({navigation: true})
                }
                if (event.changes.dataArrived) {
                nodesWithNewData = event.changes.dataNodesIds;
                        linksWithNewData = event.changes.dataLinksIds
                } else {
                nodesWithNewData = {};
                        linksWithNewData = {}
                }
                event.changes.newGraph = this.updateGraph(visibleNodes, expandedLinks, nodesWithNewData, linksWithNewData);
                        return this.applyRelevances(rel, exp, loadingNodes)
                };
                Netchart_Navigator.prototype.resolveConflicts = function() {
                var a, focusNodes, i, id, link, links, maxFocusNodes, nodeId, otherFocus, otherNodeId, _i, _len, _ref, _ref1, _results;
                        _ref = this.nodes;
                        _results = [];
                        for (nodeId in _ref) {
                a = _ref[nodeId];
                        if (this.scene.settings.navigation.mode !== "focusnodes" && this.scene.data.isFilteredNode(nodeId)) {
                delete this.nodes[nodeId];
                        continue
                }
                if (!a.initial && !a.hidden && !this.graph.idToNode.hasOwnProperty(nodeId)) {
                delete this.nodes[nodeId];
                        continue
                }
                if (a.expanded) {
                links = this.scene.data.getNodeCollectedLinks(nodeId);
                        for (_i = 0, _len = links.length; _i < _len; _i++) {
                link = links[_i];
                        otherNodeId = this.otherEnd(link, nodeId);
                        otherFocus = this.nodes[otherNodeId];
                        if (otherFocus && otherFocus.actionId < a.actionId && otherFocus.hidden) {
                delete this.nodes[otherNodeId]
                }
                }
                }
                if (this.scene.settings.navigation.mode === "focusnodes") {
                maxFocusNodes = this.scene.settings.navigation.numberOfFocusNodes;
                        focusNodes = [];
                        _ref1 = this.nodes;
                        for (id in _ref1) {
                a = _ref1[id];
                        if (a.initial) {
                focusNodes.push(a)
                }
                }
                focusNodes.sort(function(a, b) {
                return a.actionId - b.actionId
                });
                        i = 0;
                        _results.push((function() {
                        var _results1;
                                _results1 = [];
                                while (focusNodes.length - i > maxFocusNodes) {
                        focusNodes[i].initial = false;
                                _results1.push(i++)
                        }
                        return _results1
                        })())
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                Netchart_Navigator.prototype.computeRelevances = function() {
                var a, autoExpandFilterFunc, cold, cooldown, data, dataNodes, expand, expandIncremental, expandUnfinished, expandedLinks, expandedNodes, expandedRelevances, focusNodes, graphNodes, id, linkData, links, loadingNodes, mode, n1, n1rel, preloadNodeLinks, q1, queue, r, rel, _, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
                        this.changes = false;
                        graphNodes = this.graph.idToNode;
                        dataNodes = this.scene.data.nodes;
                        preloadNodeLinks = this.scene.settings.data.preloadNodeLinks;
                        expandedRelevances = {};
                        expandedNodes = {};
                        expandedLinks = {};
                        loadingNodes = {};
                        queue = {};
                        expandIncremental = !!this.scene.settings.navigation.expandDelay && mode === "focusnodes";
                        expandUnfinished = false;
                        autoExpandFilterFunc = this.scene.settings.navigation.nodeAutoExpandFilter;
                        mode = this.scene.settings.navigation.mode;
                        if (mode === "focusnodes") {
                focusNodes = [];
                        _ref = this.nodes;
                        for (id in _ref) {
                a = _ref[id];
                        if (a.initial) {
                focusNodes.push(a)
                }
                }
                focusNodes.sort(function(a, b) {
                return b.actionId - a.actionId
                });
                        cooldown = this.scene.settings.navigation.focusHistoryRelevanceCooldown;
                        cold = 0;
                        for (_i = 0, _len = focusNodes.length; _i < _len; _i++) {
                a = focusNodes[_i];
                        id = a.id;
                        r = a.relevance;
                        if (r < 0) {
                r = 1 + parseFloat(this.scene.settings.navigation.focusNodeExpansionRadius)
                }
                r = Math.max(0, r - cold);
                        cold += cooldown;
                        expandedRelevances[id] = r;
                        queue[id] = true
                }
                } else {
                if (mode === "manual") {
                focusNodes = [];
                        _ref1 = this.nodes;
                        for (id in _ref1) {
                a = _ref1[id];
                        focusNodes.push(a)
                }
                focusNodes.sort(function(a, b) {
                return b.actionId - a.actionId
                });
                        _ref2 = this.nodes;
                        for (id in _ref2) {
                a = _ref2[id];
                        if (!a.collapsed) {
                queue[id] = true;
                        expandedRelevances[id] = a.relevance
                }
                }
                if (!Base_Helpers.hasProperties(queue) && focusNodes.length > 0) {
                queue[focusNodes[0].id] = true;
                        expandedRelevances[focusNodes[0].id] = 1
                }
                } else {
                _ref3 = this.scene.data.getNodes();
                        for (id in _ref3) {
                data = _ref3[id];
                        queue[id] = true;
                        expandedRelevances[id] = 1.01
                }
                }
                }
                while (Base_Helpers.hasProperties(queue)) {
                q1 = {};
                        for (id in queue) {
                _ = queue[id];
                        rel = expandedRelevances[id];
                        a = this.nodes[id];
                        if (a) {
                if (a.hidden) {
                delete expandedRelevances[id];
                        continue
                }
                if (a.expanded && rel < 2) {
                rel = 2;
                        expandedRelevances[id] = Math.max(1, expandedRelevances[id])
                }
                expand = a.expanded || (rel > 1 && !a.collapsed) && !expandedNodes.hasOwnProperty(id)
                } else {
                expand = rel > 1
                }
                if (!this.scene.data.getNodeData(id)) {
                this.scene.loading = true;
                        delete expandedRelevances[id];
                        continue
                }
                if (!expand && autoExpandFilterFunc) {
                1
                }
                if (expand && expandIncremental && !graphNodes.hasOwnProperty(id)) {
                if (dataNodes.hasOwnProperty(id)) {
                expandUnfinished = true
                }
                expand = false
                }
                if (!expandedNodes.hasOwnProperty(id)) {
                if (expand) {
                expandedNodes[id] = true;
                        links = this.scene.data.getNodeLinks(id);
                        if (!links) {
                loadingNodes[id] = true;
                        links = this.scene.data.getNodeCollectedLinks(id)
                }
                expandedLinks[id] = links;
                        n1rel = rel - 1;
                        for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
                linkData = links[_j];
                        n1 = this.otherEnd(linkData, id);
                        if (!expandedRelevances.hasOwnProperty(n1) || n1rel > expandedRelevances[n1]) {
                expandedRelevances[n1] = n1rel;
                        q1[n1] = true
                }
                }
                } else {
                if (preloadNodeLinks) {
                links = this.scene.data.getNodeLinks(id);
                        if (!links) {
                loadingNodes[id] = true;
                        links = this.scene.data.getNodeCollectedLinks(id)
                }
                expandedLinks[id] = links
                } else {
                expandedLinks[id] = this.scene.data.getNodeCollectedLinks(id)
                }
                }
                }
                }
                queue = q1
                }
                return[expandedRelevances, expandedNodes, expandedLinks, expandUnfinished, loadingNodes]
                };
                Netchart_Navigator.prototype.updateGraph = function(visibleNodes, expandedLinks, nodesWithNewData, linksWithNewData) {
                var isNewGraph;
                        isNewGraph = this.graph.replaceGraph(visibleNodes, expandedLinks);
                        if (nodesWithNewData) {
                this.graph.updateNodesWithNewData(nodesWithNewData)
                }
                if (linksWithNewData) {
                this.graph.updateLinksWithNewData(linksWithNewData)
                }
                return isNewGraph
                };
                Netchart_Navigator.prototype.applyRelevances = function(relevances, expanded, loading) {
                var e, f, focusMode, l, link, linkId, node, nodeId, nodesInData, rel, rr, _ref, _results;
                        nodesInData = this.scene.data.nodes;
                        focusMode = this.scene.settings.navigation.mode === "focusnodes";
                        for (nodeId in relevances) {
                rel = relevances[nodeId];
                        node = this.graph.idToNode[nodeId];
                        if (node) {
                e = expanded.hasOwnProperty(nodeId);
                        f = focusMode && this.nodes[nodeId] && this.nodes[nodeId].initial;
                        l = loading.hasOwnProperty(nodeId);
                        if (e !== node.expanded || f !== node.focused || node.relevance !== rel || node.loading !== l) {
                node.expanded = e;
                        node.focused = f;
                        node.relevance = rel;
                        node.loading = l;
                        this.scene.touchNode(node)
                }
                }
                }
                if (Base_Helpers.hasProperties(loading)) {
                this.scene.loading = true
                }
                _ref = this.graph.idToLink;
                        _results = [];
                        for (linkId in _ref) {
                link = _ref[linkId];
                        rr = Math.min(link.from.relevance, link.to.relevance);
                        if (rr !== link.relevance) {
                link.relevance = rr;
                        _results.push(this.scene.touchLink(link))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                return Netchart_Navigator
        })();
        var Base_Export;
        Base_Export = (function() {
        function Base_Export() {
        }
        Base_Export["export"] = function(api, v) {
        var a4, dh, doc, dpi, dw, h, mime, mime_map, o, out, p, pdf, ph, pw, s, scale, w;
                if (v.type === void 0) {
        v.type = "png"
        }
        if (v.transparent === void 0) {
        v.transparent = v.type === "png"
        }
        if (v.dimensions === void 0) {
        v.dimensions = {}
        }
        if (v.type === "png" || v.type === "jpeg") {
        mime_map = {png: "image/png", jpeg: "image/jpeg"};
                mime = mime_map[v.type];
                out = api.saveAsImage(v.type, v.dimensions, v.transparent);
                return this.proxyExport(api, mime, out, "base64", v.dimensions)
        } else {
        if (v.type === "pdf") {
        s = [api._impl.scene.chartWidth, api._impl.scene.chartHeight];
                p = [10, 10, 10, 10];
                a4 = [];
                pw = ph = 0;
                dw = dh = 0;
                dpi = 72;
                scale = 1;
                w = h = 0;
                if (s[0] >= s[1]) {
        a4 = [297, 210];
                o = "l"
        } else {
        a4 = [210, 297];
                o = "p"
        }
        pw = a4[0] / 25.4 * dpi;
                ph = a4[1] / 25.4 * dpi;
                scale = Math.min(ph / s[1], pw / s[0]);
                if (o === "l") {
        w = s[0] * scale / pw * a4[0] - p[1] - p[3];
                dw = (a4[0] - w - p[1] - p[3]) / 2;
                h = s[1] / s[0] * w;
                dh = (a4[1] - p[0] - p[2] - h) / 2
        } else {
        h = s[1] * scale / ph * a4[1] - p[0] - p[2];
                dh = (a4[1] - h - p[0] - p[2]) / 2;
                w = s[0] / s[1] * h;
                dw = (a4[0] - p[1] - p[3] - w) / 2
        }
        out = api.saveAsImage("jpeg", {scaling: scale * 3}, v.transparent);
                out = out.slice("data:image/jpeg;base64,".length);
                out = atob(out);
                doc = new jsPDF(o, "mm", "a4");
                doc.addImage(out, "JPEG", p[3] + dw, p[0] + dh, w, h);
                pdf = doc.output("datauristring");
                return this.proxyExport(api, "application/pdf", pdf, "base64", {})
        } else {
        return api._impl.error("Unrecognized export type: " + v.type)
        }
        }
        };
                Base_Export.proxyExport = function(api, type, data, encoding, dimensions) {
                var b, f, f1, f2, f3, f4;
                        f = Base_Helpers.createDom("form");
                        f.setAttribute("action", api._impl.settings.advanced.exportProxyURL);
                        f.setAttribute("method", "POST");
                        f.setAttribute("style", "display:none");
                        f1 = Base_Helpers.createDom("input", null, null, f);
                        f1.setAttribute("type", "hidden");
                        f1.setAttribute("name", "type");
                        f1.setAttribute("value", type);
                        f2 = Base_Helpers.createDom("input", null, null, f);
                        f2.setAttribute("type", "hidden");
                        f2.setAttribute("name", "encoding");
                        f2.setAttribute("value", encoding);
                        f3 = Base_Helpers.createDom("input", null, null, f);
                        f3.setAttribute("type", "hidden");
                        f3.setAttribute("name", "data");
                        f3.setAttribute("value", data);
                        if (dimensions.dpi != null) {
                f4 = Base_Helpers.createDom("input", null, null, f);
                        f4.setAttribute("type", "hidden");
                        f4.setAttribute("name", "setdpi");
                        f4.setAttribute("value", parseInt(dimensions.dpi))
                }
                b = document.getElementsByTagName("body")[0];
                        b.appendChild(f);
                        f.submit();
                        return b.removeChild(f)
                };
                return Base_Export
        })();
        var builtinImages = {"column.png": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAADICAYAAADsgBFkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RUJFN0MzMThDOTJGMTFFMkIwNEFGNzY3QTBGQUEwRjAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RUJFN0MzMTlDOTJGMTFFMkIwNEFGNzY3QTBGQUEwRjAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpFQkU3QzMxNkM5MkYxMUUyQjA0QUY3NjdBMEZBQTBGMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpFQkU3QzMxN0M5MkYxMUUyQjA0QUY3NjdBMEZBQTBGMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pptq3kYAAAEpSURBVHja7JoxDsIwDEWTqrDADEMnVtT7H4CJE7QjR2DKFKnGEQuqmEiTpuGl8kCHL/P97R8LrIiYFKcxiY6dfd5rHDR2EZhew9kZ6Emj0zhGAD81HnYGehmG4RZeTPr8evprf26WBv0sXuC0WxI0nDYUSiV3jwEdx/ErsJkkMkvJqONkwO37m0gkE5I5YxM7hyjeKhmjir/vPKYbDULxCike9o+O4RgquFeUwTFyw0yhAs+rc/vfntywJlSBS6MKVIGZFuYgtDRUQAVUZKOC4mWgoopVAVVwjUXHULGqNdHSG/Y8Bj1UMOhpkDqXG1SxYQdBFTgIv0uzg6y6g9B5WBN/bEZudVKBmXKNxaXRMUOooIwxUzim81BFlcXzCRL2AdglAHYvAQYAcMpYf9wvA84AAAAASUVORK5CYII=", "no-data-light.png": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAABPCAYAAABWIbNMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NzIyQjVERERFNTYzMTFFMkFCQzA5QTIyQ0RFNjkyMTYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzIyQjVEREVFNTYzMTFFMkFCQzA5QTIyQ0RFNjkyMTYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MjJCNUREQkU1NjMxMUUyQUJDMDlBMjJDREU2OTIxNiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3MjJCNUREQ0U1NjMxMUUyQUJDMDlBMjJDREU2OTIxNiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqaQJv8AAA0dSURBVHja7FwLVJTHFV5w0YVdwAVUXFACCqiVl9IjEkTemAKmFhCDSQFBLIoHKb6NJ7WnNqipJoqJNTWa06MmimiaaMFXQFN8YagaFRFFLYLgCzHJgsuj34VZsq67sC9w18Occ8+/O/PPnTvff+fOvfPP/EZtbW2cpUuXcuRTdnY2R5WkqK6SxAWNA00CuYNcQI4gAYjP7vmR0U3QddBF0AlQKahFEVNV5VRHZuLJ5fRsMgH9BvQW6A2QhWxhv379GoyNjRu4XO49ekAtLS1mra2tfFx9Uewrc+sT0EHQTlCBMpB0mXoKGNKCFNAfQcMYCE8sLCyKBg0a9IOjo+M1V1fXapFI9BhFzSAJyIjJw62urhaWlZWJKisrR92/f9/t6dOnHgArHmVEt0DrQdtAPxsKMMQvFbQKZGNkZNQsFAoLXVxcjoWFhZ0xMzOrQz6BUU+dgko3K1FlLkCj4WUJsmpsbBx0+PDhX1+9ejWsvr7eD9q1EfnLQCvAYwfub9NnYMaCdoDGEyBDhgz5KigoKNfd3Z3sRDXoITrRpqINaGbDh+gOOm40derU70EHS0tLPQsLC6Pr6ureAECfoXw27k/BPVf0EZg00AbQAAyXc9COzd7e3mfw/zaEFmvLnAH6kAgAlHt5eZ0tKSnZV1BQMB/DbCLyS3BPOso+0wtgIEw/XD4EpcOINsFubExISPgc/8tQ1iPjnwF9FSDcBkBXduzYkVhRUZEC7dmGsjEoW6SLocXVQsD+bJaIMTExuRceHr7Sz88vH/lVnF5IDPhzAKG2qKjo0tGjR/8skUiykDcUZUnIf6YNf2NNNQV2ZBeBwuPxbsTHx6cBlC96CxS5dGfy5Mk7IyMjM6G1BFY8ZNsOWYxehsZsgupGA5RbycnJc4cNG1YEQZo4Lymh7RaAkgQfyIzAwZWm9Tts5uodjYEQZGjT+vfvXx0dHZ0BUI6/ZFDMoCEHAEawubn593FxcbMxtB90FC2d2SvAoCE3CPEhGdqQkJBlbm5uBcp8kV5K7aBAe0MJlJSUlAwPD4/9AQEBy5AvAW2BfM49CgwaAB7Gn0OI/s7Ozp/4+/vnIbtJn0CB73QK+eLg4OA9I0eO3IoyAWTWyN6oDAwaSIa6ekGI80lJSX9jwZ6+gSKNoRrgNqwTCAQXIPPr+P/7HgEGiJtDiPdJPX19fSmcrdJjUDpmFS73to+PTzbubQGtRR9MdQ4MtGU+BLFGAHgwMDDw3/oOijTBDn5jY2NTgPsHI4hN0ikwQJqWDjIIebj5m/D7J0MARbq+4+npmYN65AkvIjupM2CgLREYp4MRJZ+AwS3WJ1DIf+muIgxxkaWlZXFLS8tr6EugzoCBCibSFYLsw6XRkEBh6Wfcn8fsTqJOgEHj3Obm5hBaaQsNDd1vgKC0J/g1e6EtP6EvkaoOJ+NutGU8hOJbWFicFYlENYYICiVHR8e7bOoeiD65aQ0M3P4QuvL5fDJybYYICkutAOY0/UC4EKo1MBBuPF2hMWcMGJT2BF6n2GTipTUwGJNOdLW2tr5oyKAwYC7RFbOTi9bAgMkwMrwRERE1hgwKpZiYmFsU/KJPIq2BgZC0vkExUbMhg8JSE73DggE21woYikjBhAdm4lcAFKmzKkY7plprDNOatlcBFHX7ohQYWmkHwo00nF4FUGRMg1hrjYHgtH5q9iqAwiYTc2YztQNmwIABNWA2EAILDB0U8LdFmzw4rTVaAwMv8Q67jjZkUNobNjMbw7z5W1oDA2aXGTC+hgwKS7TEyeHxeFe0BgYe70k2NgMNHBTqw2S62trantQamNDQ0O/oBZZEIpnMVvIMEhS0xUMffMiLj4qKOq01MOjA44EDB/6HwnUAFG6IoDDHLop2atEqJMxDgy4cvDaoXh5bm5ltiKAw2Wl3F0ckEuXqZAWPUnh4+AEY3zpE2hHolKOhgYI2XTCMQjAb3Y2MjDyoM2DQoVogvQ+d7MflcpcYEihMW1ZQP4cPH77LwsLioc6AoeEUFBSUgwbqYdmT0cFRhgIK2vWEbXmbXvJPmTJlC0eNVUiVFoZdXV2vOTk5bUeHuTBkHxsIKEaQdTPkMXZxcdlib29/S536qr6Aapk+ffpGWPRyPIFANJqsz6CwlAlZffl8/g8zZsz4BP9bewIYWhq87e/v/yc8hWcAYRM67a6voKBtb8iUTa9M4IutxFCqVnuKVydqDwgI+BrDinZTmaLhQ7T3RA9BcYBMX0Emk7Fjx27w8fEp0Mj3UfP+HxMSEjYMHTqUZik7CHBez0AZDJmOQSaRnZ3dl/Hx8ZuRLe4NYCjdTU9Pf9fKyuo4BKD1DbGfn99qPQDlNYDyHWQaQTsc0tLS3kP2PY29ZQ19g7LU1NTFAOdbGDjT/Pz8jyDY2JdsU04BFGcCZd68eYvhc13TKozQtCJiqNKsrKxMNqzsSTBkz+F0HJborWQEUGhvbzFksMWUvDszM3ORqanpJa3jKy3qtkJzLmRkZKxwc3Nby/agkBN1HPSrXgCF3igWgj7AcJZ4enr+FUP8Pch0iaOD18nGOlDjazNnzvxo2rRpafBzriIrAPRf0FbQyB4AxJXTcSTnLMhfIBBcio2NTYWvQpuaruuqEa6Oxnh1dnZ27rhx48p3794dXVZWNgtBJ0Xj5AgeAP0TRFvUNN3lyQNFcDo2GUbSAyU3f/To0f+Ii4vbz7REp++/uDo0gLRd/TQAuvPkyZMjeXl5UZWVldHPnj37HfKJ6IxSESPaJEDa9VgJOyGI1mh9QJMZtZ+Ooyh5xIgR+6ChXyMopKXXHnl9rPMTbkx77iUlJV0FKLlHjhzxgQYFPnr0yBdB6Ju45U1Zvwh0n13JaNPhrcGcX85ISmfBJ5gBD0FDCsPCws5ixrmB7Gq01arJmciXAgwDh+KS/0HoqoiIiEugbwDS0JMnT46BFo2GRjmIxWJRU1PTYIBlgxllOBlMGHAxQHhKK/mwV1WY+W6MGjXq4sSJE6/DwNYy7Xis6oGwlwpMN0+MOvCICJ29EhwcfI5mek7HmUl6kWfKZJDK0cyI9vrR7tCnbLg9VaPNngVGjWPDKsdanF+O8+l9Mub0pT5g+oDpA6YPmD5g+oDpA6YPmFcqST3fEhDtAveGu31TzgOOxWUPaDrK9srkUwS8hJE0HQXtZWsxXSUpT0VpDbHvou4NJuscmXbGsz50l6xkIvpOPujXVoXAIFrlNzc3CxHE0W6AcbI3ILQf2NDQ0H6VAcUJ9x5FwFfj6ek5PyYmpn2BaO3atZGIov/OGlTaOSlPJyen1ampqZ0beXJzc51LS0v/gMCSDnd4K6hK+U4mJibX6dUr7tvKYidqf4r0pvXr10+vq6ub5e3t3SmbNJpnoc5zfBQ9yM5YiXYz0ilZVFyChtZ0BTsBiKDw0apVqzLwtxx1GpiA5Tk5Oa1VVVWkRTe705wHDx7Q10IKZILDUzwer6a4uHg7ZMmWBxcP8B1E4jVWVlZ5tbW1S9gDuMna7+QjEAiC6FpRUXERZSde6LQcH3rQ8iOl08ZAoPOEIDq9jA0TZcFlKph62dnZ0SdJSqSgsLLK9PT0daampqUAOl2D5YqGyMjIQ3w+vwj14+XLoSG/NTMzKxEKhf9i6zTxmtgPVfgYy9z8bMKECXTC3Rj0qTKm0BR/0i4MgS+VdK4KwNAuLDf2RNUFR4z2ScWHydWPxQOxoM4kJiaWEvj4P1sDXFTi89ysRE/L2tr6C/qgBTO6ipINEG7/glAXQ62Mrnjytpo8UdR/IF+f1J9s2ty5c/cTeAz84czwqj7bKOGD3+O7mq7FWVlZ77MhtU7RkCKNAnBd7hyQSCTt324BH40WwiBoi1x9Ie26NDc3/xYytT8QLy+vbaS56OjbarBWmY8iP6bSwcEhB52nl+Nr5Qtp5yMEt+sGGAdmt+o1tAGWsvUheBqpf319fTxb8Go7duxYKeQQgKJVdtrU4KPQwUtJSdmJKfUQmKQ0Nja6y5YB7WI68wPEQ7oAJoC0bsGCBRq950F9D1J3aX08oLeIH2aOKbJkb2+/kdmiWBWHaJd8ZM2HMlV/OGnSpL/k5+d7QcjnPhiRmZm5a+XKleRrvMscuhd8DfhErw8ZMmSNhh/uckJ9P9i63az+eLQ11tLS8mPZqZ1N75eXL18+C5rwDurs7YavQj60foyZtJMPc1CVhwQApgRT8hZSPbmie2z2GokGjsgZP/ItjsA/2AMAczSZMZiPVLFw4cI1zM5EkA1YvHjxB4pmQBjoQrbrW9gV4674IHXykdrVrmIlCSz3VlR4YYs5zV6rV6+Ox7C6y1zx9vEKAxZFaonGV6ryvSp4v1uldTkdr08+pZdocBznkE/E7E0yCS39/4I1FQppk5AF2Y9u7JZafIzYoS/6lhy9SbygoI4HyJaVye83kX5ItHMIsnu6A8WW8X3hYbC65TJ5/ozvZSW8rFn4QHWknXZkstEOjAZN+Bj17Mk+w03/F2AAHZMD17Q4OMAAAAAASUVORK5CYII=", "no-data-dark.png": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAABPCAYAAABWIbNMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUI0RTA2RDZFNTYzMTFFMkJDOTdGRTQ2M0VGMEIxOEMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUI0RTA2RDdFNTYzMTFFMkJDOTdGRTQ2M0VGMEIxOEMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1QjRFMDZENEU1NjMxMUUyQkM5N0ZFNDYzRUYwQjE4QyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1QjRFMDZENUU1NjMxMUUyQkM5N0ZFNDYzRUYwQjE4QyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PjyBbi0AAAvnSURBVHja7JwLUFTnFcdZ2EVYEQNxMkgEI9MoaoVQpdakom0hE6t2nFocFRrHlqSatlOLio+pjDOZjCYkdmKiE9vRacahoyMdH4wYsE2iIdIWEIurRV4LldfyXJ7Lm/7Pci69ud1d7t59Ycs3c+Yu997vfOf+7vnO97yoxsbGvCwllUrlJSdZy28hqSHfgKyGREEWQhZAAiAz+Z4elmpIBaQUchtSAhlxxE57bVa5GIwG8n3INsg6SKD44tDQUBekd3BwsI/K02g0WshMSKBETyfkOiQTkiuG9KSBIS9IgaRCwhhCZ319/b1Hjx7pbt++/ejGjRsNJSUlHbg0TJepSPYqdUxMTND69etDV69eHYm0bO7cudEiWDWQE5CzkD5XgTHfZEnsKUQkasgbkBbI2Ojo6FB1dfVnp0+f/k1wcHACbo+GhLPnqG2UTYBm870vzJ49O+HkyZOH9Xr959A5PDaeGiA7ISolYCYTZ4L5OqSILB4ZGRkqLS29smXLlmSOJ3ME71Qi7E1PE9ikpKQdOp3uGpXBgO5AlkxVMLsh/WRlXV3d33fu3LkDlyIh/kph2LDLH7KYymhsbCxiOH2Qn0wZMLjPB/IBWTY8PNyfnZ39Prc8WmcDsWAfBerY3NzcU/CeAQb0rpyq5VIwuMcXcoms6e3tbdyzZw8F23muBmLBzvC0tLRdfX19zQwnk2zzCBjyFATBLLLCaDRWbty4cRO1RO6GIrJz1q5du5Ko6ecYl2nLc1wJ5jRD0a9cufJlnJrhCSiCnThqAeXPZJMAB+mYW8FwoB3r6empT0xM/IGtZtdNooX35pFNCMbFW7du3Y5q1cJwktwCBueXwYgBCrT79+9/1ZOeYgnK0qVLv02t1pEjR1JQnQZxrRuXnncpGJzzhpveJSNycnJ+y73bqQbFh80NzMvL+5Bby3xpvHEqGBTwGhtRRK2PPYW4GYo5+fn5zTcYDPe4Su1wCRj8PQuu2UrueejQoR/ZW4i7oQjp6NGjW2kIAbsNuN3f6WBQhQ6TIQ8ePLgsmiLwBBjZUITBbFlZ2XW6HyP4N5wKBr81qEYGIr9v377vKglkHoJiTunp6euQbxRg9BQnnQYGUDaRMVVVVZ9S1fUQGItQZA5dtLW1tfncx/me08Cgu3+FlGIc9HOlfQJXQZE7prt+/Xoq973OOwUMza8gcPUMDAx0xsTEhHoAjE0ocsHExcWFwVt64P0dVJ0cBoN6uZKMqqmpuclzIu4EMykUO6ZHvOvq6r7kIBwtp3xvW9rgevF0bG5uLiAGXu5LNG1xRaVSJTQ1Nd2Nj4//FVrEAhofKtQ3imf4K/3AcCFBFslJBovL6Yg39rcnGIo5QVcBNyYxDoPx9fWNoGNlZWXpkwyFX+5987KFRrPQoWk+jjFtFHh5ctrLxTFGVkxROgVLA14a/JpMpnqHgy8UmdBc1zs6G+YqKHaC8QKUZlrLcggMjUjJ0K6urkoXg1EMxV4waExqaUnHKWC6u7srXAjGISj2goH31/Cyi+NVCc2bq6qSw1CUVCXEzS6HwSDwtkFRhwvAOAWKvWDgLRQzGxwG09bWpuOJngAngnEaFDsXBkOozJaWlmKHe76oRv/i4+Kp3k+ZLOElLxHijMMdvPb29gd07O/vf/FJhsK7N16io9FofOgwGPR4vzBvPVCrv/MkQ+FnWENHnU73hcM9X9T/YFrA4uG6RmGMcWpMUbjG7odnME+fBAcHBzpjokpVXV2dx8sQGxSAcSkUuWBgeyLZUF5enu20GbyrV6/u4oX7q3aCcTkUuWBgey7ZcfHixR1OA4MHCkGrZOCdTAtkgnELFJm7MhZSLMNwoC40NHSOM5dPVPn5+eZFfLROH8kA4zYocsAgrnxMtty8efMdYRbSaetK69atW4ICOngAFmkDjFuhyNiV8QLsGaFF/tjY2AhXLNH65ObmnuAliE+tgHE7lEl2Zahgq3me9/Lly2+KuyZOXbsOCQl5Dr3HRzxE+KmkEI9AmQSMecmkubn5vlarDXXlNhDVwYMHt6HpGwAE2gwYJWza8RQUG9tVVtDiIy2Z7N69e5M7Ng4FZGdnv8t7eOto74knoVjZrjIfo+h6bp7f5F2ebtlq9uy9e/eyGE6XJ6FY2JXxDGyqJJuKi4svUARw6x48X1/fyKqqqr9wMO5LS0v7oSegSDYfPAco5dzD/WTGjBmLPLKdNTw8fDkt9LPnPMYh2lNgOKY0ClCCgoKiPLkB2luj0USLqhUF5J/xXLG7wFBZe2nllWwoLCz8I7x5mbXlZLdumUdadOnSpbfRWgnbSD+DLHUDlBjILWELa2Zm5luw5fkp9S0BUmhKSsqrra2tDxkO9ZB/B/maC4AsgpzlMsYMBkNpcnJykrVA6/GvT3hv/7eysrIyTCZTGwMagfwJQpuPHNn66gfZDLnKOseom3/hwoVjKPOblprkqfRZzoT3hIWFvZyTk/MBRrQNY/9JNNlFm5B+DXkREmTDMLr2EsePa5BOQQmNkuljDoyUaSfGXCWzeR4Bw3lpXBIWEBCw5r333jtQVlb2Ca/nSBNtUK6GlELu8+8e6U3Ia6RNhhkZGfv9/PzW8HZab3uXT+wB49JvIlXjSoLozc6cOXNuamrqkri4uMXwqPloUkMB7hm0IgE+Pj5aUkXrPoDQi2qCYVlbXW1tbRU8r/TUqVMVtEGSNi1AyPPG7LVTrs0Teh0FY89Evdf4J39P8a5yLccGtWg3xTBLP028QboJBB+dlhwC8/+evKcRTIOZBjMNZhrMNJhpMNNgpsH8b4Kh7xzbIRE0FBALUqLX+HcEiZLzNAY6ztcEoY8xXpdRbqIkn1iOT5K3iu8Tl7Pchj6xBFnSY+GZx8H09/fT53w01M+SWtHQ0PCU+MhjjQiaiEe+1efOnfsllL1Cotfry3D5zGQPJ+i6devWW0JeEtKFQeQGflGWEk01RGCQWYH7kkXjugqxnocPH56j82LbWHps6fmvAZXJZPonRq/dPMo/IL5eX19v/nqWjsK50dHRu52dnWT8ChoYiqYbFhQWFr7Pel63NqQX65RMVwSeOHFiM2yhKYrj0nyw8+OBgYEGnU53nMuIsKTfYDC8TRcxOo+zdN2SHimTiRhjNBqLiSBOHqKJIhsjU3K9mJKSEnor9G9KukTX9LGxsRnQVYKH+4WCUW9XampqTktLyy3k3y697uvru6m9vb2opqbmGv2Nt71dSfyQo2cCjEajGTxz5swheIM35PfWlPb29sbRV29r1669aOXh6jo6Or5Uq9U0Wx+hAI4J+iuQP0ySP9Hb2zuQHmbDhg0lBN/Hx+c1BVxk6flKq0Rvq7Ky8gIy0vxqohXD55Ab4mebtZIBlmKNV2tra4iSN4oyWqX5UeaP8WYbV61adZngEXw8UDgHXtnJmh7h2yxrzbUpMjLyGFUpPFyGpSpFHoU0aqtwf3//QTpCj1oJGHjLiCR/EDx6TVNTEy3NmF/I+fPnz5LnogFItkO1bD2W+jH6O3fufIiHnw8I70gvUmCE8mdtla7VaufTEQHaqAQM9M8W50eZu8n9w8PDtwtNb3p6OlWBAEDcLFevPXosdvASEhIy0aTmQElKYGBglKSpvQNFs0A83poBfn5+a8nroqKiKpSAgcdFk7sL+VHWNtInaXpfKSoqOsmxKFFmFbWp5yvhQ2iu8XbyxEr27t27imIJ3KxT0lyHIACXDw0NfS7kl0g83c9NoV3NNUsElVleXv4R/72cP4g/ZWE1Yh51M1ANrslori3q4TShZ2JO2BoY8mhUqXRhCUPcj6G+Bt4o7Y+5yQUKBR2ge6urq6nFmqcATCL3kYqpT0Tn8IbTyWjhb6k0NjZm88sLsgXGmh4hSfXYAmP2jubm5ttSMF7js/txqFZ/EK//QE8+dfBwbaGtNRsBjDQBivHx48f0Nf0K4V48TC0ZbU1XQUFBCq9fH7YFxpoeIUn1mFcJUM9WUSMA+YcFOPTfDkP4WpPkmvCPRIXUxvfUTVLdQ1ivNA1x3nLRuTjW+8CKrqe5B0559HxuAdtGnxR32auHOqrTyydW0r8FGADOGvuNcLn3BwAAAABJRU5ErkJggg=="};
        var Piechart_images_back = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAA1CAYAAADRarJRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgFJREFUeNrUmc8rBGEYx9/dUbTkoIhCcXSQLUV74szRH6C9uConJy9HZwdylisnjsuNxE2ituS0tChx8eP1fXmnpm1mza/X7vepT00708znfd/Z533fZ4RIP1YEaWhxxSyumMUVs7hiFlfM4opZXDGLK2ZxxSyumMUVs/i/yWdCiMuY99aNeDbHL+AePIAKuAHX4BJcga9m6PE46AYegCUwzCTuxymYB21s4l7uQBFk2cS9HIMhRnGXKigwiru8gglGcRedbvtd8WyIXN9M0Q22an+URL2vmdbSjpEvmRGYIhmBHrDDOgLv+hVyauRZRkD/Vy8cnxMsDSg7AScYGlBx6pxM0oAn8AFaLcpXW/64QMYsnnZ5jjvBABgEo2DS0JtQ3gl7YdQsFCbyYN1sUOJknFKUlkphZxvYZjYijxHl96MOlRT29rB94DCC/Each0hhbwPumLVLGPnFuA+Rwl71QGe43RDyidK4tFj6yJnqQtD9dRruSPoQabFuM1tH/iStyUJaks+Ymo6f/Fqas520VDFbDpAfT3u6lhbkCz7iZVvrDZmyfM5HftXmak+mfD/vzPsZpobTVOt2j/yeIIvbtCamRoT72pyxibd7en2OTT5vxM/JimM/UTTyM4IwtsGRIA397WqMUXwEbLL2+kJNFSJ++aAB8SZ+v0sFxrcAAwAU8YKsEeepXgAAAABJRU5ErkJggg==";
        var Piechart_Selection;
        Piechart_Selection = (function() {
        Piechart_Selection.prototype.scene = null;
                Piechart_Selection.prototype.events = null;
                Piechart_Selection.prototype.currentSlice = null;
                Piechart_Selection.prototype.currentPie = null;
                Piechart_Selection.prototype.draggedLabelSlice = null;
                Piechart_Selection.prototype.draggedLabel = null;
                Piechart_Selection.prototype.hoverEvent = null;
                function Piechart_Selection(chart) {
                this.chart = chart;
                        this.scene = chart.scene;
                        this.events = chart.events;
                        this.dragPointers = {}
                }
        Piechart_Selection.prototype.doAnimations = function(event) {
        if (this.hoverEvent) {
        return this.onPointerMove(this.hoverEvent)
        }
        };
                Piechart_Selection.prototype.previewPointerDrag = function(event) {
                return this.hoverEvent = event
                };
                Piechart_Selection.prototype.onPointerMove = function(event) {
                var pie, slice;
                        this.hoverEvent = event;
                        slice = this.scene.findSliceAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        if (slice) {
                event.cursor = "pointer"
                }
                this.switchCurrentSlice(slice, event);
                        pie = this.scene.findPieAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        if (pie && pie.background && !slice) {
                event.cursor = "pointer";
                        return this.switchCurrentPie(pie, event)
                } else {
                return this.switchCurrentPie(null, event)
                }
                };
                Piechart_Selection.prototype.onPointerOut = function(event) {
                return this.switchCurrentSlice(null, event)
                };
                Piechart_Selection.prototype.onPointerDown = function(event) {
                var slice, _ref;
                        slice = this.scene.findSliceAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        if (slice) {
                event.consumed = true
                }
                _ref = this.scene.findLabelAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance), this.draggedLabelSlice = _ref[0], this.draggedLabel = _ref[1];
                        if (this.draggedLabel && this.scene.settings.interaction.dragging.enabled) {
                return event.consumed = true
                } else {
                this.draggedLabel = null;
                        return this.draggedLabelSlice = null
                }
                };
                Piechart_Selection.prototype.onPointerUp = function(event) {
                if (this.draggedLabel) {
                this.draggedLabel = null;
                        return event.consumed = true
                }
                };
                Piechart_Selection.prototype.onPointerCancel = function(event) {
                return this.onPointerUp(event)
                };
                Piechart_Selection.prototype.onPointerDrag = function(event) {
                var label;
                        if (this.draggedLabel) {
                label = this.draggedLabel;
                        label.userPlaced = true;
                        label.x += event.dx;
                        label.y += event.dy;
                        event.consumed = true;
                        return event.changes.pie = true
                }
                };
                Piechart_Selection.prototype.onClick = function(event) {
                var n, p, userEvent;
                        n = this.scene.findSliceAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        p = this.scene.findPieAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        event.clickSlice = n;
                        event.clickPie = n ? n.pie : p;
                        event.consumed = true;
                        if (n) {
                event.cursor = "pointer"
                }
                userEvent = this.chart.notifyClick(event);
                        if (!userEvent.defaultPrevented) {
                return this.updateSelection(event, n, false)
                }
                };
                Piechart_Selection.prototype.onRightClick = function(event) {
                var n, p, userEvent;
                        n = this.scene.findSliceAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        p = this.scene.findPieAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        event.clickSlice = n;
                        event.clickPie = n ? n.pie : p;
                        userEvent = this.chart.notifyRightClick(event);
                        if (n) {
                event.cursor = "pointer"
                }
                if (userEvent.defaultPrevented) {
                return event.consumed = true
                }
                };
                Piechart_Selection.prototype.onDoubleClick = function(event) {
                var n;
                        n = this.scene.findSliceAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        event.clickSlice = n;
                        if (n) {
                event.cursor = "pointer"
                }
                this.chart.notifyDoubleClick(event);
                        return event.consumed = true
                };
                Piechart_Selection.prototype.updateSelection = function(event, target, softDeselect) {
                if (!this.scene.settings.interaction.selection.enabled) {
                return
                }
                if (!event.shiftKey && (!target || target.selected)) {
                return this.setSelection([])
                } else {
                if (target && event.shiftKey || (softDeselect && target.selected)) {
                if (!target.selected) {
                this.scene.selection.push(target);
                        target.selected = true;
                        return this.setSelection(this.scene.selection, this.scene.selectionIds, true)
                }
                } else {
                if (target) {
                return this.setSelection([target])
                }
                }
                }
                };
                Piechart_Selection.prototype.switchCurrentSlice = function(obj, event) {
                if (obj === this.currentSlice) {
                return
                }
                event.changes.current = true;
                        if (this.scene.hoverSlice) {
                this.scene.hoverSlice.active = false
                }
                if (this.scene.hoverPie) {
                this.scene.hoverPie.active = false
                }
                this.scene.hoverSlice = obj;
                        this.scene.hoverPie = null;
                        this.currentSlice = obj;
                        this.currentPie = null;
                        if (this.currentSlice) {
                this.scene.hoverSlice.active = true;
                        event.hoverSlice = this.currentSlice
                }
                this.events.notifySceneChanges({pie: true});
                        return this.chart.notifyHoverChanged(event)
                };
                Piechart_Selection.prototype.switchCurrentPie = function(obj, event) {
                if (obj === this.currentPie) {
                return
                }
                event.changes.current = true;
                        if (this.scene.hoverSlice) {
                this.scene.hoverSlice.active = false
                }
                if (this.scene.hoverPie) {
                this.scene.hoverPie.active = false
                }
                this.scene.hoverPie = obj;
                        this.scene.hoverSlice = null;
                        this.currentSlice = null;
                        this.currentPie = obj;
                        if (this.currentPie) {
                this.scene.hoverPie.active = true;
                        event.hoverPie = this.currentPie
                }
                this.events.notifySceneChanges({pie: true});
                        return this.chart.notifyHoverChanged(event)
                };
                Piechart_Selection.prototype.onSceneChange = function(event) {
                if (event.changes.pie) {
                if (this.updateSelectionIds()) {
                this.events.notifySceneChanges({selection: true});
                        return this.chart.notifySelectionChanged(origin)
                }
                }
                };
                Piechart_Selection.prototype.updateSelectionIds = function() {
                var id, pie, slice, slicesToSelect, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
                        slicesToSelect = [];
                        _ref = this.scene.selectionIds;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                id = _ref[_i];
                        _ref1 = this.scene.pies;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                pie = _ref1[_j];
                        if (pie.background) {
                continue
                }
                _ref2 = pie.slices;
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                slice = _ref2[_k];
                        if (slice.id === id) {
                slicesToSelect.push(slice);
                        break
                }
                }
                }
                }
                if (slicesToSelect.length > 0) {
                for (_l = 0, _len3 = slicesToSelect.length; _l < _len3; _l++) {
                slice = slicesToSelect[_l];
                        if (!slice.selected) {
                slice.selected = true;
                        this.scene.selection.push(slice)
                }
                Base_Helpers.removeFromArray(this.scene.selectionIds, slice.id)
                }
                }
                return slicesToSelect.length > 0
                };
                Piechart_Selection.prototype.setSelection = function(selection, selectionIds, alreadyChanged, origin) {
                var hasChanges, s, _i, _j, _len, _len1, _ref;
                        if (selectionIds == null) {
                selectionIds = []
                }
                if (alreadyChanged == null) {
                alreadyChanged = false
                }
                if (origin == null) {
                origin = "user"
                }
                this.scene.selectionIds = selectionIds;
                        if (alreadyChanged) {
                hasChanges = true
                } else {
                _ref = this.scene.selection;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                        if (!Base_Helpers.arrayContains(selection, s)) {
                s.selected = false;
                        hasChanges = true
                }
                }
                for (_j = 0, _len1 = selection.length; _j < _len1; _j++) {
                s = selection[_j];
                        if (!s.selected) {
                s.selected = true;
                        hasChanges = true
                }
                }
                this.scene.selection = selection
                }
                hasChanges || (hasChanges = this.updateSelectionIds());
                        if (hasChanges) {
                this.events.notifySceneChanges({selection: true});
                        return this.chart.notifySelectionChanged(origin)
                }
                };
                return Piechart_Selection
        })();
        var Piechart_Scrolling;
        Piechart_Scrolling = (function() {
        Piechart_Scrolling.prototype.animationPriority = 1002;
                function Piechart_Scrolling(chart, view) {
                this.chart = chart;
                        this.view = view;
                        this.scene = chart.scene;
                        this.events = chart.events;
                        this.pie = null;
                        this.slice = null;
                        this.fraction = null;
                        this.offset = null
                }
        Piechart_Scrolling.prototype.doAnimations = function(event) {
        };
                Piechart_Scrolling.prototype.onPointerDown = function(event) {
                this.pie = this.scene.view.findPieAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        this.slice = this.scene.view.findSliceAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        if (this.slice) {
                this.pie = this.slice.pie
                }
                return this.mode = null
                };
                Piechart_Scrolling.prototype.onPointerDrag = function(event) {
                var dfraction, doffset, newDist, _ref;
                        if (!(this.pie || this.slice)) {
                return
                }
                if (this.mode === null) {
                if (this.pie && this.scene.settings.interaction.scrolling.enabled) {
                this.mode = "scroll"
                } else {
                if (this.slice && this.scene.settings.interaction.dragging.enabled) {
                this.mode = "drag"
                }
                }
                }
                _ref = this.scene.view.getMovement(this.pie, event), dfraction = _ref[0], doffset = _ref[1];
                        if (this.mode === "scroll") {
                this.pie.scrollOffset += dfraction;
                        this.updatePieScrolling(this.pie);
                        event.consumed = true;
                        return event.changes.pie = true
                } else {
                if (this.mode === "drag") {
                this.slice.userPlaced = true;
                        newDist = this.slice.currentCutoutDistance + doffset;
                        if (newDist < 0) {
                this.slice.currentCutoutDistance = 0;
                        this.slice.userPlaced = false
                } else {
                this.slice.currentCutoutDistance = newDist;
                        this.slice.userPlaced = true
                }
                event.consumed = true;
                        return event.changes.pie = true
                }
                }
                };
                Piechart_Scrolling.prototype.onPointerUp = function(event) {
                if (this.mode === "scroll") {
                this.updatePieAfterScroll(this.pie);
                        event.consumed = true
                } else {
                if (this.mode === "drag") {
                event.consumed = true
                }
                }
                this.pie = null;
                        this.slice = null;
                        return this.mode = null
                };
                Piechart_Scrolling.prototype.onPointerCancel = function(event) {
                return this.onPointerUp(event)
                };
                Piechart_Scrolling.prototype.updatePieScrolling = function(pie) {
                var offsetIncrement, pieUpdate, remainingOffset, scrollIncrement;
                        pieUpdate = false;
                        if (pie.scrollOffset < 0) {
                remainingOffset = pie.scrollOffset;
                        offsetIncrement = 0;
                        scrollIncrement = 0;
                        while (pie.slices.length > offsetIncrement + 1 && pie.slices[offsetIncrement].fraction < - (pie.scrollOffset + scrollIncrement)) {
                offsetIncrement += 1;
                        scrollIncrement += pie.slices[scrollIncrement].fraction
                }
                pie.offset += offsetIncrement;
                        pie.scrollOffset += scrollIncrement;
                        pieUpdate = true
                } else {
                if (pie.scrollOffset > 0) {
                if (pie.offset === 0) {
                pie.scrollOffset = 0
                }
                }
                }
                if (pieUpdate) {
                return this.scene.view.updatePie(this.pie)
                }
                };
                Piechart_Scrolling.prototype.updatePieAfterScroll = function(pie) {
                return 1
                };
                return Piechart_Scrolling
        })();
        var Piechart_Data, Piechart_PieData, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        };
        Piechart_PieData = (function() {
        function Piechart_PieData(id) {
        this.values = [];
                this.offset = 0;
                this.totalCount = null;
                this.total = 0;
                this.valuesSum = 0;
                this.beforeSum = 0;
                this.afterSum = 0;
                this.done = false
        }
        Piechart_PieData.prototype.addData = function(values, offset, limit, before, after, sum, chart) {
        var len, v;
                len = values.length;
                if (this.values.length === 0) {
        this.offset = offset
        }
        if (offset < this.offset) {
        if (offset + len < this.offset) {
        chart.error("Data cannot be merged");
                return
        }
        while (offset < this.offset) {
        this.offset--;
                v = values[this.offset - offset];
                this.values.unshift(v);
                this.valuesSum += v.value;
                this.beforeSum -= v.value
        }
        }
        if (offset + len > this.offset + this.values.length) {
        if (this.offset + this.values.length < offset) {
        chart.error("Data cannot be merged");
                return
        }
        while (this.offset + this.values.length < offset + len) {
        v = values[this.offset + this.values.length - offset];
                this.values.push(v);
                this.valuesSum += v.value;
                this.afterSum -= v.value
        }
        }
        if (!limit || values.length < limit) {
        this.done = true
        }
        if (offset = 0) {
        this.beforeSum = 0
        } else {
        if (before) {
        this.beforeSum = parseFloat(before)
        } else {
        this.beforeSum = Math.max(0, this.beforeSum)
        }
        }
        if (this.done) {
        this.afterSum = 0;
                this.totalCount = this.values.length + this.offset
        } else {
        if (after) {
        this.afterSum = parseFloat(after)
        } else {
        this.afterSum = Math.max(0, this.afterSum)
        }
        }
        if (sum) {
        this.total = parseFloat(sum);
                if (!after && (this.beforeSum || this.offset === 0)) {
        this.afterSum = this.total - this.valuesSum - this.beforeSum
        }
        if (!before && (this.afterSum || this.done)) {
        return this.beforeSum = this.total - this.valuesSum - this.afterSum
        }
        } else {
        return this.total = this.beforeSum + this.valuesSum + this.afterSum
        }
        };
                Piechart_PieData.prototype.markDone = function(id) {
                if (this.done) {
                return
                }
                this.done = true;
                        this.afterSum = 0;
                        return this.totalCount = this.offset + this.values.length
                };
                return Piechart_PieData
        })();
        Piechart_Data = (function() {
        Piechart_Data.prototype.requestScheduled = false;
                Piechart_Data.prototype.cleanupScheduled = false;
                Piechart_Data.prototype.removed = false;
                Piechart_Data.prototype.CS = String.fromCharCode(63743);
                function Piechart_Data(chart) {
                var id, value, _ref;
                        this.chart = chart;
                        this.runRequests = __bind(this.runRequests, this);
                        this.settings = chart.settings;
                        this.pies = {};
                        this.pendingPies = {};
                        this.requestedPies = {};
                        this.requests = [];
                        this.nextId = 0;
                        this.dataFunc = this.getDataFunction();
                        if (this.settings.data.preloaded) {
                this.dataArrived(null, this.settings.data.preloaded)
                }
                if (!this.dataFunc) {
                _ref = this.pies;
                        for (id in _ref) {
                value = _ref[id];
                        value.markDone()
                }
                this.chart.scene.loading = false
                }
                }
        Piechart_Data.prototype.remove = function() {
        return this.removed = true
        };
                Piechart_Data.prototype.getQueueLength = function() {
                return Base_Helpers.countProperties(this.pendingPies) + Base_Helpers.countProperties(this.requestedPies)
                };
                Piechart_Data.prototype.getRootId = function() {
                if (Base_Helpers.isArray(this.settings.area.initialPieId)) {
                return this.settings.area.initialPieId[0]
                } else {
                return this.settings.area.initialPieId
                }
                };
                Piechart_Data.prototype.canExapnd = function(id) {
                return this.pies.hasOwnProperty(id) || (Base_Helpers.isString(id) && id[0] !== this.CS)
                };
                Piechart_Data.prototype.getPieData = function(id) {
                var data;
                        if (!this.pies.hasOwnProperty(id)) {
                return null
                }
                data = this.pies[id];
                        if (this.needPostprocessing()) {
                data = this.filterAndSortData(data)
                }
                return data
                };
                Piechart_Data.prototype.requestMorePieData = function(id, count) {
                if (count == null) {
                count = this.settings.data.itemsToLoad
                }
                if (!(this.pies.hasOwnProperty(id) && !this.pies[id].done)) {
                return false
                }
                this.requestPieData(id, this.pies[id].offset + this.pies[id].values.length, count);
                        return true
                };
                Piechart_Data.prototype.requestLessPieData = function(id, count) {
                if (count == null) {
                count = this.settings.data.itemsToLoad
                }
                if (!(this.pies.hasOwnProperty(id) && !this.pies[id].done && this.pies[id].offset > 0)) {
                return false
                }
                this.requestPieData(id, Math.max(this.pies[id].offset - this.settings.data.itemsToLoad, 0), count);
                        return true
                };
                Piechart_Data.prototype.pieRemoved = function(id) {
                delete this.pendingPies[id];
                        return delete this.requestedPies[id]
                };
                Piechart_Data.prototype.requestPieData = function(pieId, offset, count) {
                var data, end, newMax, newOffset, request, start;
                        if (count == null) {
                count = this.settings.data.itemsToLoad
                }
                if (pieId[0] === this.CS) {
                throw"Invalid Id: " + pieId
                }
                if (this.pies.hasOwnProperty(pieId)) {
                data = this.pies[pieId];
                        start = data.offset;
                        end = start + data.values.length;
                        if (offset < start) {
                count = start - offset
                } else {
                if (offset + count > end) {
                count = offset + count - end;
                        offset = end
                } else {
                return
                }
                }
                } else {
                if (this.needPostprocessing() || !this.settings.data.partialLoad) {
                count = count + offset;
                        offset = 0
                }
                }
                if (this.requestedPies.hasOwnProperty(pieId)) {
                return
                }
                if (this.pendingPies.hasOwnProperty(pieId)) {
                request = this.pendingPies[pieId];
                        newOffset = Math.min(request.offset, offset);
                        newMax = Math.max(request.offset + request.count, offset + count);
                        request.offset = newOffset;
                        request.count = newMax - newOffset
                } else {
                if (this.dataFunc != null) {
                this.pendingPies[pieId] = {offset: offset, count: count};
                        if (!this.requestScheduled) {
                this.requestScheduled = true;
                        return setTimeout(this.runRequests, 0)
                }
                }
                }
                };
                Piechart_Data.prototype.runRequests = function() {
                var id, r, remainingRequests, request, time, timeout, _i, _len, _ref, _ref1;
                        if (this.removed) {
                return
                }
                this.requestScheduled = false;
                        time = new Date().getTime();
                        timeout = this.settings.data.requestTimeout;
                        if (this.cleanupScheduled) {
                this.cleanupScheduled = false;
                        remainingRequests = [];
                        _ref = this.requests;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                r = _ref[_i];
                        if (r.time + timeout > time) {
                remainingRequests.push(r)
                } else {
                id = r.__id;
                        if (this.requestedPies.hasOwnProperty(id)) {
                request = this.requestedPies[id];
                        delete this.requestedPies[id];
                        this.pendingPies[id] = request
                }
                if (r.time !== 0) {
                this.chart.error("Data request timed out, timeout " + timeout + " ms")
                }
                }
                }
                this.requests = remainingRequests
                }
                while (Base_Helpers.hasProperties(this.pendingPies) && this.requests.length < this.settings.data.numberOfParralelRequests) {
                _ref1 = Base_Helpers.removePropertyValue(this.pendingPies), id = _ref1[0], request = _ref1[1];
                        this.makeRequest(id, request.offset, request.count, time)
                }
                this.chart.scene.loading = this.requests.length > 0;
                        this.chart.events.notifySceneChanges({loading: true});
                        if (this.requests.length > 0 && !this.cleanupScheduled) {
                this.cleanupScheduled = true;
                        return setTimeout(this.runRequests, timeout)
                }
                };
                Piechart_Data.prototype.makeRequest = function(id, offset, limit, time) {
                var failFunc, okFunc, request, response;
                        this.requestedPies[id] = {offset: offset, count: limit};
                        this.chart.log("Requesting data on " + id + ", [" + offset + ", " + limit + "]");
                        request = {time: time, id: id, offset: offset, limit: limit};
                        okFunc = (function(_this) {
                        return function(data) {
                        return _this.dataArrived(request, data)
                        }
                        })(this);
                        failFunc = (function(_this) {
                        return function() {
                        return _this.dataError(request)
                        }
                        })(this);
                        response = this.dataFunc(id, limit, offset, okFunc, failFunc);
                        if ((response != null) && (Base_Helpers.isObject(response) || Base_Helpers.isString(response))) {
                return this.dataArrived(request, response)
                } else {
                return this.requests.push(request)
                }
                };
                Piechart_Data.prototype.dataError = function(request) {
                var p;
                        if (request) {
                p = new Piechart_PieData(request.id);
                        p.done = true;
                        this.pies[request.id] = p;
                        this.chart.error("Data request failed for pie: " + request.id);
                        Base_Helpers.removeFromArray(this.requests, request);
                        delete this.requestedPies[request.id]
                } else {
                this.chart.error("Data request failed")
                }
                this.cleanupScheduled = true;
                        return this.runRequests()
                };
                Piechart_Data.prototype.dataArrived = function(request, rawData) {
                var allOk, data, id, newIds, required, _i, _len, _ref;
                        if (this.removed) {
                return
                }
                allOk = false;
                        if (rawData) {
                data = Base_Helpers.parseData(rawData, this.settings.data.format, this.chart);
                        id = data.hasOwnProperty("id") ? data.id : request ? request.id : this.getRootId();
                        if (data.error != null) {
                this.chart.error(data.error);
                        allOk = false
                } else {
                allOk = true;
                        _ref = ["values"];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                required = _ref[_i];
                        if (!data.hasOwnProperty(required)) {
                allOk = false;
                        this.chart.error("Field " + required + " not set in data")
                }
                }
                if (data.hasOwnProperty("offset") && parseInt(data.offset) >= 0) {
                data.offset = parseInt(data.offset);
                        if (request && request.offset !== data.offset) {
                allOk = false;
                        this.chart.error("Response Offset " + data.offset + " does not match request offset: " + request.offset);
                        this.markDone(id)
                }
                } else {
                if (request) {
                data.offset = request.offset
                } else {
                data.offset = 0
                }
                }
                data.limit = parseInt(data.limit) ? parseInt(data.limit) : request ? request.limit : Infinity
                }
                } else {
                this.chart.error("Got empty response")
                }
                newIds = {};
                        newIds[id] = true;
                        if (allOk) {
                if (request) {
                this.chart.log("Data arrived, id=" + id + ", offset=" + request.offset + ", len=" + data.values.length + " of " + request.limit)
                } else {
                this.chart.log("Data arrived, id=" + id + ", offset=" + data.offset + ", len=" + data.values.length + " of " + data.limit)
                }
                this.addData(id, data.values, data.offset, data.limit, data.afterSum, data.beforeSum, data.sum, data, newIds)
                }
                this.chart.events.notifySceneChanges({dataArrived: true, dataArrivedIds: newIds});
                        if (request) {
                Base_Helpers.removeFromArray(this.requests, request);
                        delete this.requestedPies[request.id];
                        return this.runRequests()
                }
                };
                Piechart_Data.prototype.addData = function(id, values, offset, limit, afterValue, beforeValue, sum, dataObj, newIds) {
                var builinKeys, key, pie, seenIds, v, val, _i, _len, _results;
                        seenIds = {};
                        for (_i = 0, _len = values.length; _i < _len; _i++) {
                v = values[_i];
                        v.value = parseFloat(v.value);
                        if (!v.id) {
                v.__id = this.CS + this.nextId;
                        this.nextId++
                } else {
                v.__id = "" + v.id;
                        if (seenIds.hasOwnProperty(v.__id)) {
                this.chart.error("Data response: Multiple slices with the same ID: " + v.__id)
                }
                seenIds[v.__id] = true
                }
                if (v.subvalues) {
                newIds[v.__id] = true;
                        this.addData(v.__id, v.subvalues, 0, Infinity, 0, 0, 0, null, newIds);
                        this.markDone(v.__id)
                }
                }
                if (this.pies.hasOwnProperty(id)) {
                pie = this.pies[id]
                } else {
                pie = this.pies[id] = new Piechart_PieData(id)
                }
                pie.addData(values, offset, limit, afterValue, beforeValue, sum, this.chart);
                        if (dataObj) {
                builinKeys = {values: true, id: true, offset: true, limit: true, afterSum: true, beforeSum: true, subvalues: true, sum: true};
                        _results = [];
                        for (key in dataObj) {
                val = dataObj[key];
                        if (!builinKeys[key]) {
                _results.push(pie[key] = val)
                } else {
                _results.push(void 0)
                }
                }
                return _results
                }
                };
                Piechart_Data.prototype.markDone = function(id) {
                if (this.pies.hasOwnProperty(id)) {
                return this.pies[id].markDone()
                }
                };
                Piechart_Data.prototype.getDataFunction = function() {
                var config;
                        config = this.settings.data;
                        if (config.dataFunction) {
                return config.dataFunction
                } else {
                if (config.url) {
                return function(pieId, limit, offset, success, fail) {
                var params;
                        params = [];
                        if (pieId != null) {
                params.push(["id", pieId])
                }
                params.push(["limit", limit]);
                        params.push(["offset", offset]);
                        return Base_Helpers.doRequest(config.url, params, success, fail)
                }
                } else {
                return null
                }
                }
                };
                Piechart_Data.prototype.needPostprocessing = function() {
                return(this.chart.settings.filters.sliceFilter != null) || this.chart.settings.data.sortSlices
                };
                Piechart_Data.prototype.filterAndSortData = function(pieData) {
                var filter, newData, slice, total, totalCount, values, _i, _len, _ref;
                        filter = this.chart.settings.filters.sliceFilter;
                        if (filter) {
                total = pieData.total || 0;
                        totalCount = pieData.totalCount || 0;
                        values = [];
                        _ref = pieData.values;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                slice = _ref[_i];
                        if (filter(slice)) {
                values.push(slice)
                } else {
                total -= slice.value;
                        totalCount -= 1
                }
                }
                newData = {values: values, done: pieData.done, beforeSum: pieData.beforeSum, afterSum: pieData.afterSum};
                        if (pieData.total) {
                newData.total = total
                }
                if (pieData.totalCount) {
                newData.totalCount = totalCount
                }
                pieData = newData
                }
                if (this.chart.settings.data.sortSlices) {
                pieData.values.sort(function(x, y) {
                return y.value - x.value
                })
                }
                return pieData
                };
                return Piechart_Data
        })();
        var Facetchart_Selection;
        Facetchart_Selection = (function() {
        Facetchart_Selection.prototype.scene = null;
                Facetchart_Selection.prototype.events = null;
                Facetchart_Selection.prototype.currentItem = null;
                Facetchart_Selection.prototype.currentFacet = null;
                Facetchart_Selection.prototype.draggedLabelItem = null;
                Facetchart_Selection.prototype.draggedLabel = null;
                Facetchart_Selection.prototype.hoverEvent = null;
                function Facetchart_Selection(chart) {
                this.chart = chart;
                        this.scene = chart.scene;
                        this.events = chart.events;
                        this.dragPointers = {}
                }
        Facetchart_Selection.prototype.doAnimations = function(event) {
        if (this.hoverEvent) {
        return this.onPointerMove(this.hoverEvent)
        }
        };
                Facetchart_Selection.prototype.previewPointerDrag = function(event) {
                return this.hoverEvent = event
                };
                Facetchart_Selection.prototype.onPointerMove = function(event) {
                var item;
                        this.hoverEvent = event;
                        item = this.scene.findItemAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        if (item) {
                event.cursor = "pointer"
                }
                return this.switchcurrentItem(item, event)
                };
                Facetchart_Selection.prototype.onPointerOut = function(event) {
                return this.switchcurrentItem(null, event)
                };
                Facetchart_Selection.prototype.onPointerDown = function(event) {
                var _ref;
                        _ref = this.scene.findLabelAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance), this.draggedLabelItem = _ref[0], this.draggedLabel = _ref[1];
                        if (this.draggedLabel) {
                return event.consumed = true
                }
                };
                Facetchart_Selection.prototype.onPointerUp = function(event) {
                if (this.draggedLabel) {
                this.draggedLabel = null;
                        return event.consumed = true
                }
                };
                Facetchart_Selection.prototype.onPointerCancel = function(event) {
                if (this.draggedLabel) {
                return this.draggedLabel = null
                }
                };
                Facetchart_Selection.prototype.onPointerDrag = function(event) {
                var label;
                        if (this.draggedLabel) {
                label = this.draggedLabel;
                        label.userPlaced = true;
                        label.x += event.dx;
                        label.y += event.dy;
                        event.consumed = true;
                        return event.changes.label = true
                }
                };
                Facetchart_Selection.prototype.onClick = function(event) {
                var n, userEvent;
                        n = this.scene.findItemAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        event.clickItem = n;
                        event.clickFacet = n ? n.facet : null;
                        event.consumed = true;
                        if (n) {
                event.cursor = "pointer"
                }
                userEvent = this.chart.notifyClick(event);
                        if (!userEvent.defaultPrevented) {
                return this.updateSelection(event, n, false)
                }
                };
                Facetchart_Selection.prototype.onRightClick = function(event) {
                var n, userEvent;
                        n = this.scene.findItemAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        event.clickItem = n;
                        event.clickFacet = n ? n.facet : null;
                        userEvent = this.chart.notifyRightClick(event);
                        if (n) {
                event.cursor = "pointer"
                }
                if (userEvent.defaultPrevented) {
                return event.consumed = true
                }
                };
                Facetchart_Selection.prototype.onDoubleClick = function(event) {
                var n;
                        n = this.scene.findItemAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
                        event.clickItem = n;
                        if (n) {
                event.cursor = "pointer"
                }
                this.chart.notifyDoubleClick(event);
                        return event.consumed = true
                };
                Facetchart_Selection.prototype.updateSelection = function(event, target, softDeselect) {
                if (!this.scene.settings.interaction.selection.enabled) {
                return
                }
                if (!event.shiftKey && (!target || target.selected)) {
                return this.setSelection([])
                } else {
                if (target && event.shiftKey || (softDeselect && target.selected)) {
                if (!target.selected) {
                this.scene.selection.push(target);
                        target.selected = true;
                        return this.setSelection(this.scene.selection, this.scene.selectionIds, true)
                }
                } else {
                if (target) {
                return this.setSelection([target])
                }
                }
                }
                };
                Facetchart_Selection.prototype.switchcurrentItem = function(obj, event) {
                if (obj === this.currentItem) {
                return
                }
                event.changes.current = true;
                        if (this.scene.hoverItem) {
                this.scene.hoverItem.active = false
                }
                this.scene.hoverItem = obj;
                        this.currentItem = obj;
                        this.currentFacet = null;
                        if (this.currentItem) {
                this.scene.hoverItem.active = true;
                        event.hoverItem = this.currentItem
                }
                this.events.notifySceneChanges({items: true});
                        return this.chart.notifyHoverChanged(event)
                };
                Facetchart_Selection.prototype.onSceneChange = function(event) {
                if (event.changes.items) {
                if (this.updateSelectionIds()) {
                this.events.notifySceneChanges({selection: true});
                        return this.chart.notifySelectionChanged(origin)
                }
                }
                };
                Facetchart_Selection.prototype.updateSelectionIds = function() {
                var facet, id, item, itemsToSelect, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
                        itemsToSelect = [];
                        _ref = this.scene.selectionIds;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                id = _ref[_i];
                        _ref1 = this.scene.activeFacet;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                facet = _ref1[_j];
                        _ref2 = facet.items;
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                item = _ref2[_k];
                        if (item.id === id) {
                itemsToSelect.push(item);
                        break
                }
                }
                }
                }
                if (itemsToSelect.length > 0) {
                for (_l = 0, _len3 = itemsToSelect.length; _l < _len3; _l++) {
                item = itemsToSelect[_l];
                        if (!item.selected) {
                item.selected = true;
                        this.scene.selection.push(item)
                }
                Base_Helpers.removeFromArray(this.scene.selectionIds, item.id)
                }
                }
                return itemsToSelect.length > 0
                };
                Facetchart_Selection.prototype.setSelection = function(selection, selectionIds, alreadyChanged, origin) {
                var hasChanges, s, _i, _j, _len, _len1, _ref;
                        if (selectionIds == null) {
                selectionIds = []
                }
                if (alreadyChanged == null) {
                alreadyChanged = false
                }
                if (origin == null) {
                origin = "user"
                }
                this.scene.selectionIds = selectionIds;
                        if (alreadyChanged) {
                hasChanges = true
                } else {
                _ref = this.scene.selection;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                        if (!Base_Helpers.arrayContains(selection, s)) {
                s.selected = false;
                        hasChanges = true
                }
                }
                for (_j = 0, _len1 = selection.length; _j < _len1; _j++) {
                s = selection[_j];
                        if (!s.selected) {
                s.selected = true;
                        hasChanges = true
                }
                }
                this.scene.selection = selection
                }
                hasChanges || (hasChanges = this.updateSelectionIds());
                        if (hasChanges) {
                this.events.notifySceneChanges({selection: true});
                        return this.chart.notifySelectionChanged(origin)
                }
                };
                return Facetchart_Selection
        })();
        var Base_images_logo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAAkCAYAAACkCKB2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAFbxJREFUeNrsXQt4FFWWPp2k0yEPHgKB8BaQlzwEwgwP37LKMrwcHUQcmRnHDYzuuLPKqviBozI64Koz6qoQ0XHcHWARR8URGQmgO6IYExCIMPIOCEh4JyGvTrrn/tXndm5XV3VXd7qTdq3/+87X1VW3bt261fXfc/977m2H1+slGzZsRI7cfIddCTbihqI8LyXZ1WDDRpPwz8KOCfPaZlsM7Bj/pjTYBG3DRtPwirAcuxpsxAg5/JvSkGLXh40WlQlyc1u2G1lUhDL8iLffiPKFsmEj1iRtTNCO/OLvbrUkOynt1GEa9OZCSmpwk9cRcQfjamGv8/ZqYfd+l6oPZNcCyBOW38Q8FvHnGzY32EgkJJIHfRkcKmGXCksXdljYNmGFwk59S+ozQ1h33u6c4GVFOSfyNnSvd7+Fv98HmFzbCVtsv842bIKOPX4gbJ6wsXDgDY4fF7ZC2CPCKhK8Pj3Kdn2Cl3WosCW8/XkLEvRI/oym69bbfoVt2AQdP4B050NcCJEmh6UCEPgdwnbbjy0mUBuQqhYsRx5/zo7i3MW2NGHDJuj4AF7zr5Xvu4S9Qz5JA55yJ2FXCZvK26PZy7tc2Df2o/t/A8gTZ6M890CUxG7DxrcCLRVmN1nYE8p3bEN/fkjY28I2CFvOL18uEzfQR9h/h/G4EwWJPgOo0sSbbm6MtF9DGzase9AIkv6eRYKBZrxO2Gdh0rXi/Gr4+wLl2OPkkznM8LUwhEGtFTaebZKwreTTrzGo2ENYlrAGTl/IBH9eWJqwa4R9X1hfYdl83zi2m/P92AKJYEBtEHt8uM5JYXuFbebz6w3qBufdIKy/sI68/xjX159CSAud+LyhfG+t+ZroOewgX4TI0TBlRmM2TthAYd2EXcR1gm0X14WadgE1jgHgWkspcHAWvZkJfC8Z3Mv5SthGblAjRm5u7nje7K1IHQXsGRM/d2wX87ZMn8/7evM+9RwJ+Vtpp3jb+U3w1mOO7LR+NGvw/dQ5qxtV1pZT4dGPaG3pC9qx2UOepqU77zM8z+zYoLbX0sS+M7X8vqn4mtbuW067zm3U9g/LHkcr9iwMm8+4TjNocPYow+uqadWy41qvlzxJZTV7Qt7vrf0W0PayzVqZQu3H99auttp2ee052nD4f03zRtr+HYZQpqt1wD2rx63kZVZH2H9F9x/4vyMPfRqjdEZ1Fg0c+qnejvziV8XHzyLIAyPpT+r29WSiBzFeIqwN+QbQTpNv0G8Ke+87mDhrLFwH5LiFibhMmFN5+Yywh8lzLJOKGTxMRg9RsvOcLsyuEzcgs/h6ZnhG2H18z2vlsyRfNIqZjIQIlblMcPq6+0RYlxDXQ+PwNNe7V1dHN3I5LmMiVYFBwTkWn+sQYSWcx9NhpIS/gECLiopqIiDnPK73IP6hxrC5/Uy+xZz2AD/zf+J9Mg/1HPmbXMRkfFZpBA5wj8xP0hwHvZ+3+0TUwPimekfVU8IL/czEFXSy8hs6UXHc1ypn5dDta4Zpx16fvoFmrbouiMzMjk3seTc9eM1i2nV8O1XWVVBmapYgrKP0yCfTNSK+cciPacLyTv70c3OX0bAuo7TrqcD+8f0ma9vpqRlUVXfBf2zWn6/QyE1fdpS7Y2ZnunftrUHlVbFu5gl6a+f/BJGWfj++y7wH5wzXyrFo0wP+xsv/Y75hM/Vq35dKjm/z11/Pi/oEpEVeKszyemTsKrq230S6eeWIAAJH3d02cjYVln6s1Smud6GukhYU/EvAvcp0an2pdRYNN2OqtxF5NESYkUfnKWNA7z+YlPXoq/v+hEVyBnax1zmHvWCjcqiSTT82o/tzsxfp4HN+Qb6wuB+SV8641IgJcstoA2nAw/fqVDxQPVqHuZ/hwtYIG0WBA58ZCjnXM9HL8rbl/R2ZgOAN/1JXn1NNrufmsiO/TL53h8lzdCs9gsd05OzhfJI4H+KGODWCZwkyzBfECPJdzyS8WPF0VbTje32Q01jRrAu4zG8oaSVp51EChOTNu/J3GrHM3TShyXmBMEHOfypeasljQ/opg2doRKXHU0V3CgtNqAvHvxxUdhAc7klP+NHi44MF/uvCC8b9Fa1c7yc7kDOgNjqyB7D5xMqAfeo9gEj1eWneSJeRGrle1+OWIA8Z+9V7RSOGBkpPvkinL088NOgXhU3nLqXephp4fLv4M4dfjN8YkHM5vyi1OhL4PMLyfqTTTZ/lco0RNoK98dvZM1e14H38ck5kz3Ioyw/zlDLdSElJNzlrKyi5rg7e8zMKOXvZ+xzLXuoAzmeasJXcM9CjhuvqLvb4ULaryTcwWqGQ8Yu654DyvCTsZr5Gf7YBLFm8pqT9VyZHI5LdxeR6M5cbb85/km+QFY3D3UraYt43gg0S10FuKFRyfp6PD+R6GMPEWUjGIZLhSFol4wMG5CylimKFVK1IFMUGcob8Pr6lyRmEA0/vyU/viUl+0wfNodIz+y13p+8Yfr/mEeq9SCuAp94xsxO9ui2w0/zi1vnaPeF4rAHCBPndeMlsfxkG5Qyj5z5bEJRWT85GkoOal5RrcE+HTu/T5JJwQCMGLxoST0to0NvYjHADe3wSz3GXHp7cB/ziSnzBZLKZ9dI6Ye2FDRY2g1+UCxGWt0zZvsDadaUuDcjiQ76HDvI3KexvJvfaoEg0eeTxvCn4+GKx/RPF4wbpr9Cde5waI0+MvOV3+D6NGpkPuDHLYNIeyvUlu/V3GZwHzfwEyx/p3IgSy1GblIZE4lFhq0LU4UW6BnSHQdoxikyC+9EzyhGWnZ6m+A2KtqOmzxQkRe5o8djpkV3HaQQZZdc3CKN7XaV5iVagacw5wzU5IipvveNwOll5IkjKwL2gkcDxtaWxrzOQZ5bL5/dd23uyJuWEklPC5ZWT1d3/HV4zSHvbsS10ff9plvL49NAmGtNL+EZxnjwbSRRHTybcLNlYsZyBQbhXdeT8W/ba4OEWMZmdZl34z0wukyny6IFMVaNRyqLH16yLynS9QuT5nl/WcTj6pNRWiRM817KkoD0LA3Imgx6CkQdthi1MtH45M8J6+LVSd+NNGohwkS4uC7+DDjrP3gz1UUhjkSBW6w8kxAAhCHLvqS9jkhfkig6Z2fS3I+9ZSj/n+/OoYM+7UZMbBgUPnt5reAyaMY7HAxmuzID623c6+ukQHbM60/GKI/7v8Joh2aAO4UnDow6Ho+WllJGaGfffilWCdjJJyenLZ4TdyS9lHnfhpQeHbjfC5aoDcsC6FtraFv6e8GYTaSAUIhG49inbbUOkq2bvHmVLS6kWDrnHM1w5vj5Odav+ys1+1Q4+BlnhCrZR3DBVKCTa2eTcpmK72pMm3xjACGreMEcz6aMliT5h0M6VbTkt9Nd0QSrookcLDMSZAVEUF7e/JC73iUFIkKJERe35qBs0kPCR8safFPRnNJhotKQOHfbFKNusNYzIT5+/NCtEH43EYYSF3N2VQJf/79z9/ZWyHxploLCVLC6RlEzwTDVXy+nSFiXSuBx0Xi+40euxUoa2FFl0iUoiobrfjUTmcJCzpjyZvN4eam8mTu+W6pGm6d8DrldISn0Negp1yrND+VPj6LlCkrmKv89k2aaE96+IY/3EAhifGEmN0T4tHnMdqccb1hvPHkWnKsssecRWu+/hiBIDeEYAacbaqwTJ3TXiN5rmCy1a1p8eajhdSdnnAVo0pBEZPog6gDwi9XepP8vnAU9a06GjUJ9QLkTYSOC5NHXQMMXij3yujoRlKBkGrS7m7XMsbTQitRV1OXucbv/ifRp9ZBfVJyfTedFVOdS2MxV1HUAeQS3bOvWlk1nthdcatoc8X7lWvCCI3OHUSQblzfDeqg3IlcL+GEaWSQ1xfizh5kZxGaQ/pWcwlO1ulpLm6noELQ3ozKuYkNVQuxaXOE7VfK15aZF4viG1tdpzltIhvGzLoY80bzFUjLUVSC04nkBYIAzlhraNsDa1/vSYOOBmrfFA+sLSSwMIGmGDMBxbU7IyoAch9WfEMMs4ZtRRVM9WELKq7aOs8fag4Um+qHij8JrUJztJ2cYkiMYp2CkuGn1oGz2+Pp96lJdRTYqPU5KEt3z54R10244PqE7sm3LrE/CwHYKgQ5HML3XXbU7CbE70ZK9UhtmVcWOIaJeD7HVnsOyxiMKH8sUCuO549p6ncKPcVSFr7MPAL6JDjicIOUtZSh9qt5RaOIoDg2kgBHhz4SIOLGlQWlf7Mc2zDOVF45qIiUaIGLzIaAkaHqaZzoyBN8QvxwLQyTHpBFDvS9afHjK876lr1gUdk2F2CM3Tlx3eMogbjYHamMGzDjWIa9bARqvtmyGUToo4X8xYkwNFZ9ibcitd68uV9O805ppMbarO0uMFL1NO5RnhNWdQbbJTs2pB3JXCs65KTaNk4TVP2vMJtGl08R8mX3gXCMjJkgaCD9Gfeo5zria9th1biHvyurk34O/VNeP7e49Czp+xB/gzbiTfJ1/YHtYjeamZPHu1wYL+DHEOMzevD3jePlJ8IEG85zwuD8L/9KF27RKhgOiux8oLlR5lrzYDLaXHjD906eFFxxqYzScn3TQVkEtAdkaEF239rfn7cvpez8sDtOE+HfprXjWkCGlWdOhIpKV4ETRm0I1SXtAfszclAVKVteQJ9J6dNL1kI3U7X0ZVTpdCfuob76C65BTKK3qXcku3V1NKKmbAIboBw9sYnNrNpHQdn4LmbBo3FHGiIS+507IayOFQA4XGNaPHrg6CPkW+aBTDd0FXn83576Xn2UOdRo0L3RMlQHyxIskdIOMV7hJi3Y+dx4q1WXyx8sgR9obwNqvpQUjR6tEYTEMUhREwQIiBwngDIW7R1B90Z8glMn4ZRI3Y7V0nA6OKrcRDo7eAdPGGGUFjcsO/Kd9/x2Rp4HH6CaZRRBaece7Rr6g+KWCwH4scYf2MIu6yF3ocSYXp7trl4458icHEM5wfuvlwB2RkAjzFPzJRb6DgAbVY8qTDndEGHn2hsnNCM767KtHWhkmbpjzDhiZeyxNleRcqDWZCeKffBqzatSSmkzo++OptbWag1agB6UVHc/239i7VJAD9uRiEQ57I2wz6+GNJksgPA3uWiXbf8qjrDwOccip7bidf8FnRicBALYTwhdKhISdhWvhHB9e1CEHjKb+qHENX1kiwgtRwkrfBxOrEB2pwBEVioUkazl5MLnvnozwOR/dT6ZBSvVJKgZeOiRdv8nXhVf6Uvcn4jk40NFBt646uhhRXgcPrlRNgLqPgCRp6dIgRMX+l7JsZIv1NSn0fCeFph0K1hfJjjCLU+hR4numy55ngvDiSEmSBf3SLMVHlnnEPB4Rp6QkWOqcatmUG6Kvwoh+76g8BeZgRtvSibx2WF5XHjrLjXFkmXAfx1eEm30BiALGpxIoIDZQ9Ej0e9Yfyo/4iJWl1yjd6HfCo9WX+9EhBUDy0fAZoiDClHZEgZosmWXlmVmE0SIhuqxrWBT14mQmZqwv6YCqzb7aeIOdTwhNNDgyfC/IIMWBY7sp4e3P3wZlUXy+JANrhqjBSQHzgqafai7qmVnfoXpZxYv/z3pTUeXwEE27Q3EL7LWWPExo5Ii4mcZf6JzEoARrGPG7wZnAv4gUmbjcTKXo3cxRSxz8AR/NPM3uZpDHWMJivs4yfExpQiGtYeQ9vDibdYILRZu7RQLdCTPZ8xZP/vybcdyzlkWJqXMXurE76SJiV7LC2Awa0lkxb4x/0grZ60+rG9vDZqYHzo17+9BnT8DxEOYA4Vs/Y6s8PURsYGDTzolcP3qoRXKRTvlF2DLjJssMDBmGFW1cE1xlUMlxbC+Oeuof9+6OZ1eiLxFgWlJeM1AgFDEBC4qkS9b39WLDnjsaiqu5Zvw6ths/hftEQGd2rPswOMFrwKiLPzWA1OyydGY3uCkFmqPbSp7aiH217nx7fsIzK0/wLqhVS4DRxyqyrPrvx4hG9754yd6bX0/ACeb0ggkvJfGJCOyaW9kwUWJ/CbFQCT+1R3kYUyH+ZpINXVcJEdYxcrQZkF79X0evD15wNqa1WsLeqop4bCnV1O/QyIOqpq9lB0pkVor6w1se/K43iPINy+317bhT0K+rtJF/4m1wWFL2OH/L2beSLrAmFZw16B26+Dtba2M313Vd3PEUnkWDC0diioqKIo0dzc3PXs3c7mxonksjnv58/zbx4o9XsQM7I8w1u7CU553H+I9X8Wmo1O9XLxboQmDiBrrb05oy8L/mih4rYkPG++lhgo6iEcJEK4Y6bXcvqPZst/xnuuvq0IFLEQKMce89vDTjXLC/pHZtdRz1PfRYYlDU7J9Qzi4abzVazi/ZfVvqyF7mE6mtp7YBxdMuXm2jgyVKqdrqCEqc21HsrU1v99KVRU73epORHqUGbufwxhZ415lC61OkUenDMabJtlGcrf57uOseZfqOp8/a/ul0Vp2/zJCXvZ4kl26R+KpjgpdQj4QpTX6km24+xXDBHIcZkXd6QX+BK3UuBazanRfgcEb+MAUe4Chm6upLdH3jOdygyiNPAY0UDGO3CEg8yocpeUz417V9SCjjPRUzMxJ7zdOV7wgAvu1HIW6gXO9QxEKURWRqRSjgSDHfc7FrR3rPV6+rTGkkN4fKK5N6tkmw8IjqMXmIMcXa06BngJZ7MLzCAyI9PyOPZcSEtk+Zfdye99tYiSnfXIGIjxc+w7prTF5xpv7r/+l+s2dlt4Gqqq5Ev/+/DXK+SXzQXe3KhIjrgPcoFiL4Ike4b9n5TNO/f01BVn9meKroOoLSSD2spNRnhY4hJupp8YYXtuG6gvyPqBOFwhzmvz1mCIJZCQgFEtMlAeya+3hKWja5nqUP+ycAXTGiHDPJcyDKJ7LGEA+rw5+RbpvQW7pHUcrlk/g+wt4/ZhGOYqL3cc3mfZQ93EyWJXEXmUKMvci3UodFi/Yt5/0glz7NkPtU7l2zYSEAYSRyR5gFPFsKLXJqzjLv2fyVXOk0q2Ui/LcintPq6dR5HUqv6pKT3tnS79JXfj72lemdOv+XkrpHrFz9P4QfjmgfONOq1IZ+yd2yghtQ0+1diEZALvkuIhcRhw0akEkekqGJpA15XF5YCMJniFaqt+sNfBl5ZfKR1x4YrSndOKE9Lp90derUp7tJvusfpuk+Qs/ynE8xQfCihqsdrv3c2bNhoWcTqX70h2GAxfMw2wyAfdMo5mtXXbd/edeDu7T2GXBCk1528ntFiX2ty+4M6MKg2k4LXdbZhw4YNm6BjBMz+Q9gZ/uYAC87Lga9hgpCHaavWBQIj/4hWwDTmBvtR2LBhw0b8CBrAoB1CxxCbi8FDxJ1gBbo2TMIgZQyI4R9FIIMctR+BDRs2bBgjaJDQhg0b1sCDhJjMk2PXho0YApFlORgkTLLrwoaNJuFOUhcKs2GjaYCq8HP5JcWuDxs2moS1tgdtI174hwADAIWSg7lTzeQwAAAAAElFTkSuQmCC";
        (function(undefined) {
        var moment, VERSION = "2.0.0", round = Math.round, i, languages = {}, hasModule = (typeof module !== "undefined" && module.exports), aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g, parseMultipleFormatChunker = /([0-9a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)/gi, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{1,4}/, parseTokenSixDigits = /[+\-]?\d{1,6}/, parseTokenWord = /[0-9]*[a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF]+\s*?[\u0600-\u06FF]+/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, parseTokenT = /T/i, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, isoRegex = /^\s*\d{4}-\d\d-\d\d((T| )(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoTimes = [["HH:mm:ss.S", /(T| )\d\d:\d\d:\d\d\.\d{1,3}/], ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/], ["HH:mm", /(T| )\d\d:\d\d/], ["HH", /(T| )\d\d/]], parseTimezoneChunker = /([\+\-]|\d\d)/gi, proxyGettersAndSetters = "Month|Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {Milliseconds: 1, Seconds: 1000, Minutes: 60000, Hours: 3600000, Days: 86400000, Months: 2592000000, Years: 31536000000}, formatFunctions = {}, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {M: function() {
        return this.month() + 1
        }, MMM: function(format) {
        return this.lang().monthsShort(this, format)
        }, MMMM: function(format) {
        return this.lang().months(this, format)
        }, D: function() {
        return this.date()
        }, DDD: function() {
        return this.dayOfYear()
        }, d: function() {
        return this.day()
        }, dd: function(format) {
        return this.lang().weekdaysMin(this, format)
        }, ddd: function(format) {
        return this.lang().weekdaysShort(this, format)
        }, dddd: function(format) {
        return this.lang().weekdays(this, format)
        }, w: function() {
        return this.week()
        }, W: function() {
        return this.isoWeek()
        }, YY: function() {
        return leftZeroFill(this.year() % 100, 2)
        }, YYYY: function() {
        return leftZeroFill(this.year(), 4)
        }, YYYYY: function() {
        return leftZeroFill(this.year(), 5)
        }, a: function() {
        return this.lang().meridiem(this.hours(), this.minutes(), true)
        }, A: function() {
        return this.lang().meridiem(this.hours(), this.minutes(), false)
        }, H: function() {
        return this.hours()
        }, h: function() {
        return this.hours() % 12 || 12
        }, m: function() {
        return this.minutes()
        }, s: function() {
        return this.seconds()
        }, S: function() {
        return ~~(this.milliseconds() / 100)
        }, SS: function() {
        return leftZeroFill(~~(this.milliseconds() / 10), 2)
        }, SSS: function() {
        return leftZeroFill(this.milliseconds(), 3)
        }, Z: function() {
        var a = - this.zone(), b = "+";
                if (a < 0) {
        a = - a;
                b = "-"
        }
        return b + leftZeroFill(~~(a / 60), 2) + ":" + leftZeroFill(~~a % 60, 2)
        }, ZZ: function() {
        var a = - this.zone(), b = "+";
                if (a < 0) {
        a = - a;
                b = "-"
        }
        return b + leftZeroFill(~~(10 * a / 6), 4)
        }, X: function() {
        return this.unix()
        }};
                function padToken(func, count) {
                return function(a) {
                return leftZeroFill(func.call(this, a), count)
                }
                }
        function ordinalizeToken(func) {
        return function(a) {
        return this.lang().ordinal(func.call(this, a))
        }
        }
        while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
                formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i])
        }
        while (paddedTokens.length) {
        i = paddedTokens.pop();
                formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2)
        }
        formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
                function Language() {
                }
        function Moment(config) {
        extend(this, config)
        }
        function Duration(duration) {
        var data = this._data = {}, years = duration.years || duration.year || duration.y || 0, months = duration.months || duration.month || duration.M || 0, weeks = duration.weeks || duration.week || duration.w || 0, days = duration.days || duration.day || duration.d || 0, hours = duration.hours || duration.hour || duration.h || 0, minutes = duration.minutes || duration.minute || duration.m || 0, seconds = duration.seconds || duration.second || duration.s || 0, milliseconds = duration.milliseconds || duration.millisecond || duration.ms || 0;
                this._milliseconds = milliseconds + seconds * 1000 + minutes * 60000 + hours * 3600000;
                this._days = days + weeks * 7;
                this._months = months + years * 12;
                data.milliseconds = milliseconds % 1000;
                seconds += absRound(milliseconds / 1000);
                data.seconds = seconds % 60;
                minutes += absRound(seconds / 60);
                data.minutes = minutes % 60;
                hours += absRound(minutes / 60);
                data.hours = hours % 24;
                days += absRound(hours / 24);
                days += weeks * 7;
                data.days = days % 30;
                months += absRound(days / 30);
                data.months = months % 12;
                years += absRound(months / 12);
                data.years = years
        }
        function extend(a, b) {
        for (var i in b) {
        if (b.hasOwnProperty(i)) {
        a[i] = b[i]
        }
        }
        return a
        }
        function absRound(number) {
        if (number < 0) {
        return Math.ceil(number)
        } else {
        return Math.floor(number)
        }
        }
        function leftZeroFill(number, targetLength) {
        var output = number + "";
                while (output.length < targetLength) {
        output = "0" + output
        }
        return output
        }
        function addOrSubtractDurationFromMoment(mom, duration, isAdding) {
        var ms = duration._milliseconds, d = duration._days, M = duration._months, currentDate;
                if (ms) {
        mom._d.setTime( + mom + ms * isAdding)
        }
        if (d) {
        mom.date(mom.date() + d * isAdding)
        }
        if (M) {
        currentDate = mom.date();
                mom.date(1).month(mom.month() + M * isAdding).date(Math.min(currentDate, mom.daysInMonth()))
        }
        }
        function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]"
        }
        function compareArrays(array1, array2) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
                for (i = 0; i < len; i++) {
        if (~~array1[i] !== ~~array2[i]) {
        diffs++
        }
        }
        return diffs + lengthDiff
        }
        Language.prototype = {set: function(config) {
        var prop, i;
                for (i in config) {
        prop = config[i];
                if (typeof prop === "function") {
        this[i] = prop
        } else {
        this["_" + i] = prop
        }
        }
        }, _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), months: function(m) {
        return this._months[m.month()]
        }, _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), monthsShort: function(m) {
        return this._monthsShort[m.month()]
        }, monthsParse: function(monthName) {
        var i, mom, regex, output;
                if (!this._monthsParse) {
        this._monthsParse = []
        }
        for (i = 0; i < 12; i++) {
        if (!this._monthsParse[i]) {
        mom = moment([2000, i]);
                regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")
        }
        if (this._monthsParse[i].test(monthName)) {
        return i
        }
        }
        }, _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdays: function(m) {
        return this._weekdays[m.day()]
        }, _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysShort: function(m) {
        return this._weekdaysShort[m.day()]
        }, _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), weekdaysMin: function(m) {
        return this._weekdaysMin[m.day()]
        }, _longDateFormat: {LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D YYYY", LLL: "MMMM D YYYY LT", LLLL: "dddd, MMMM D YYYY LT"}, longDateFormat: function(key) {
        var output = this._longDateFormat[key];
                if (!output && this._longDateFormat[key.toUpperCase()]) {
        output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
        return val.slice(1)
        });
                this._longDateFormat[key] = output
        }
        return output
        }, meridiem: function(hours, minutes, isLower) {
        if (hours > 11) {
        return isLower ? "pm" : "PM"
        } else {
        return isLower ? "am" : "AM"
        }
        }, _calendar: {sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[last] dddd [at] LT", sameElse: "L"}, calendar: function(key, mom) {
        var output = this._calendar[key];
                return typeof output === "function" ? output.apply(mom) : output
        }, _relativeTime: {future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years"}, relativeTime: function(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
                return(typeof output === "function") ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number)
        }, pastFuture: function(diff, output) {
        var format = this._relativeTime[diff > 0 ? "future" : "past"];
                return typeof format === "function" ? format(output) : format.replace(/%s/i, output)
        }, ordinal: function(number) {
        return this._ordinal.replace("%d", number)
        }, _ordinal: "%d", preparse: function(string) {
        return string
        }, postformat: function(string) {
        return string
        }, week: function(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy)
        }, _week: {dow: 0, doy: 6}};
                function loadLang(key, values) {
                values.abbr = key;
                        if (!languages[key]) {
                languages[key] = new Language()
                }
                languages[key].set(values);
                        return languages[key]
                }
        function getLangDefinition(key) {
        if (!key) {
        return moment.fn._lang
        }
        if (!languages[key] && hasModule) {
        require("./lang/" + key)
        }
        return languages[key]
        }
        function removeFormattingTokens(input) {
        if (input.match(/\[.*\]/)) {
        return input.replace(/^\[|\]$/g, "")
        }
        return input.replace(/\\/g, "")
        }
        function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
                for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]]
        } else {
        array[i] = removeFormattingTokens(array[i])
        }
        }
        return function(mom) {
        var output = "";
                for (i = 0; i < length; i++) {
        output += typeof array[i].call === "function" ? array[i].call(mom, format) : array[i]
        }
        return output
        }
        }
        function formatMoment(m, format) {
        var i = 5;
                function replaceLongDateFormatTokens(input) {
                return m.lang().longDateFormat(input) || input
                }
        while (i-- && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens)
        }
        if (!formatFunctions[format]) {
        formatFunctions[format] = makeFormatFunction(format)
        }
        return formatFunctions[format](m)
        }
        function getParseRegexForToken(token) {
        switch (token) {
        case"DDDD":
                return parseTokenThreeDigits;
                case"YYYY":
                return parseTokenFourDigits;
                case"YYYYY":
                return parseTokenSixDigits;
                case"S":
                case"SS":
                case"SSS":
                case"DDD":
                return parseTokenOneToThreeDigits;
                case"MMM":
                case"MMMM":
                case"dd":
                case"ddd":
                case"dddd":
                case"a":
                case"A":
                return parseTokenWord;
                case"X":
                return parseTokenTimestampMs;
                case"Z":
                case"ZZ":
                return parseTokenTimezone;
                case"T":
                return parseTokenT;
                case"MM":
                case"DD":
                case"YY":
                case"HH":
                case"hh":
                case"mm":
                case"ss":
                case"M":
                case"D":
                case"d":
                case"H":
                case"h":
                case"m":
                case"s":
                return parseTokenOneOrTwoDigits;
                default:
                return new RegExp(token.replace("\\", ""))
        }
        }
        function addTimeToArrayFromToken(token, input, config) {
        var a, b, datePartArray = config._a;
                switch (token) {
        case"M":
                case"MM":
                datePartArray[1] = (input == null) ? 0 : ~~input - 1;
                break;
                case"MMM":
                case"MMMM":
                a = getLangDefinition(config._l).monthsParse(input);
                if (a != null) {
        datePartArray[1] = a
        } else {
        config._isValid = false
        }
        break;
                case"D":
                case"DD":
                case"DDD":
                case"DDDD":
                if (input != null) {
        datePartArray[2] = ~~input
        }
        break;
                case"YY":
                datePartArray[0] = ~~input + (~~input > 68 ? 1900 : 2000);
                break;
                case"YYYY":
                case"YYYYY":
                datePartArray[0] = ~~input;
                break;
                case"a":
                case"A":
                config._isPm = ((input + "").toLowerCase() === "pm");
                break;
                case"H":
                case"HH":
                case"h":
                case"hh":
                datePartArray[3] = ~~input;
                break;
                case"m":
                case"mm":
                datePartArray[4] = ~~input;
                break;
                case"s":
                case"ss":
                datePartArray[5] = ~~input;
                break;
                case"S":
                case"SS":
                case"SSS":
                datePartArray[6] = ~~(("0." + input) * 1000);
                break;
                case"X":
                config._d = new Date(parseFloat(input) * 1000);
                break;
                case"Z":
                case"ZZ":
                config._useUTC = true;
                a = (input + "").match(parseTimezoneChunker);
                if (a && a[1]) {
        config._tzh = ~~a[1]
        }
        if (a && a[2]) {
        config._tzm = ~~a[2]
        }
        if (a && a[0] === "+") {
        config._tzh = - config._tzh;
                config._tzm = - config._tzm
        }
        break
        }
        if (input == null) {
        config._isValid = false
        }
        }
        function dateFromArray(config) {
        var i, date, input = [];
                if (config._d) {
        return
        }
        for (i = 0; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i]
        }
        input[3] += config._tzh || 0;
                input[4] += config._tzm || 0;
                date = new Date(0);
                if (config._useUTC) {
        date.setUTCFullYear(input[0], input[1], input[2]);
                date.setUTCHours(input[3], input[4], input[5], input[6])
        } else {
        date.setFullYear(input[0], input[1], input[2]);
                date.setHours(input[3], input[4], input[5], input[6])
        }
        config._d = date
        }
        function makeDateFromStringAndFormat(config) {
        var tokens = config._f.match(formattingTokens), string = config._i, i, parsedInput;
                config._a = [];
                for (i = 0; i < tokens.length; i++) {
        parsedInput = (getParseRegexForToken(tokens[i]).exec(string) || [])[0];
                if (parsedInput) {
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length)
        }
        if (formatTokenFunctions[tokens[i]]) {
        addTimeToArrayFromToken(tokens[i], parsedInput, config)
        }
        }
        if (config._isPm && config._a[3] < 12) {
        config._a[3] += 12
        }
        if (config._isPm === false && config._a[3] === 12) {
        config._a[3] = 0
        }
        dateFromArray(config)
        }
        function makeDateFromStringAndArray(config) {
        var tempConfig, tempMoment, bestMoment, scoreToBeat = 99, i, currentDate, currentScore;
                while (config._f.length) {
        tempConfig = extend({}, config);
                tempConfig._f = config._f.pop();
                makeDateFromStringAndFormat(tempConfig);
                tempMoment = new Moment(tempConfig);
                if (tempMoment.isValid()) {
        bestMoment = tempMoment;
                break
        }
        currentScore = compareArrays(tempConfig._a, tempMoment.toArray());
                if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
                bestMoment = tempMoment
        }
        }
        extend(config, bestMoment)
        }
        function makeDateFromString(config) {
        var i, string = config._i;
                if (isoRegex.exec(string)) {
        config._f = "YYYY-MM-DDT";
                for (i = 0; i < 4; i++) {
        if (isoTimes[i][1].exec(string)) {
        config._f += isoTimes[i][0];
                break
        }
        }
        if (parseTokenTimezone.exec(string)) {
        config._f += " Z"
        }
        makeDateFromStringAndFormat(config)
        } else {
        config._d = new Date(string)
        }
        }
        function makeDateFromInput(config) {
        var input = config._i, matched = aspNetJsonRegex.exec(input);
                if (input === undefined) {
        config._d = new Date()
        } else {
        if (matched) {
        config._d = new Date( + matched[1])
        } else {
        if (typeof input === "string") {
        makeDateFromString(config)
        } else {
        if (isArray(input)) {
        config._a = input.slice(0);
                dateFromArray(config)
        } else {
        config._d = input instanceof Date ? new Date( + input) : new Date(input)
        }
        }
        }
        }
        }
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture)
        }
        function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000), minutes = round(seconds / 60), hours = round(minutes / 60), days = round(hours / 24), years = round(days / 365), args = seconds < 45 && ["s", seconds] || minutes === 1 && ["m"] || minutes < 45 && ["mm", minutes] || hours === 1 && ["h"] || hours < 22 && ["hh", hours] || days === 1 && ["d"] || days <= 25 && ["dd", days] || days <= 45 && ["M"] || days < 345 && ["MM", round(days / 30)] || years === 1 && ["y"] || ["yy", years];
                args[2] = withoutSuffix;
                args[3] = milliseconds > 0;
                args[4] = lang;
                return substituteTimeAgo.apply({}, args)
        }
        function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day();
                if (daysToDayOfWeek > end) {
        daysToDayOfWeek -= 7
        }
        if (daysToDayOfWeek < end - 7) {
        daysToDayOfWeek += 7
        }
        return Math.ceil(moment(mom).add("d", daysToDayOfWeek).dayOfYear() / 7)
        }
        function makeMoment(config) {
        var input = config._i, format = config._f;
                if (input === null || input === "") {
        return null
        }
        if (typeof input === "string") {
        config._i = input = getLangDefinition().preparse(input)
        }
        if (moment.isMoment(input)) {
        config = extend({}, input);
                config._d = new Date( + input._d)
        } else {
        if (format) {
        if (isArray(format)) {
        makeDateFromStringAndArray(config)
        } else {
        makeDateFromStringAndFormat(config)
        }
        } else {
        makeDateFromInput(config)
        }
        }
        return new Moment(config)
        }
        moment = function(input, format, lang) {
        return makeMoment({_i: input, _f: format, _l: lang, _isUTC: false})
        };
                moment.utc = function(input, format, lang) {
                return makeMoment({_useUTC: true, _isUTC: true, _l: lang, _i: input, _f: format})
                };
                moment.unix = function(input) {
                return moment(input * 1000)
                };
                moment.duration = function(input, key) {
                var isDuration = moment.isDuration(input), isNumber = (typeof input === "number"), duration = (isDuration ? input._data : (isNumber ? {} : input)), ret;
                        if (isNumber) {
                if (key) {
                duration[key] = input
                } else {
                duration.milliseconds = input
                }
                }
                ret = new Duration(duration);
                        if (isDuration && input.hasOwnProperty("_lang")) {
                ret._lang = input._lang
                }
                return ret
                };
                moment.version = VERSION;
                moment.defaultFormat = isoFormat;
                moment.lang = function(key, values) {
                var i;
                        if (!key) {
                return moment.fn._lang._abbr
                }
                if (values) {
                loadLang(key, values)
                } else {
                if (!languages[key]) {
                getLangDefinition(key)
                }
                }
                moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key)
                };
                moment.langData = function(key) {
                if (key && key._lang && key._lang._abbr) {
                key = key._lang._abbr
                }
                return getLangDefinition(key)
                };
                moment.isMoment = function(obj) {
                return obj instanceof Moment
                };
                moment.isDuration = function(obj) {
                return obj instanceof Duration
                };
                moment.fn = Moment.prototype = {clone: function() {
                return moment(this)
                }, valueOf: function() {
                return + this._d
                }, unix: function() {
                return Math.floor( + this._d / 1000)
                }, toString: function() {
                return this.format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
                }, toDate: function() {
                return this._d
                }, toJSON: function() {
                return moment.utc(this).format("YYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
                }, toArray: function() {
                var m = this;
                        return[m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds()]
                }, isValid: function() {
                if (this._isValid == null) {
                if (this._a) {
                this._isValid = !compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray())
                } else {
                this._isValid = !isNaN(this._d.getTime())
                }
                }
                return !!this._isValid
                }, utc: function() {
                this._isUTC = true;
                        return this
                }, local: function() {
                this._isUTC = false;
                        return this
                }, format: function(inputString) {
                var output = formatMoment(this, inputString || moment.defaultFormat);
                        return this.lang().postformat(output)
                }, add: function(input, val) {
                var dur;
                        if (typeof input === "string") {
                dur = moment.duration( + val, input)
                } else {
                dur = moment.duration(input, val)
                }
                addOrSubtractDurationFromMoment(this, dur, 1);
                        return this
                }, subtract: function(input, val) {
                var dur;
                        if (typeof input === "string") {
                dur = moment.duration( + val, input)
                } else {
                dur = moment.duration(input, val)
                }
                addOrSubtractDurationFromMoment(this, dur, - 1);
                        return this
                }, diff: function(input, units, asFloat) {
                var that = this._isUTC ? moment(input).utc() : moment(input).local(), zoneDiff = (this.zone() - that.zone()) * 60000, diff, output;
                        if (units) {
                units = units.replace(/s$/, "")
                }
                if (units === "year" || units === "month") {
                diff = (this.daysInMonth() + that.daysInMonth()) * 43200000;
                        output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                        output += ((this - moment(this).startOf("month")) - (that - moment(that).startOf("month"))) / diff;
                        if (units === "year") {
                output = output / 12
                }
                } else {
                diff = (this - that) - zoneDiff;
                        output = units === "second" ? diff / 1000 : units === "minute" ? diff / 60000 : units === "hour" ? diff / 3600000 : units === "day" ? diff / 86400000 : units === "week" ? diff / 604800000 : diff
                }
                return asFloat ? output : absRound(output)
                }, from: function(time, withoutSuffix) {
                return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix)
                }, fromNow: function(withoutSuffix) {
                return this.from(moment(), withoutSuffix)
                }, calendar: function() {
                var diff = this.diff(moment().startOf("day"), "days", true), format = diff < - 6 ? "sameElse" : diff < - 1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
                        return this.format(this.lang().calendar(format, this))
                }, isLeapYear: function() {
                var year = this.year();
                        return(year % 4 === 0 && year % 100 !== 0) || year % 400 === 0
                }, isDST: function() {
                return(this.zone() < moment([this.year()]).zone() || this.zone() < moment([this.year(), 5]).zone())
                }, day: function(input) {
                var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                        return input == null ? day : this.add({d: input - day})
                }, startOf: function(units) {
                units = units.replace(/s$/, "");
                        switch (units) {
                case"year":
                        this.month(0);
                        case"month":
                        this.date(1);
                        case"week":
                        case"day":
                        this.hours(0);
                        case"hour":
                        this.minutes(0);
                        case"minute":
                        this.seconds(0);
                        case"second":
                        this.milliseconds(0)
                }
                if (units === "week") {
                this.day(0)
                }
                return this
                }, endOf: function(units) {
                return this.startOf(units).add(units.replace(/s?$/, "s"), 1).subtract("ms", 1)
                }, isAfter: function(input, units) {
                units = typeof units !== "undefined" ? units : "millisecond";
                        return + this.clone().startOf(units) > + moment(input).startOf(units)
                }, isBefore: function(input, units) {
                units = typeof units !== "undefined" ? units : "millisecond";
                        return + this.clone().startOf(units) < + moment(input).startOf(units)
                }, isSame: function(input, units) {
                units = typeof units !== "undefined" ? units : "millisecond";
                        return + this.clone().startOf(units) === + moment(input).startOf(units)
                }, zone: function() {
                return this._isUTC ? 0 : this._d.getTimezoneOffset()
                }, daysInMonth: function() {
                return moment.utc([this.year(), this.month() + 1, 0]).date()
                }, dayOfYear: function(input) {
                var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 86400000) + 1;
                        return input == null ? dayOfYear : this.add("d", (input - dayOfYear))
                }, isoWeek: function(input) {
                var week = weekOfYear(this, 1, 4);
                        return input == null ? week : this.add("d", (input - week) * 7)
                }, week: function(input) {
                var week = this.lang().week(this);
                        return input == null ? week : this.add("d", (input - week) * 7)
                }, lang: function(key) {
                if (key === undefined) {
                return this._lang
                } else {
                this._lang = getLangDefinition(key);
                        return this
                }
                }};
                function makeGetterAndSetter(name, key) {
                moment.fn[name] = moment.fn[name + "s"] = function(input) {
                var utc = this._isUTC ? "UTC" : "";
                        if (input != null) {
                this._d["set" + utc + key](input);
                        return this
                } else {
                return this._d["get" + utc + key]()
                }
                }
                }
        for (i = 0; i < proxyGettersAndSetters.length; i++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ""), proxyGettersAndSetters[i])
        }
        makeGetterAndSetter("year", "FullYear");
                moment.fn.days = moment.fn.day;
                moment.fn.weeks = moment.fn.week;
                moment.fn.isoWeeks = moment.fn.isoWeek;
                moment.duration.fn = Duration.prototype = {weeks: function() {
                return absRound(this.days() / 7)
                }, valueOf: function() {
                return this._milliseconds + this._days * 86400000 + this._months * 2592000000
                }, humanize: function(withSuffix) {
                var difference = + this, output = relativeTime(difference, !withSuffix, this.lang());
                        if (withSuffix) {
                output = this.lang().pastFuture(difference, output)
                }
                return this.lang().postformat(output)
                }, lang: moment.fn.lang};
                function makeDurationGetter(name) {
                moment.duration.fn[name] = function() {
                return this._data[name]
                }
                }
        function makeDurationAsGetter(name, factor) {
        moment.duration.fn["as" + name] = function() {
        return + this / factor
        }
        }
        for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
        makeDurationAsGetter(i, unitMillisecondFactors[i]);
                makeDurationGetter(i.toLowerCase())
        }
        }
        makeDurationAsGetter("Weeks", 604800000);
                moment.lang("en", {ordinal: function(number) {
                var b = number % 10, output = (~~(number % 100 / 10) === 1) ? "th" : (b === 1) ? "st" : (b === 2) ? "nd" : (b === 3) ? "rd" : "th";
                        return number + output
                }});
                if (hasModule) {
        module.exports = moment
        }
        if (typeof ender === "undefined") {
        this["moment"] = moment
        }
        if (typeof define === "function" && define.amd) {
        define("moment", [], function() {
        return moment
        })
        }
        }).call(this);
        var Base_Geometry;
        Base_Geometry = (function() {
        function Base_Geometry() {
        }
        Base_Geometry.closestPointToLine = function(x0, y0, x1, y1, x, y) {
        var dx, dy, lengthSqr, t;
                dx = x1 - x0;
                dy = y1 - y0;
                lengthSqr = dx * dx + dy * dy;
                if (lengthSqr > 0) {
        t = (((x - x0) * dx) + (y - y0) * dy) / lengthSqr;
                t = Math.min(Math.max(t, 0), 1)
        } else {
        t = 0
        }
        return[x0 + dx * t, y0 + dy * t]
        };
                Base_Geometry.rayIntersectsLine = function(rx, ry, rdx, rdy, lx, ly, lx1, ly1) {
                var coef, div, ldx, ldy, tl, tr;
                        coef = Infinity;
                        ldx = lx1 - lx;
                        ldy = ly1 - ly;
                        div = rdx * ldy - rdy * ldx;
                        if (div !== 0) {
                tr = (ry * ldx - rx * ldy + lx * ldy - ly * ldx) / div;
                        if (Math.abs(ldx) > Math.abs(ldy)) {
                tl = (rx + rdx * tr - lx) / ldx
                } else {
                tl = (ry + rdy * tr - ly) / ldy
                }
                if (tl >= 0 && tl <= 1 && tr >= 0) {
                coef = tr
                }
                }
                return coef
                };
                Base_Geometry.rayIntersectsCircle = function(rx, ry, rdx, rdy, r) {
                var a, b, c, coef, d, t0, t1;
                        a = rdx * rdx + rdy * rdy;
                        b = rx * rdx + ry * rdy;
                        c = rx * rx + ry * ry - r * r;
                        d = b * b - a * c;
                        coef = Infinity;
                        if (d > 0) {
                d = Math.sqrt(d);
                        t0 = ( - b - d) / a;
                        t1 = ( - b + d) / a;
                        if (t0 >= 0) {
                coef = t0
                }
                if (t1 >= 0) {
                coef = Math.min(coef, t1)
                }
                }
                return coef
                };
                Base_Geometry.rayIntersectsCircleOuter = function(rx, ry, rdx, rdy, r) {
                var a, b, c, d;
                        a = rdx * rdx + rdy * rdy;
                        b = rx * rdx + ry * rdy;
                        c = rx * rx + ry * ry - r * r;
                        d = b * b - a * c;
                        d = Math.sqrt(d);
                        return Math.max(( - b + d) / a, ( - b - d) / a)
                };
                Base_Geometry.lineTouchingCircle = function(rx, ry, xt, yt, r) {
                var a, angle, b, dx, dy, h, xx;
                        a = Math.sqrt(rx * rx + ry * ry);
                        if (!(a > r)) {
                return null
                }
                b = Math.sqrt(a * a - r * r);
                        h = r * b / a;
                        xx = r * r / a;
                        dx = rx / a;
                        dy = ry / a;
                        angle = rx * yt - ry * xt;
                        if (angle < 0) {
                h = - h
                }
                return[dx * xx - dy * h, dy * xx + dx * h]
                };
                return Base_Geometry
        })();
        var Base_Random;
        Base_Random = (function() {
        function Base_Random(seed) {
        this.seed = seed;
                this.A = 48271;
                this.M = 2147483647;
                this.Q = this.M / this.A;
                this.R = this.M % this.A;
                this.oneOverM = 1 / this.M
        }
        Base_Random.prototype.get = function() {
        var hi, lo, test;
                hi = this.seed / this.Q;
                lo = this.seed % this.Q;
                test = this.A * lo - this.R * hi;
                if (test > 0) {
        this.seed = test
        } else {
        this.seed = test + this.M
        }
        return this.seed * this.oneOverM
        };
                return Base_Random
        })();
        var Linearchart_DataLimitRenderer;
        Linearchart_DataLimitRenderer = (function() {
        function Linearchart_DataLimitRenderer(r) {
        this.r = r;
                this.scene = r.scene
        }
        Linearchart_DataLimitRenderer.prototype.paint = function(g, dataExistsFrom, dataExistsTo) {
        var dataLimitFrom, dataLimitTo, df, dt, from, height, to, width, x, x0, x1, y0, _ref;
                return;
                df = null;
                dt = null;
                if (this.bars != null) {
        df = this.bars.dataExistsFrom;
                dt = this.bars.dataExistsTo
        }
        from = this.scene.timeStart;
                to = this.scene.timeEnd;
                _ref = this.scene.getDataLimits(), dataLimitFrom = _ref[0], dataLimitTo = _ref[1];
                x0 = this.scene.x0;
                y0 = this.scene.y0;
                height = this.scene.height;
                x1 = x0 + this.scene.width;
                if (this.scene.settings.area.noData) {
        if (dataLimitFrom !== null && dataLimitFrom > from) {
        x = this.scene.timeToX(dataLimitFrom);
                this.paintFancyRect(g, x0, x1, - Infinity, x, y0, height, this.scene.settings.area.style.noData);
                x0 = x;
                from = dataLimitFrom
        }
        if (dataLimitTo !== null && dataLimitTo < to && x0 < x1) {
        x = this.scene.timeToX(dataLimitTo);
                this.paintFancyRect(g, x0, x1, x, Infinity, y0, height, this.scene.settings.area.style.noData);
                x1 = x;
                to = dataLimitTo
        }
        }
        width = x1 - x0;
                if (width <= 0) {
        return
        }
        if (dataExistsFrom === null || dataExistsTo === null) {
        this.paintFancyRect(g, x0, x1, x0, x1, y0, height, this.scene.settings.area.style.loadingData)
        } else {
        this.paintFancyRect(g, x0, x1, x0, this.scene.timeToX(dataExistsFrom), y0, height, this.scene.settings.area.style.loadingData);
                this.paintFancyRect(g, x0, x1, this.scene.timeToX(dataExistsTo), x1, y0, height, this.scene.settings.area.style.loadingData)
        }
        };
                Linearchart_DataLimitRenderer.prototype.paintFancyRect = function(g, clipX0, clipX1, x0, x1, y0, height, style) {
                var ih, image, iw, iww, ix, w, x, xx0, xx1, y;
                        if (x0 >= clipX1 || x1 <= clipX0) {
                return
                }
                xx0 = Math.max(x0, clipX0);
                        xx1 = Math.min(x1, clipX1);
                        g.beginPath();
                        g.rect(xx0, y0, xx1 - xx0, height);
                        Base_Graphics.paint(g, style);
                        if (style.image != null) {
                image = this.r.getImage(style.image);
                        if (image != null) {
                iw = image.width;
                        ih = image.height;
                        x = (xx0 + xx1) / 2;
                        y = y0 + (height - ih) / 2;
                        w = iw / 2 + 2;
                        if (x + w - 2 > x1) {
                x = x1 - iw - 2;
                        ix = xx0 - x;
                        if (((iw - ix) | 0) > 0 && (ix | 0) < (iw | 0)) {
                return g.drawImage(image, ix | 0, 0, (iw - ix) | 0, ih, (x + ix) | 0, y | 0, (iw - ix) | 0, ih | 0)
                }
                } else {
                if (x - w < x0) {
                x = x0 + 2;
                        iww = Math.min(xx1 - x, iw);
                        if ((iww | 0) > 0) {
                return g.drawImage(image, 0, 0, iww | 0, ih, x | 0, y | 0, iww | 0, ih | 0)
                }
                } else {
                return g.drawImage(image, (x - iw / 2) | 0, y | 0)
                }
                }
                }
                }
                };
                return Linearchart_DataLimitRenderer
        })();
        var Base_Label, Base_LabelLayoutBase;
        Base_Label = (function() {
        function Base_Label() {
        }
        Base_Label.prototype.text = null;
                Base_Label.prototype.lines = null;
                Base_Label.prototype.words = null;
                Base_Label.prototype.lineHeight = 0;
                Base_Label.prototype.align = "left";
                Base_Label.prototype.hwidth = 0;
                Base_Label.prototype.hheight = 0;
                Base_Label.prototype.x = null;
                Base_Label.prototype.y = null;
                Base_Label.prototype.angle = 0;
                Base_Label.prototype.visible = true;
                Base_Label.prototype.userPlaced = false;
                Base_Label.prototype.paint = function(g, x, y, style, backgroundStyle) {
                var hw, line, r, x0, xx, y0, _i, _len, _ref;
                        x0 = x + this.x;
                        y0 = y + this.y;
                        if (this.angle) {
                g.save();
                        g.translate(x0, y0);
                        g.rotate(this.angle);
                        x0 = 0;
                        y0 = 0
                }
                if (backgroundStyle) {
                g.beginPath();
                        r = this.hheight;
                        hw = this.hwidth;
                        xx = x0 + hw - r / 2;
                        g.moveTo(xx, y0 - r);
                        g.arc(xx, y0, r, - Math.PI / 2, Math.PI / 2, false);
                        xx = x0 - hw + r / 2;
                        g.lineTo(xx, y0 + r);
                        g.arc(xx, y0, r, Math.PI * 0.5, Math.PI * 1.5, false);
                        g.closePath();
                        Base_Graphics.paint(g, backgroundStyle)
                }
                g.textBaseline = "top";
                        y0 -= this.hheight;
                        if (this.align === "left") {
                x0 -= this.hwidth;
                        g.textAlign = "start"
                } else {
                if (this.align === "right") {
                x0 += this.hwidth;
                        g.textAlign = "end"
                } else {
                g.textAlign = "center"
                }
                }
                Base_Graphics.textStyle(g, style);
                        _ref = this.lines;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                line = _ref[_i];
                        g.fillText(line, x0, y0);
                        y0 += this.lineHeight
                }
                if (this.angle) {
                return g.restore()
                }
                };
                return Base_Label
        })();
        Base_LabelLayoutBase = (function() {
        function Base_LabelLayoutBase(g, config) {
        var height, lineSpacing;
                this.g = g;
                this.config = config;
                Base_Graphics.textStyle(g, config.textStyle);
                this.angle = config.angle / 180 * Math.PI;
                this.connectorLength = config.connectorLength;
                this.margin = config.margin;
                height = g.measureText("M").width * 1.25;
                this.interLabelSpacing = Math.max(this.config.interLabelSpacing * height, this.margin);
                lineSpacing = config.lineSpacing;
                this.lineHeightM = height * (lineSpacing + 1);
                this.lineHeightC = - height * lineSpacing
        }
        Base_LabelLayoutBase.prototype.fitLabelInRect = function(label, align, locationFromHeight, storePosition) {
        var actualWidth, availableWidth, bestActualWidth, bestDx, bestDy, bestLines, bestProp, bestWidth, bestX, bestY, centerOffset, dx, dy, g, height, line, line1, lineCount, lineHeightC, lineHeightM, lineTargetWidth, lineW, lineWidth, lines, margin, pos, prop, totalChars, totalWidth, word, words, x, y, _i, _j, _len, _ref, _ref1;
                if (storePosition == null) {
        storePosition = true
        }
        g = this.g;
                margin = this.margin;
                lineHeightC = this.lineHeightC;
                lineHeightM = this.lineHeightM;
                totalWidth = g.measureText(label.text).width;
                words = label.words;
                totalChars = 0;
                for (_i = 0, _len = words.length; _i < _len; _i++) {
        word = words[_i];
                totalChars += word.length + 1
        }
        bestProp = - 1;
                bestLines = null;
                bestX = 0;
                bestY = 0;
                bestWidth = 0;
                bestActualWidth = 0;
                for (lineCount = _j = 1, _ref = words.length; _j <= _ref; lineCount = _j += 1) {
        height = lineHeightC + lineHeightM * lineCount;
                _ref1 = locationFromHeight(height / 2 + margin), x = _ref1[0], y = _ref1[1], dx = _ref1[2], dy = _ref1[3], availableWidth = _ref1[4];
                availableWidth -= margin * 2;
                lineTargetWidth = totalWidth / lineCount;
                prop = 100;
                line = words[0];
                actualWidth = 0;
                lineWidth = g.measureText(line).width;
                lines = [];
                pos = 1;
                while (pos < words.length) {
        line1 = line + " " + words[pos];
                lineW = g.measureText(line1).width;
                if (lineW <= lineTargetWidth || lineW <= availableWidth || lines.length === lineCount - 1) {
        line = line1;
                lineWidth = lineW
        } else {
        lines.push(line);
                actualWidth = Math.max(actualWidth, lineWidth);
                prop = Math.min(prop, availableWidth / lineWidth);
                line = words[pos];
                lineWidth = g.measureText(line).width
        }
        pos++
        }
        lines.push(line);
                actualWidth = Math.max(actualWidth, lineWidth);
                prop = Math.min(prop, availableWidth / lineWidth);
                if (prop > bestProp) {
        bestLines = lines;
                bestProp = prop;
                bestDx = dx;
                bestDy = dy;
                bestX = x;
                bestY = y;
                bestWidth = availableWidth;
                bestActualWidth = actualWidth
        }
        if (prop >= 1) {
        break
        }
        }
        if (bestLines) {
        if (!label.userPlaced) {
        if (align === "left") {
        centerOffset = (bestActualWidth - bestWidth) / 2
        } else {
        if (align === "right") {
        centerOffset = (bestWidth - bestActualWidth) / 2
        } else {
        centerOffset = 0
        }
        }
        bestX = bestX + bestDx * centerOffset;
                bestY = bestY + bestDy * centerOffset
        }
        if (storePosition) {
        label.x = bestX;
                label.y = bestY
        }
        label.lines = bestLines;
                label.hheight = (lineHeightC + lineHeightM * bestLines.length) / 2;
                label.lineHeight = lineHeightM;
                label.hwidth = bestActualWidth / 2;
                label.visible = true
        } else {
        label.lines = [];
                label.visible = false
        }
        return bestProp
        };
                return Base_LabelLayoutBase
        })();
        var Piechart_View;
        Piechart_View = (function() {
        Piechart_View.prototype.animationPriority = 1007;
                function Piechart_View(chart) {
                this.chart = chart
                }
        Piechart_View.prototype.updatePie = function(pie) {
        return true
        };
                Piechart_View.prototype.scrollForward = function(pie, offset) {
                return true
                };
                Piechart_View.prototype.scrollBackward = function(pie, offset) {
                return false
                };
                Piechart_View.prototype.onSceneChange = function(event) {
                };
                Piechart_View.prototype.doAnimations = function(event) {
                };
                Piechart_View.prototype.paintScene = function(event) {
                };
                Piechart_View.prototype.getMovement = function(pie, event) {
                return[0, 0]
                };
                Piechart_View.prototype.findSliceAt = function(x, y, tolerance) {
                };
                Piechart_View.prototype.findPieAt = function(x, y, tolerance) {
                };
                Piechart_View.prototype.findLabelAt = function(x, y, tolerance) {
                };
                return Piechart_View
        })();
        var Piechart_Animations;
        Piechart_Animations = (function() {
        function Piechart_Animations(chart) {
        this.chart = chart;
                this.scene = chart.scene;
                this.events = chart.events;
                this.prevTime = 0
        }
        Piechart_Animations.prototype.doAnimations = function(event) {
        var a0Animator, a1Animator, c, c0, c1, c2, c3, cc, changedPies, cutoutAnimator, diff, dt, fadeDuration, fillAnimator, interactionDuration, lineAnimator, minRad, pie, pieChanges, piesToRemove, r0Animator, r1Animator, radiusChanges, removePie, slice, slicesToRemove, time, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
                if (this.prevTime) {
        dt = Math.min(30, event.time - this.prevTime)
        } else {
        dt = 0
        }
        fadeDuration = this.scene.settings.advanced.animationTime;
                interactionDuration = this.scene.settings.advanced.interactionTime;
                time = event.time;
                piesToRemove = [];
                changedPies = [];
                radiusChanges = false;
                if (this.scene.settings.pie.animateRadius) {
        if (!this.innerRadiusAnimator) {
        this.innerRadiusAnimator = new Base_Animator(0, this.scene.innerRadius, fadeDuration, "<>", time);
                this.radiusAnimator = new Base_Animator(0, this.scene.radius, fadeDuration, "<>", time)
        }
        _ref = this.radiusAnimator.updateAndGet(this.scene.radius, time), this.scene.currentRadius = _ref[0], c0 = _ref[1];
                _ref1 = this.innerRadiusAnimator.updateAndGet(this.scene.innerRadius, time), this.scene.currentInnerRadius = _ref1[0], c1 = _ref1[1];
                radiusChanges || (radiusChanges = c0 || c1);
                event.animating || (event.animating = radiusChanges)
        } else {
        if (this.scene.currentRadius !== this.scene.radius || this.scene.currentInnerRadius !== this.scene.innerRadius) {
        radiusChanges = true;
                this.scene.currentRadius = this.scene.radius;
                this.scene.currentInnerRadius = this.scene.innerRadius
        }
        }
        diff = this.scene.currentRadius - this.scene.currentInnerRadius;
                minRad = diff > 0 ? - this.scene.currentInnerRadius / diff : 0;
                _ref2 = this.scene.pies;
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        pie = _ref2[_i];
                pieChanges = false;
                if (event.changes.pie || event.changes.bounds) {
        pieChanges = true
        }
        removePie = false;
                if (pie.removed === true) {
        pie.removed = time + fadeDuration
        }
        if (pie.removed) {
        event.animating = true;
                removePie = pie.removed < time
        }
        if (!removePie) {
        if (!pie.animatorA0) {
        pie.animatorA0 = new Base_Animator(pie.currentStartAngle, pie.startAngle, fadeDuration, "<>", time);
                pie.animatorA1 = new Base_Animator(pie.currentEndAngle, pie.endAngle, fadeDuration, "<>", time);
                pie.animatorR0 = new Base_Animator(pie.currentInnerRadius, pie.innerRadius, fadeDuration, "<>", time);
                pie.animatorR1 = new Base_Animator(pie.currentRadius, pie.radius, fadeDuration, "<>", time);
                if (!this.scene.settings.area.initialAnimation) {
        pie.animatorA0.jump(pie.startAngle);
                pie.animatorA1.jump(pie.endAngle);
                pie.animatorR0.jump(pie.innerRadius);
                pie.animatorR1.jump(pie.radius)
        }
        }
        a0Animator = pie.animatorA0;
                a1Animator = pie.animatorA1;
                r0Animator = pie.animatorR0;
                r1Animator = pie.animatorR1;
                _ref3 = a0Animator.updateAndGet(pie.startAngle, time), pie.currentStartAngle = _ref3[0], c0 = _ref3[1];
                _ref4 = a1Animator.updateAndGet(pie.endAngle, time), pie.currentEndAngle = _ref4[0], c1 = _ref4[1];
                _ref5 = r1Animator.updateAndGet(pie.radius, time), pie.currentRadius = _ref5[0], c2 = _ref5[1];
                _ref6 = r0Animator.updateAndGet(pie.innerRadius, time), pie.currentInnerRadius = _ref6[0], c3 = _ref6[1];
                pie.currentRadius = Math.max(minRad, pie.currentRadius);
                pie.currentInnerRadius = Math.min(Math.max(minRad, pie.currentInnerRadius), pie.currentRadius);
                pieChanges || (pieChanges = c0 || c1 || c2 || c3);
                slicesToRemove = [];
                cc = false;
                _ref7 = pie.allSlices;
                for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
        slice = _ref7[_j];
                if (!slice.animatorF) {
        slice.animatorF = new Base_Animator(slice.currentFraction, slice.fraction, fadeDuration, "<>", time)
        }
        _ref8 = slice.animatorF.updateAndGetFixed(slice.fraction, time), slice.currentFraction = _ref8[0], c = _ref8[1];
                cc || (cc = c);
                if (slice.removed && slice.currentFraction === 0) {
        slicesToRemove.push(slice)
        }
        }
        pieChanges || (pieChanges = cc);
                if (slicesToRemove.length > 0) {
        pieChanges = true;
                for (_k = 0, _len2 = slicesToRemove.length; _k < _len2; _k++) {
        slice = slicesToRemove[_k];
                Base_Helpers.removeFromArray(pie.slices, slice);
                Base_Helpers.removeFromArray(pie.allSlices, slice);
                if (slice === pie.othersSlice) {
        pie.othersSlice = null
        }
        if (slice === pie.previousSlice) {
        pie.previousSlice = null
        }
        }
        }
        _ref9 = pie.allSlices;
                for (_l = 0, _len3 = _ref9.length; _l < _len3; _l++) {
        slice = _ref9[_l];
                if (!slice.animatorLineColor) {
        slice.animatorLineColor = new Base_Animator(slice.currentLineColor, slice.targetLineColor, interactionDuration, "<>", time);
                slice.animatorFillColor = new Base_Animator(slice.currentFillColor, slice.targetFillColor, interactionDuration, "<>", time);
                slice.animatorCutout = new Base_Animator(slice.currentCutoutDistance, slice.cutoutDistance, interactionDuration, "<>", time)
        }
        lineAnimator = slice.animatorLineColor;
                fillAnimator = slice.animatorFillColor;
                cutoutAnimator = slice.animatorCutout;
                _ref10 = lineAnimator.updateColorAndGet(slice.targetLineColor, time), slice.currentLineColor = _ref10[0], c0 = _ref10[1];
                _ref11 = fillAnimator.updateColorAndGet(slice.targetFillColor, time), slice.currentFillColor = _ref11[0], c1 = _ref11[1];
                if (!slice.userPlaced) {
        _ref12 = cutoutAnimator.updateAndGet(slice.cutoutDistance, time), slice.currentCutoutDistance = _ref12[0], c2 = _ref12[1]
        }
        pieChanges || (pieChanges = c0 || c1 || c2)
        }
        if (pieChanges || radiusChanges) {
        changedPies.push(pie)
        }
        event.animating || (event.animating = pieChanges)
        } else {
        piesToRemove.push(pie)
        }
        }
        for (_m = 0, _len4 = piesToRemove.length; _m < _len4; _m++) {
        pie = piesToRemove[_m];
                this.scene.deletePie(pie)
        }
        this.prevTime = time;
                return changedPies
        };
                return Piechart_Animations
        })();
        var Facetchart_FacetAxis;
        Facetchart_FacetAxis = (function() {
        function Facetchart_FacetAxis(chart, facet) {
        this.chart = chart;
                this.facet = facet;
                this.scene = this.chart.scene;
                this.options = this.scene.settings.facetAxis;
                this.currentItemWidth = 1;
                this.currentItemHeight = 1
        }
        Facetchart_FacetAxis.prototype.paint = function(event, boundsLeft, boundsWidth, xes) {
        var boundsRight, c0, c1, g, i, item, itemHeight, itemWidth, label, rebuildLabels, top, x0, _i, _len, _ref, _results;
                if (!(xes.length > 1 && this.options.enabled && this.options.size > 0)) {
        return
        }
        g = event.context;
                boundsRight = boundsLeft + boundsWidth;
                itemWidth = xes[1] - xes[0];
                top = this.scene.y0 + this.scene.height;
                itemHeight = this.options.size;
                if (this.options.labels.enabled) {
        rebuildLabels = false;
                if (Math.abs(1 - this.currentItemWidth / itemWidth) > 0.01 || Math.abs(1 - this.currentItemHeight / itemHeight) > 0.01) {
        this.currentItemWidth = itemWidth;
                this.currentItemHeight = itemHeight;
                rebuildLabels = true
        }
        if (event.changes.settings) {
        rebuildLabels = true
        }
        this.layout = new Base_LabelLayoutBase(g, this.options.labels);
                _ref = this.facet.items;
                _results = [];
                for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
                x0 = xes[i];
                if (item.label) {
        if (item.currentLabel === null || rebuildLabels || item.currentLabel.text !== item.label) {
        label = this.buildLabel(item.label, itemWidth, itemHeight);
                item.currentLabel = label
        } else {
        label = item.currentLabel
        }
        c0 = Math.max(x0 + 1, boundsLeft);
                c1 = Math.min(x0 + itemWidth - 2, boundsRight);
                Base_Graphics.pushClip(g, c0, top, c1 - c0, itemHeight);
                label.paint(g, x0, top, this.options);
                _results.push(Base_Graphics.popClip(g))
        } else {
        _results.push(item.currentLabel = null)
        }
        }
        return _results
        }
        };
                Facetchart_FacetAxis.prototype.buildLabel = function(text, availableWidth, availableHeight) {
                var align, angle, cosa, label, locationFromHeight, middleX, prop, sina;
                        label = new Base_Label();
                        label.text = text;
                        label.words = text.split(" ");
                        label.align = "left";
                        angle = label.angle = this.layout.angle;
                        if (angle > 0) {
                align = label.align = "left"
                } else {
                if (angle < 0) {
                align = label.align = "right"
                } else {
                align = label.align = "center"
                }
                }
                middleX = availableWidth / 2;
                        sina = Math.sin(angle);
                        cosa = Math.cos(angle);
                        locationFromHeight = function(halfHeight) {
                        var centerX, centerY, heightR, rotatedHeight, width;
                                rotatedHeight = halfHeight * cosa;
                                if (sina !== 0) {
                        heightR = availableHeight - 2 * halfHeight * cosa;
                                width = Math.max(0, heightR / Math.abs(sina))
                        } else {
                        if (halfHeight * 2 <= availableHeight) {
                        width = availableWidth
                        } else {
                        width = 0
                        }
                        }
                        if (angle > 0) {
                        centerX = middleX + width / 2 * cosa;
                                centerY = halfHeight * cosa + width / 2 * sina
                        } else {
                        if (angle < 0) {
                        centerX = middleX - width / 2 * cosa;
                                centerY = halfHeight * cosa - width / 2 * sina
                        } else {
                        centerX = middleX;
                                centerY = halfHeight
                        }
                        }
                        return[centerX, centerY, cosa, sina, width]
                        };
                        prop = this.layout.fitLabelInRect(label, align, locationFromHeight);
                        return label
                };
                return Facetchart_FacetAxis
        })();
        var Netchart_Layout_BHTree;
        Netchart_Layout_BHTree = (function() {
        var RepulsiveTreeNode, swap;
                RepulsiveTreeNode = (function() {
                function RepulsiveTreeNode() {
                }
                RepulsiveTreeNode.prototype.forceLinkList = null;
                        RepulsiveTreeNode.prototype.x = 0;
                        RepulsiveTreeNode.prototype.y = 0;
                        RepulsiveTreeNode.prototype.r = 0;
                        RepulsiveTreeNode.prototype.fx = 0;
                        RepulsiveTreeNode.prototype.fy = 0;
                        RepulsiveTreeNode.prototype.sizeEstimate = 0;
                        RepulsiveTreeNode.prototype.left = null;
                        RepulsiveTreeNode.prototype.right = null;
                        RepulsiveTreeNode.prototype.nodes = null;
                        return RepulsiveTreeNode
                })();
                Netchart_Layout_BHTree.prototype.maxLeafCount = 5;
                Netchart_Layout_BHTree.test = function() {
                var base, nodes, t;
                        t = new Netchart_Layout_BHTree();
                        t.maxLeafCount = 2;
                        t.temperature = 1;
                        nodes = [];
                        base = {z: 0, dx: 0, dy: 0, dz: 0, repulsiveForceX: 0, repulsiveForceY: 0, repulsiveForceZ: 0, fsum: 0};
                        nodes.push(Base_Helpers.extend({r: 5, x: 10, y: 10}, base));
                        nodes.push(Base_Helpers.extend({r: 5, x: 0, y: 0}, base));
                        nodes.push(Base_Helpers.extend({r: 5, x: 0, y: 10}, base));
                        nodes.push(Base_Helpers.extend({r: 5, x: 10, y: 0}, base));
                        nodes.push(Base_Helpers.extend({r: 5, x: 10, y: 10}, base));
                        nodes.push(Base_Helpers.extend({r: 5, x: 20, y: 0}, base));
                        nodes.push(Base_Helpers.extend({r: 5, x: 25, y: 0}, base));
                        return t.buildTree(nodes, nodes.length)
                };
                function Netchart_Layout_BHTree() {
                this.root = null;
                        this.freeNodeRoot = null;
                        this.temperature = 0;
                        this.nodeCount = 0
                }
        Netchart_Layout_BHTree.prototype.buildTree = function(nodeArray) {
        var count, i, _i, _ref;
                this.iters = 0;
                count = nodeArray.length;
                if (this.root != null) {
        this.freeNode(this.root)
        }
        this.root = this.newNode();
                if (count > 0) {
        this.buildTreeRecursive(nodeArray, 0, count, this.root)
        }
        for (i = _i = 0, _ref = count - 1; _i <= _ref; i = _i += 1) {
        nodeArray[i].repulsiveForceX = 0;
                nodeArray[i].repulsiveForceY = 0;
                nodeArray[i].repulsiveForceZ = 0
        }
        return this.calculateForces()
        };
                Netchart_Layout_BHTree.prototype.freeNode = function(node) {
                if (node.left != null) {
                this.freeNode(node.left)
                }
                if (node.right != null) {
                this.freeNode(node.right)
                }
                node.left = this.freeNodeRoot;
                        return this.freeNodeRoot = node
                };
                Netchart_Layout_BHTree.prototype.newNode = function() {
                var node;
                        if (this.freeNodeRoot != null) {
                node = this.freeNodeRoot;
                        this.freeNodeRoot = node.left;
                        node.left = null;
                        node.right = null;
                        node.leafCount = 0;
                        node.sizeEstimate = 0;
                        node.forceLinkList.length = 0
                } else {
                node = new RepulsiveTreeNode();
                        node.forceLinkList = [];
                        node.leaves = new Array(this.maxLeafCount)
                }
                node.repulsiveForceX = 0;
                        node.repulsiveForceY = 0;
                        node.repulsiveForceZ = 0;
                        return node
                };
                swap = function(arr, a, b) {
                var p;
                        p = arr[a];
                        arr[a] = arr[b];
                        return arr[b] = p
                };
                Netchart_Layout_BHTree.prototype.addForceLink = function(source, target) {
                return source.forceLinkList.push(target)
                };
                Netchart_Layout_BHTree.prototype.getMedianX = function(arr, low, high) {
                var hh, ll, median, middle, tmp;
                        high -= 1;
                        median = ((low + high) / 2) | 0;
                        while (true) {
                if (high <= low) {
                return median
                }
                if (high === low + 1) {
                if (arr[low].x > arr[high].x) {
                swap(arr, low, high);
                        return median
                }
                }
                middle = ((low + high) / 2) | 0;
                        if (arr[middle].x > arr[high].x) {
                swap(arr, middle, high)
                }
                if (arr[low].x > arr[high].x) {
                swap(arr, low, high)
                }
                if (arr[middle].x > arr[low].x) {
                swap(arr, middle, low)
                }
                swap(arr, middle, low + 1);
                        ll = low + 1;
                        hh = high;
                        while (true) {
                while (true) {
                ll += 1;
                        if (!(arr[low].x > arr[ll].x)) {
                break
                }
                }
                while (true) {
                hh -= 1;
                        if (!(arr[hh].x > arr[low].x)) {
                break
                }
                }
                if (hh < ll) {
                break
                }
                tmp = arr[ll];
                        arr[ll] = arr[hh];
                        arr[hh] = tmp
                }
                swap(arr, low, hh);
                        if (hh <= median) {
                low = ll
                }
                if (hh >= median) {
                high = hh - 1
                }
                }
                };
                Netchart_Layout_BHTree.prototype.getMedianY = function(arr, low, high) {
                var hh, ll, median, middle, tmp;
                        high -= 1;
                        median = ((low + high) / 2) | 0;
                        while (true) {
                if (high <= low) {
                return median
                }
                if (high === low + 1) {
                if (arr[low].y > arr[high].y) {
                swap(arr, low, high)
                }
                return median
                }
                middle = ((low + high) / 2) | 0;
                        if (arr[middle].y > arr[high].y) {
                swap(arr, middle, high)
                }
                if (arr[low].y > arr[high].y) {
                swap(arr, low, high)
                }
                if (arr[middle].y > arr[low].y) {
                swap(arr, middle, low)
                }
                swap(arr, middle, low + 1);
                        ll = low + 1;
                        hh = high;
                        while (true) {
                while (true) {
                ll += 1;
                        if (!(arr[low].y > arr[ll].y)) {
                break
                }
                }
                while (true) {
                hh -= 1;
                        if (!(arr[hh].y > arr[low].y)) {
                break
                }
                }
                if (hh < ll) {
                break
                }
                tmp = arr[ll];
                        arr[ll] = arr[hh];
                        arr[hh] = tmp
                }
                swap(arr, low, hh);
                        if (hh <= median) {
                low = ll
                }
                if (hh >= median) {
                high = hh - 1
                }
                }
                };
                Netchart_Layout_BHTree.prototype.buildTreeRecursive = function(nodeArray, start, end, subtree) {
                var child, count, i, invcnt, median, node, p, r, x, x1, x2, y, y1, y2, z, _i, _j, _ref, _ref1, _ref2;
                        x1 = x2 = nodeArray[start].x;
                        y1 = y2 = nodeArray[start].y;
                        for (i = _i = _ref = start + 1, _ref1 = end - 1; _i <= _ref1; i = _i += 1) {
                p = nodeArray[i];
                        x = p.x;
                        y = p.y;
                        if (x < x1) {
                x1 = x
                }
                if (x > x2) {
                x2 = x
                }
                if (y < y1) {
                y1 = y
                }
                if (y > y2) {
                y2 = y
                }
                }
                subtree.sizeEstimate = Math.max(x2 - x1, y2 - y1);
                        subtree.sizeEstimate = subtree.sizeEstimate * subtree.sizeEstimate + 0.1;
                        subtree.sizeEstimate *= 2;
                        count = end - start;
                        if (count <= this.maxLeafCount) {
                subtree.leafCount = count;
                        x = 0;
                        y = 0;
                        z = 0;
                        r = 0;
                        for (i = _j = 0, _ref2 = count - 1; _j <= _ref2; i = _j += 1) {
                node = nodeArray[i + start];
                        x += node.x;
                        y += node.y;
                        z += node.z;
                        r += node.r;
                        subtree.leaves[i] = node
                }
                invcnt = 1 / count;
                        subtree.r = r;
                        subtree.x = x * invcnt;
                        subtree.y = y * invcnt;
                        subtree.z = z * invcnt;
                        return
                }
                if (x2 - x1 > y2 - y1) {
                median = this.getMedianX(nodeArray, start, end)
                } else {
                median = this.getMedianY(nodeArray, start, end)
                }
                median++;
                        child = this.newNode();
                        subtree.left = child;
                        this.buildTreeRecursive(nodeArray, start, median, child);
                        child = this.newNode();
                        subtree.right = child;
                        this.buildTreeRecursive(nodeArray, median, end, child);
                        invcnt = 1 / count;
                        subtree.r = subtree.right.r + subtree.left.r;
                        subtree.x = (subtree.left.x * (median - start) + subtree.right.x * (end - median)) * invcnt;
                        subtree.y = (subtree.left.y * (median - start) + subtree.right.y * (end - median)) * invcnt;
                        return subtree.z = (subtree.left.z * (median - start) + subtree.right.z * (end - median)) * invcnt
                };
                Netchart_Layout_BHTree.prototype.calculateForces = function() {
                var factor, forceX, forceY, i, invr, k, node, node1, node2, queue, queueEnd, queueStart, _i, _j, _ref, _ref1, _ref2, _results;
                        queue = new Array(this.nodeCount);
                        queueStart = 0;
                        queueEnd = 0;
                        if (this.root.left !== null) {
                queue[queueEnd] = this.root.left;
                        queueEnd++;
                        queue[queueEnd] = this.root.right;
                        queueEnd++;
                        this.addForceLink(this.root.left, this.root.right)
                } else {
                queue[queueEnd] = this.root;
                        queueEnd++
                }
                _results = [];
                        while (queueStart < queueEnd) {
                node = queue[queueStart];
                        queueStart++;
                        invr = 1 / node.r;
                        if (node.left !== null) {
                this.processTreeNode(node, node.left);
                        this.processTreeNode(node, node.right);
                        queue[queueEnd] = node.left;
                        queueEnd++;
                        queue[queueEnd] = node.right;
                        queueEnd++;
                        factor = node.left.r * invr;
                        forceX = node.repulsiveForceX * factor;
                        forceY = node.repulsiveForceY * factor;
                        node.left.repulsiveForceX += forceX;
                        node.left.repulsiveForceY += forceY;
                        node.right.repulsiveForceX += node.repulsiveForceX - forceX;
                        node.right.repulsiveForceY += node.repulsiveForceY - forceY;
                        this.addForceLink(node.left, node.right)
                } else {
                for (i = _i = 0, _ref = node.leafCount - 1; _i <= _ref; i = _i += 1) {
                node1 = node.leaves[i];
                        this.processLeafNode(node, node1);
                        factor = node1.r * invr;
                        node1.repulsiveForceX += node.repulsiveForceX * factor;
                        node1.repulsiveForceY += node.repulsiveForceY * factor;
                        for (k = _j = _ref1 = i + 1, _ref2 = node.leafCount - 1; _j <= _ref2; k = _j += 1) {
                node2 = node.leaves[k];
                        this.forceBetweenParticles(node1, node2)
                }
                }
                }
                _results.push(node.forceLinkList.length = 0)
                }
                return _results
                };
                Netchart_Layout_BHTree.prototype.processTreeNode = function(node, subtree) {
                var fx, fy, i, len, length, otherNode, threshold, vx, vy, w, _i, _ref, _results;
                        length = node.forceLinkList.length;
                        _results = [];
                        for (i = _i = 0, _ref = length - 1; _i <= _ref; i = _i += 1) {
                otherNode = node.forceLinkList[i];
                        vx = subtree.x - otherNode.x;
                        vy = subtree.y - otherNode.y;
                        len = vx * vx + vy * vy;
                        threshold = subtree.sizeEstimate;
                        if (otherNode instanceof RepulsiveTreeNode) {
                threshold += otherNode.sizeEstimate
                }
                if (threshold < len) {
                w = subtree.r * otherNode.r / (len * Math.sqrt(len));
                        fx = vx * w;
                        subtree.repulsiveForceX += fx;
                        otherNode.repulsiveForceX -= fx;
                        fy = vy * w;
                        subtree.repulsiveForceY += fy;
                        _results.push(otherNode.repulsiveForceY -= fy)
                } else {
                if (otherNode instanceof RepulsiveTreeNode) {
                _results.push(this.addForceLink(otherNode, subtree))
                } else {
                _results.push(this.addForceLink(subtree, otherNode))
                }
                }
                }
                return _results
                };
                Netchart_Layout_BHTree.prototype.processLeafNode = function(node, subtree) {
                var fx, fy, len, otherNode, threshold, vx, vy, w, _i, _len, _ref, _results;
                        _ref = node.forceLinkList;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                otherNode = _ref[_i];
                        if (!(otherNode instanceof RepulsiveTreeNode)) {
                _results.push(this.forceBetweenParticles(subtree, otherNode))
                } else {
                vx = subtree.x - otherNode.x;
                        vy = subtree.y - otherNode.y;
                        len = vx * vx + vy * vy;
                        threshold = otherNode.sizeEstimate;
                        if (threshold < len) {
                w = subtree.r * otherNode.r / (len * Math.sqrt(len));
                        fx = vx * w;
                        subtree.repulsiveForceX += fx;
                        otherNode.repulsiveForceX -= fx;
                        fy = vy * w;
                        subtree.repulsiveForceY += fy;
                        _results.push(otherNode.repulsiveForceY -= fy)
                } else {
                _results.push(this.addForceLink(otherNode, subtree))
                }
                }
                }
                return _results
                };
                Netchart_Layout_BHTree.prototype.forceBetweenParticles = function(node1, node2) {
                var len1, r, vx1, vy1, vz1, w;
                        vx1 = node1.x - node2.x;
                        vy1 = node1.y - node2.y;
                        vz1 = node1.z - node2.z;
                        len1 = vx1 * vx1 + vy1 * vy1 + vz1 * vz1;
                        r = node1.r + node2.r;
                        if (len1 * this.temperature < r) {
                w = 0.25 * this.temperature * Math.sqrt(this.temperature * r)
                } else {
                w = 0.25 * r * r / (len1 * Math.sqrt(len1))
                }
                node1.repulsiveForceX += vx1 * w;
                        node2.repulsiveForceX -= vx1 * w;
                        node1.repulsiveForceY += vy1 * w;
                        node2.repulsiveForceY -= vy1 * w;
                        node1.repulsiveForceZ += vz1 * w;
                        return node2.repulsiveForceZ -= vz1 * w
                };
                return Netchart_Layout_BHTree
        })();
        var Netchart_Layout_GraphAdjacency;
        Netchart_Layout_GraphAdjacency = (function() {
        function Netchart_Layout_GraphAdjacency(nodes, edges) {
        var i, _i, _ref;
                this.edgecnt = 0;
                this.nodecnt = nodes;
                this.maxedges = edges;
                this.increment = edges + 1;
                this.nodestart = new Array(nodes);
                this.enodes = new Array(edges);
                this.next = new Array(edges);
                for (i = _i = 0, _ref = this.nodecnt - 1; _i <= _ref; i = _i += 1) {
        this.nodestart[i] = - 1
        }
        }
        Netchart_Layout_GraphAdjacency.prototype.addEdge = function(snode, enode) {
        if (this.edgecnt >= this.maxedges) {
        this.maxedges += this.increment;
                this.increment *= 2;
                this.next.length = this.maxedges;
                this.enodes.length = this.maxedges
        }
        this.enodes[this.edgecnt] = enode;
                this.next[this.edgecnt] = this.nodestart[snode];
                this.nodestart[snode] = this.edgecnt;
                return this.edgecnt++
        };
                Netchart_Layout_GraphAdjacency.prototype.addUndirectEdge = function(snode, enode) {
                this.addEdge(snode, enode);
                        return this.addEdge(enode, snode)
                };
                return Netchart_Layout_GraphAdjacency
        })();
        var Base_CssColorParser;
        Base_CssColorParser = (function() {
        function Base_CssColorParser() {
        }
        Base_CssColorParser.clamp_css_byte = function(i) {
        i = Math.round(i);
                if (i < 0) {
        return 0
        } else {
        if (i > 255) {
        return 255
        } else {
        return i
        }
        }
        };
                Base_CssColorParser.clamp_css_float = function(f) {
                if (f < 0) {
                return 0
                } else {
                if (f > 1) {
                return 1
                } else {
                return f
                }
                }
                };
                Base_CssColorParser.parse_css_int = function(str) {
                if (str[str.length - 1] === "%") {
                return Base_CssColorParser.clamp_css_byte(parseFloat(str) / 100 * 255)
                }
                return Base_CssColorParser.clamp_css_byte(parseInt(str))
                };
                Base_CssColorParser.parse_css_float = function(str) {
                if (str[str.length - 1] === "%") {
                return Base_CssColorParser.clamp_css_float(parseFloat(str) / 100)
                }
                return Base_CssColorParser.clamp_css_float(parseFloat(str))
                };
                Base_CssColorParser.css_hue_to_rgb = function(m1, m2, h) {
                if (h < 0) {
                h += 1
                } else {
                if (h > 1) {
                h -= 1
                }
                }
                if (h * 6 < 1) {
                return m1 + (m2 - m1) * h * 6
                }
                if (h * 2 < 1) {
                return m2
                }
                if (h * 3 < 2) {
                return m1 + (m2 - m1) * (2 / 3 - h) * 6
                }
                return m1
                };
                Base_CssColorParser.parseCSSColor = function(css_str) {
                var alpha, ep, fname, h, iv, l, m1, m2, op, params, s, str;
                        str = css_str.replace(RegExp(" ", "g"), "").toLowerCase();
                        if (str in Base_CssColorParser.kCSSColorTable) {
                return Base_CssColorParser.kCSSColorTable[str].slice()
                }
                if (str[0] === "#") {
                if (str.length === 4) {
                iv = parseInt(str.substr(1), 16);
                        if (!(iv >= 0 && iv <= 4095)) {
                return null
                }
                return[((iv & 3840) >> 4) | ((iv & 3840) >> 8), (iv & 240) | ((iv & 240) >> 4), (iv & 15) | ((iv & 15) << 4), 1]
                } else {
                if (str.length === 7) {
                iv = parseInt(str.substr(1), 16);
                        if (!(iv >= 0 && iv < 16777215)) {
                return null
                }
                return[(iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, 1]
                }
                }
                return null
                }
                op = str.indexOf("(");
                        ep = str.indexOf(")");
                        if (op !== - 1 && ep + 1 === str.length) {
                fname = str.substr(0, op);
                        params = str.substr(op + 1, ep - (op + 1)).split(",");
                        alpha = 1;
                        if (fname === "rgba") {
                if (params.length !== 4) {
                return null
                }
                alpha = Base_CssColorParser.parse_css_float(params.pop())
                }
                if (fname === "rgba" || fname === "rgb") {
                if (params.length !== 3) {
                return null
                }
                return[Base_CssColorParser.parse_css_int(params[0]), Base_CssColorParser.parse_css_int(params[1]), Base_CssColorParser.parse_css_int(params[2]), alpha]
                }
                if (fname === "hsla") {
                if (params.length !== 4) {
                return null
                }
                alpha = Base_CssColorParser.parse_css_float(params.pop())
                }
                if (fname === "hsla" || fname === "hsl") {
                if (params.length !== 3) {
                return null
                }
                h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;
                        s = parse_css_float(params[1]);
                        l = parse_css_float(params[2]);
                        m2 = (l <= 0.5 ? l * (s + 1) : l + s - l * s);
                        m1 = l * 2 - m2;
                        return[Base_CssColorParser.clamp_css_byte(Base_CssColorParser.css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), Base_CssColorParser.clamp_css_byte(Base_CssColorParser.css_hue_to_rgb(m1, m2, h) * 255), Base_CssColorParser.clamp_css_byte(Base_CssColorParser.css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha]
                }
                }
                return null
                };
                Base_CssColorParser.kCSSColorTable = {transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1]};
                return Base_CssColorParser
        })();
        var PieChart_Renderer_Base;
        PieChart_Renderer_Base = (function() {
        function PieChart_Renderer_Base(renderer) {
        this.renderer = renderer;
                this.settings = this.renderer.settings
        }
        PieChart_Renderer_Base.prototype.paintPie = function(context, x, y, r0, r1, a0, a1, pie) {
        if (pie.fillColor) {
        context.beginPath();
                context.arc(x, y, r1, a0, a1, false);
                context.arc(x, y, r0, a1, a0, true);
                context.closePath();
                return Base_Graphics.fill(context, pie)
        }
        };
                PieChart_Renderer_Base.prototype.paintSlices = function(context, x, y, radius, innerRadius, slices) {
                throw"paintSlices not implemented"
                };
                PieChart_Renderer_Base.prototype.paintExpandableHilights = function(context, piex, piey, slices) {
                var distance, oa0, oa1, params, r, r0, r1, slice, x, y, _i, _len, _results;
                        distance = this.settings.slice.expandableMarkStyle.distance;
                        _results = [];
                        for (_i = 0, _len = slices.length; _i < _len; _i++) {
                slice = slices[_i];
                        if (!slice.expandable) {
                continue
                }
                params = slice.renderParams;
                        x = piex + slice.x;
                        y = piey + slice.y;
                        r0 = params[0];
                        r1 = params[1];
                        r = Math.max((r0 + r1) / 2, r1 - distance);
                        oa0 = params[2];
                        oa1 = params[3];
                        context.beginPath();
                        context.arc(x, y, r, oa0, oa1);
                        _results.push(Base_Graphics.paint(context, this.settings.slice.expandableMarkStyle))
                }
                return _results
                };
                PieChart_Renderer_Base.prototype.strokeSlice = function(context, x, y, slice) {
                var ia0, ia1, oa0, oa1, offset, params, perimeter, r0, r1, width;
                        params = slice.renderParams;
                        context.beginPath();
                        x = x + slice.x;
                        y = y + slice.y;
                        r0 = params[0];
                        r1 = params[1];
                        oa0 = params[2];
                        oa1 = params[3];
                        ia0 = params[4];
                        ia1 = params[5];
                        perimeter = r1 * Math.abs(oa1 - oa0);
                        width = r1 - r0;
                        offset = Math.min(0.1 * Math.min(perimeter, width), 3);
                        if (slice.lineDecoration === "zigzag") {
                this.strokeZigZag(context, x, y, r1, offset, oa0, oa1)
                } else {
                context.arc(x, y, r1, oa0, oa1, false)
                }
                if (ia0 === ia1) {
                context.lineTo(x + Math.cos(ia0) * r0, y + Math.sin(ia0) * r0)
                } else {
                context.arc(x, y, r0, ia1, ia0, true)
                }
                return context.closePath()
                };
                PieChart_Renderer_Base.prototype.strokeZigZag = function(context, x, y, r, offset, a0, a1) {
                var a, da;
                        da = 5 / r;
                        a = a0;
                        context.moveTo(x + r * Math.cos(a0), y + r * Math.sin(a0));
                        while (a + da < a1) {
                a += da;
                        context.lineTo(x + (r + offset) * Math.cos(a), y + (r + offset) * Math.sin(a));
                        offset = - offset
                }
                return context.lineTo(x + r * Math.cos(a1), y + r * Math.sin(a1))
                };
                PieChart_Renderer_Base.prototype.strokeAndPaint = function(g, x, y, slice) {
                this.strokeSlice(g, x, y, slice);
                        return Base_Graphics.paint(g, slice)
                };
                return PieChart_Renderer_Base
        })();
        var Base_MonotoneCurve;
        Base_MonotoneCurve = (function() {
        function Base_MonotoneCurve(x, y) {
        var alpha, beta, delta, dist, i, m, n, tau, to_fix, _i, _j, _k, _l, _len, _len1, _m, _n, _ref, _ref1, _ref2, _ref3;
                n = x.length;
                delta = [];
                m = [];
                alpha = [];
                beta = [];
                dist = [];
                tau = [];
                for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        delta[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
                if (i > 0) {
        m[i] = (delta[i - 1] + delta[i]) / 2
        }
        }
        m[0] = delta[0];
                m[n - 1] = delta[n - 2];
                to_fix = [];
                for (i = _j = 0, _ref1 = n - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        if (delta[i] === 0) {
        to_fix.push(i)
        }
        }
        for (_k = 0, _len = to_fix.length; _k < _len; _k++) {
        i = to_fix[_k];
                m[i] = m[i + 1] = 0
        }
        for (i = _l = 0, _ref2 = n - 1; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
        alpha[i] = m[i] / delta[i];
                beta[i] = m[i + 1] / delta[i];
                dist[i] = Math.pow(alpha[i], 2) + Math.pow(beta[i], 2);
                tau[i] = 3 / Math.sqrt(dist[i])
        }
        to_fix = [];
                for (i = _m = 0, _ref3 = n - 1; 0 <= _ref3 ? _m < _ref3 : _m > _ref3; i = 0 <= _ref3 ? ++_m : --_m) {
        if (dist[i] > 9) {
        to_fix.push(i)
        }
        }
        for (_n = 0, _len1 = to_fix.length; _n < _len1; _n++) {
        i = to_fix[_n];
                m[i] = tau[i] * alpha[i] * delta[i];
                m[i + 1] = tau[i] * beta[i] * delta[i]
        }
        this.x = x;
                this.y = y;
                this.m = m
        }
        Base_MonotoneCurve.prototype.interpolate = function(x) {
        var h, h00, h01, h10, h11, i, t, t2, t3, y, _i, _ref;
                for (i = _i = _ref = this.x.length - 2; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        if (this.x[i] <= x) {
        break
        }
        }
        h = this.x[i + 1] - this.x[i];
                t = (x - this.x[i]) / h;
                t2 = Math.pow(t, 2);
                t3 = Math.pow(t, 3);
                h00 = 2 * t3 - 3 * t2 + 1;
                h10 = t3 - 2 * t2 + t;
                h01 = - 2 * t3 + 3 * t2;
                h11 = t3 - t2;
                y = h00 * this.y[i] + h10 * h * this.m[i] + h01 * this.y[i + 1] + h11 * h * this.m[i + 1];
                return y
        };
                return Base_MonotoneCurve
        })();
        var Base_Api;
        Base_Api = (function() {
        function Base_Api() {
        }
        Base_Api.themes = {};
                Base_Api.prototype.customize = function(name) {
                if (!this.themes.hasOwnProperty(name)) {
                throw"No customization named " + name
                }
                return this.updateSettings(this.themes[name])
                };
                Base_Api.prototype.saveState = function() {
                return this._impl.save()
                };
                Base_Api.prototype.restoreState = function(state, animate) {
                if (animate == null) {
                animate = false
                }
                return this._impl.restore(state, animate)
                };
                Base_Api.prototype.updateSettings = function(changes) {
                if (changes == null) {
                changes = {}
                }
                this._impl.updateSettings(changes, "api");
                        return this
                };
                Base_Api.prototype.on = function(name, listener) {
                return this._impl.on(name, listener)
                };
                Base_Api.prototype.off = function(name, listener) {
                return this._impl.off(name, listener)
                };
                Base_Api.prototype.updateSize = function() {
                this._impl.updateSize(true);
                        return this
                };
                Base_Api.prototype.reloadData = function() {
                return this._impl.reloadData()
                };
                Base_Api.prototype.addData = function(data, sourceId) {
                if (sourceId == null) {
                sourceId = "default"
                }
                return this._impl.addData(data, sourceId)
                };
                Base_Api.prototype.removeData = function(data, sourceId) {
                if (sourceId == null) {
                sourceId = "default"
                }
                return this._impl.removeData(data, sourceId)
                };
                Base_Api.prototype.replaceData = function(data, sourceId) {
                if (sourceId == null) {
                sourceId = "default"
                }
                return this._impl.replaceData(data, sourceId)
                };
                Base_Api.prototype.remove = function() {
                return this._impl.remove()
                };
                Base_Api.prototype.saveAsImage = function(type, dimensions, transparent) {
                return this._impl.events.exportToImage(type, dimensions, transparent)
                };
                Base_Api.prototype["export"] = function(type, dimensions, transparent) {
        return Base_Export["export"](this, {type: type, dimensions: dimensions, transparent: transparent})
        };
                Base_Api.prototype.exportGetDimensions = function(dimensions) {
                return this._impl.events.exportGetDimensions(dimensions)
                };
                Base_Api.prototype.addSubchartContainer = function(container) {
                return this._impl.layers.mouseTrackLayer.appendChild(container)
                };
                Base_Api.prototype.paintNow = function() {
                return this._impl.events.paintNow()
                };
                return Base_Api
        })();
        var Base_TimeStep;
        Base_TimeStep = (function() {
        Base_TimeStep.parsingMap = {milliseconds: "ms", millisecond: "ms", second: "s", seconds: "s", minute: "m", minutes: "m", hour: "h", hours: "h", day: "d", days: "d", week: "w", weeks: "w", month: "M", months: "M", year: "y", years: "y", ms: "ms", s: "s", m: "m", h: "h", d: "d", w: "w", M: "M", y: "y"};
                Base_TimeStep.knownUnits = ["ms", "s", "m", "h", "d", "w", "M", "y"];
                Base_TimeStep.isGoodUnit = function(unit) {
                return Base_TimeStep.parsingMap[unit] != null
                };
                Base_TimeStep.prototype.unit = "s";
                Base_TimeStep.prototype.count = 1;
                Base_TimeStep.prototype.name = null;
                function Base_TimeStep(unit, count) {
                this.unit = unit;
                        this.count = count;
                        this.name = "" + this.count + " " + this.unit
                }
        Base_TimeStep.parse = function(input) {
        var count, l, name, s, unit, unitText;
                if (input == null) {
        return null
        }
        if (input.unit != null) {
        name = input.name;
                unitText = input.unit
        } else {
        unitText = input;
                name = input
        }
        if (input.count != null) {
        count = input.count;
                unit = input.unit
        } else {
        l = unitText.split(" ");
                if (l.length === 2) {
        count = parseInt(l[0], 10);
                unit = l[1]
        } else {
        if (l.length === 1) {
        count = 1;
                unit = l[0]
        } else {
        return null
        }
        }
        }
        unit = Base_TimeStep.parsingMap[unit];
                if (typeof count !== "number" || !Base_TimeStep.isGoodUnit(unit)) {
        return null
        }
        s = new Base_TimeStep(unit, count);
                s.name = name;
                return s
        };
                Base_TimeStep.prototype.clone = function() {
                return new Base_TimeStep(this.unit, this.count)
                };
                Base_TimeStep.prototype.add = function(time, times) {
                if (times == null) {
                times = 1
                }
                return moment(time).utc().add(this.unit, this.count * times).valueOf()
                };
                Base_TimeStep.prototype.sub = function(time, times) {
                if (times == null) {
                times = 1
                }
                return moment(time).utc().subtract(this.unit, this.count * times).valueOf()
                };
                Base_TimeStep.prototype.numberOfUnits = function(from, to) {
                return Math.round(moment(to).utc().diff(from, Base_TimeStep.unitsTranslation[this.unit], true) / this.count)
                };
                Base_TimeStep.prototype.toString = function() {
                return"" + this.count + " " + this.unit
                };
                Base_TimeStep.timeUnitDiffs = {ms: 1, s: 1000, m: 60 * 1000, h: 60 * 60 * 1000, d: 24 * 60 * 60 * 1000, w: 7 * 24 * 60 * 60 * 1000, M: 30 * 24 * 60 * 60 * 1000, y: 365 * 24 * 60 * 60 * 1000};
                Base_TimeStep.unitsTranslation = {s: "second", m: "minute", h: "hour", d: "day", w: "week", M: "month", y: "year"};
                Base_TimeStep.toBiggerUnit = {ms: "s", s: "m", m: "h", h: "d", d: "w", w: "M", M: "y", y: null};
                Base_TimeStep.toSmallerUnit = {ms: null, s: "ms", m: "s", h: "m", d: "h", w: "d", M: "d", y: "M"};
                Base_TimeStep.prototype.approxTime = function() {
                return Base_TimeStep.timeUnitDiffs[this.unit] * this.count
                };
                Base_TimeStep.prototype.isSmallerOrEqual = function(bigger) {
                return this.approxTime() <= bigger.approxTime()
                };
                Base_TimeStep.prototype.isSmaller = function(bigger) {
                return this.approxTime() < bigger.approxTime()
                };
                Base_TimeStep.prototype.isBigger = function(smaller) {
                return this.approxTime() > smaller.approxTime()
                };
                Base_TimeStep.prototype.isEqual = function(step) {
                return this.approxTime() === step.approxTime()
                };
                Base_TimeStep.prototype.getBigger = function() {
                if (this.unit === "y") {
                return new Base_TimeStep(this.unit, this.count * 10)
                } else {
                return new Base_TimeStep(Base_TimeStep.toBiggerUnit[this.unit], 1)
                }
                };
                Base_TimeStep.prototype.roundTimeDown = function(t) {
                var times;
                        t = Math.round(t);
                        times = this.count;
                        if (this.unit === "ms") {
                Math.floor(t / times) * times
                }
                if (this.unit !== "ms") {
                t = moment(t).utc().startOf(Base_TimeStep.unitsTranslation[this.unit])
                }
                if (this.unit === "y") {
                t.year(Math.floor(t.year() / times) * times)
                } else {
                if (this.unit === "M") {
                t.month(Math.floor(t.month() / times) * times)
                } else {
                if (this.unit === "w") {
                t.week(Math.floor(t.week() / times) * times)
                } else {
                if (this.unit === "d") {
                t.date(Math.floor(t.date() / times) * times)
                } else {
                if (this.unit === "h") {
                t.hours(Math.floor(t.hours() / times) * times)
                } else {
                if (this.unit === "m") {
                t.minutes(Math.floor(t.minutes() / times) * times)
                } else {
                if (this.unit === "s") {
                t.seconds(Math.floor(t.seconds() / times) * times)
                }
                }
                }
                }
                }
                }
                }
                return t.valueOf()
                };
                Base_TimeStep.prototype.roundTimeUp = function(time) {
                return this.roundTimeDown(moment(Math.round(time)).utc().add(this.unit, this.count).valueOf() - 1)
                };
                Base_TimeStep.prototype.roundTimeRound = function(time) {
                var t;
                        t = moment(Math.round(time)).utc().add(this.unit, this.count);
                        return this.roundTimeDown((t.valueOf() + time - 1) / 2)
                };
                return Base_TimeStep
        })();
        var Netchart_Layout_TimedSpringEmbedder;
        Netchart_Layout_TimedSpringEmbedder = (function() {
        var SpringEdge, SpringNode;
                SpringEdge = (function() {
                function SpringEdge() {
                }
                SpringEdge.prototype.to = null;
                        SpringEdge.prototype.K = 0;
                        SpringEdge.prototype.len = 0;
                        SpringEdge.prototype.strength = 0;
                        return SpringEdge
                })();
                SpringNode = (function() {
                function SpringNode() {
                }
                SpringNode.prototype.x = 0;
                        SpringNode.prototype.y = 0;
                        SpringNode.prototype.z = 0;
                        SpringNode.prototype.r = 1;
                        SpringNode.prototype.zattr = 1;
                        SpringNode.prototype.repulsiveForceX = 0;
                        SpringNode.prototype.repulsiveForceY = 0;
                        SpringNode.prototype.repulsiveForceZ = 0;
                        SpringNode.prototype.fsum = 0;
                        SpringNode.prototype.edges = [];
                        return SpringNode
                })();
                Netchart_Layout_TimedSpringEmbedder.prototype.temperature = 0;
                Netchart_Layout_TimedSpringEmbedder.prototype.unitTemperature = 0;
                Netchart_Layout_TimedSpringEmbedder.prototype.randomLayoutRadius = 0;
                Netchart_Layout_TimedSpringEmbedder.prototype.repulsiveForceTree = null;
                Netchart_Layout_TimedSpringEmbedder.prototype.randomGenerator = null;
                Netchart_Layout_TimedSpringEmbedder.prototype.nodePermutation = null;
                Netchart_Layout_TimedSpringEmbedder.prototype.nodeRepulsionFactor = 15;
                Netchart_Layout_TimedSpringEmbedder.prototype.componentCenterFactor = 0.005;
                Netchart_Layout_TimedSpringEmbedder.prototype.linkForceFactor = 0.2;
                Netchart_Layout_TimedSpringEmbedder.prototype.zAxisAttraction = 1;
                Netchart_Layout_TimedSpringEmbedder.prototype.nodeDegreeModifier = 1.2;
                Netchart_Layout_TimedSpringEmbedder.prototype.forceReductionFactor = 1;
                Netchart_Layout_TimedSpringEmbedder.prototype.globalForceX = 0;
                Netchart_Layout_TimedSpringEmbedder.prototype.globalForceY = 0;
                Netchart_Layout_TimedSpringEmbedder.prototype.centerX = 0;
                Netchart_Layout_TimedSpringEmbedder.prototype.centerY = 0;
                Netchart_Layout_TimedSpringEmbedder.prototype.aspectRatio = null;
                function Netchart_Layout_TimedSpringEmbedder(random) {
                this.random = random;
                        this.nodeCount = 0;
                        this.nodes = [];
                        this.forceX = [];
                        this.forceY = [];
                        this.forceZ = [];
                        this.forceSum = [];
                        this.oldForceX = [];
                        this.oldForceY = [];
                        this.oldForceZ = [];
                        this.componentX = [];
                        this.componentY = [];
                        this.componentSum = [];
                        this.componentNodeCount = [];
                        this.nodePermutation = [];
                        this.nodesAspect = 1;
                        this.idToIndex = {};
                        this.repulsiveForceTree = new Netchart_Layout_BHTree()
                }
        Netchart_Layout_TimedSpringEmbedder.prototype.updateParams = function(spacing, nodeDegreeModifier, aspectRatio) {
        this.spacing = spacing;
                this.nodeDegreeModifier = nodeDegreeModifier;
                this.aspectRatio = aspectRatio
        };
                Netchart_Layout_TimedSpringEmbedder.prototype.updateGraph = function(nodes, links, topologyChanges) {
                var desiredLen, desiredStrength, e, from, fsum, id, idx, lenSum, length, lengthProp, link, n, nn, node, nodesAspect, nodesAspectCount, oldIdToIndex, oldIdx, oldNode, oldNodes, oldOldForceX, oldOldForceY, oldOldForceZ, radSum, relevantEdgeCount, spacing, strength, sum, to, ton, vis, w, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3;
                        topologyChanges |= nodes.length !== this.nodeCount;
                        if (topologyChanges) {
                oldNodes = this.nodes;
                        oldOldForceX = this.oldForceX;
                        oldOldForceY = this.oldForceY;
                        oldOldForceZ = this.oldForceZ;
                        oldIdToIndex = this.idToIndex;
                        this.nodeCount = nodes.length;
                        this.oldForceX = new Array(this.nodeCount);
                        this.oldForceY = new Array(this.nodeCount);
                        this.oldForceZ = new Array(this.nodeCount);
                        this.forceX = new Array(this.nodeCount);
                        this.forceY = new Array(this.nodeCount);
                        this.forceZ = new Array(this.nodeCount);
                        this.forceSum = new Array(this.nodeCount);
                        this.nodes = new Array(this.nodeCount);
                        this.idToIndex = {};
                        nodesAspect = 0;
                        nodesAspectCount = 0;
                        for (idx = _i = 0, _len = nodes.length; _i < _len; idx = ++_i) {
                n = nodes[idx];
                        id = n.id;
                        node = new SpringNode();
                        node.edges = [];
                        if (n.currentRadius > 0) {
                nodesAspect += n.currentRadius / n.currentHwidth;
                        nodesAspectCount += 1
                }
                this.idToIndex[id] = idx;
                        this.nodes[idx] = node;
                        if (oldIdToIndex.hasOwnProperty(id)) {
                oldIdx = oldIdToIndex[id];
                        oldNode = oldNodes[oldIdx];
                        node.z = oldNode.z;
                        this.oldForceX[idx] = oldOldForceX[oldIdx];
                        this.oldForceY[idx] = oldOldForceY[oldIdx];
                        this.oldForceZ[idx] = oldOldForceZ[oldIdx]
                } else {
                this.oldForceX[idx] = 0;
                        this.oldForceY[idx] = 0;
                        this.oldForceZ[idx] = 0
                }
                }
                this.nodePermutation = this.nodes.slice(0);
                        if (nodesAspectCount > 0) {
                this.nodesAspect = Math.max(0.3, nodesAspect / nodesAspectCount)
                } else {
                this.nodesAspect = 1
                }
                }
                for (idx = _j = 0, _len1 = nodes.length; _j < _len1; idx = ++_j) {
                n = nodes[idx];
                        nn = this.nodes[idx];
                        nn.x = n.x;
                        nn.y = n.y;
                        nn.r = Math.max(1, n.currentHwidth);
                        nn.minr = Math.max(1, (n.currentRadius + n.currentHwidth * 0.5) / 1.5);
                        nn.zattr = n.visibility;
                        nn.edges.length = 0;
                        nn.locked = n.locked;
                        this.forceX[idx] = 0;
                        this.forceY[idx] = 0;
                        this.forceZ[idx] = 0;
                        this.forceSum[idx] = 0
                }
                for (_k = 0, _len2 = links.length; _k < _len2; _k++) {
                link = links[_k];
                        strength = link.strength;
                        length = link.length;
                        vis = link.visibility;
                        from = this.nodes[this.idToIndex[link.from.id]];
                        to = this.nodes[this.idToIndex[link.to.id]];
                        if (!from || !to) {
                console.log("Layout: missing node for link: " + link.from.id + " " + link.to.id + ", topology = " + topologyChanges);
                        continue
                }
                if (from === to) {
                continue
                }
                from.edges.push({to: to, strength: strength, len: length, vis: vis});
                        to.edges.push({to: from, strength: strength, len: length, vis: vis})
                }
                if (topologyChanges) {
                this.computeComponents()
                }
                spacing = this.spacing / 2;
                        _ref = this.nodes;
                        for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
                n = _ref[_l];
                        sum = 0;
                        _ref1 = n.edges;
                        for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {
                e = _ref1[_m];
                        sum += e.to.edges.length * e.vis
                }
                w = Math.sqrt(sum);
                        n.r += spacing;
                        n.minr += spacing;
                        if (w > 4) {
                n.r += (w - 4) * n.r / 4 * this.nodeDegreeModifier;
                        n.minr += (w - 4) * n.minr / 4 * this.nodeDegreeModifier
                }
                }
                lenSum = 0;
                        radSum = 0;
                        relevantEdgeCount = 0;
                        _ref2 = this.nodes;
                        for (_n = 0, _len5 = _ref2.length; _n < _len5; _n++) {
                n = _ref2[_n];
                        fsum = 0;
                        _ref3 = n.edges;
                        for (_o = 0, _len6 = _ref3.length; _o < _len6; _o++) {
                e = _ref3[_o];
                        ton = e.to;
                        if (n.locked && ton.locked || (n === ton)) {
                continue
                }
                relevantEdgeCount++;
                        desiredLen = n.minr + ton.minr;
                        lengthProp = e.len;
                        desiredStrength = Math.min(20, e.strength);
                        e.len = Math.max(1, desiredLen * lengthProp);
                        e.K = desiredStrength * 30 / e.len;
                        fsum += e.K;
                        lenSum += e.len
                }
                n.fsum = fsum;
                        radSum += n.r * n.r
                }
                if (relevantEdgeCount > 0) {
                this.randomLayoutRadius = Math.max(1, lenSum / 10);
                        return this.unitTemperature = lenSum / relevantEdgeCount / 50
                } else {
                this.randomLayoutRadius = Math.max(1, Math.sqrt(radSum));
                        return this.unitTemperature = 1
                }
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.computeComponents = function() {
                var component, componentNodes, e, end, n2, node, queue, start, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
                        this.componentX = [];
                        this.componentY = [];
                        this.componentSum = [];
                        this.componentNodeCount = [];
                        queue = new Array(this.nodeCount);
                        _ref = this.nodes;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        node.component = - 1
                }
                component = 0;
                        _ref1 = this.nodes;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                node = _ref1[_j];
                        if (node.component >= 0) {
                continue
                }
                node.component = component;
                        componentNodes = 0;
                        start = 0;
                        end = 0;
                        queue[end] = node;
                        end += 1;
                        while (start < end) {
                node = queue[start];
                        start += 1;
                        componentNodes += 1;
                        _ref2 = node.edges;
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                e = _ref2[_k];
                        n2 = e.to;
                        if (n2.component === - 1) {
                n2.component = component;
                        queue[end] = n2;
                        end += 1
                }
                }
                }
                this.componentNodeCount.push(componentNodes);
                        this.componentX.push(0);
                        this.componentY.push(0);
                        this.componentSum.push(0);
                        component += 1
                }
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.updateComponents = function() {
                var i, node, _i, _j, _k, _len, _ref, _ref1, _ref2, _results;
                        for (i = _i = 0, _ref = this.componentNodeCount.length - 1; _i <= _ref; i = _i += 1) {
                this.componentX[i] = 0;
                        this.componentY[i] = 0;
                        this.componentSum[i] = 0
                }
                _ref1 = this.nodes;
                        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
                node = _ref1[_j];
                        i = node.component;
                        this.componentX[i] += node.x * node.r;
                        this.componentY[i] += node.y * node.r;
                        this.componentSum[i] += node.r
                }
                _results = [];
                        for (i = _k = 0, _ref2 = this.componentNodeCount.length - 1; _k <= _ref2; i = _k += 1) {
                this.componentX[i] /= this.componentSum[i];
                        _results.push(this.componentY[i] /= this.componentSum[i])
                }
                return _results
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.globalLayout = function(nodes, timeout, resetPositions) {
                var i1, iter, node, numberOfMovingNodes, step, t0, _i, _len, _ref;
                        if (this.nodeCount <= 0) {
                return
                }
                if (resetPositions) {
                if (this.nodeCount === 1) {
                nodes[0].x = nodes[0].y = 0;
                        return
                } else {
                this.initialRandomLayout()
                }
                }
                numberOfMovingNodes = 0;
                        _ref = this.nodes;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        if (!node.locked) {
                numberOfMovingNodes++
                }
                }
                step = Math.floor(Math.sqrt(numberOfMovingNodes) + 10);
                        iter = step * 2;
                        this.forceReductionFactor = 1;
                        this.temperature = (Math.sqrt(numberOfMovingNodes) * 2 + 20) * this.unitTemperature;
                        this.zAxisAttraction = 0.02;
                        t0 = new Date().getTime();
                        i1 = 3;
                        while (this.temperature > this.unitTemperature) {
                if ((iter--) <= 0) {
                iter = step * 3 / (i1++);
                        this.temperature = this.temperature / 1.5 - 0.5;
                        if (this.temperature < 20 * this.unitTemperature) {
                this.zAxisAttraction = this.zAxisAttraction * 1.5 + 0.02
                }
                }
                this.randomNodePermutation();
                        this.repulsiveForceTree.temperature = this.zAxisAttraction * 1.75;
                        this.repulsiveForceTree.buildTree(this.nodePermutation);
                        this.moveNodesGlobal();
                        if (this.aspectRatio) {
                this.updateAspectRatio(this.forceReductionFactor * 0.001)
                }
                if (new Date().getTime() > t0 + timeout) {
                break
                }
                }
                if (resetPositions) {
                this.centerNodes()
                }
                return this.storeNodes(nodes)
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.initialRandomLayout = function() {
                var R, coef, i, i1, n, perm, r, tmp, _i, _j, _k, _len, _ref, _ref1, _results;
                        n = this.nodeCount;
                        perm = new Array(n);
                        for (i = _i = 0, _ref = n - 1; _i <= _ref; i = _i += 1) {
                perm[i] = i
                }
                for (i = _j = 0; _j <= n; i = _j += 1) {
                i1 = Math.floor(this.random.get() * (n - i)) + i;
                        tmp = perm[i];
                        perm[i] = perm[i1];
                        perm[i1] = tmp
                }
                R = this.randomLayoutRadius;
                        coef = 2 * Math.PI / this.nodeCount;
                        _ref1 = this.nodes;
                        _results = [];
                        for (i = _k = 0, _len = _ref1.length; _k < _len; i = ++_k) {
                n = _ref1[i];
                        this.oldForceX[i] = 0;
                        this.oldForceY[i] = 0;
                        this.oldForceZ[i] = 0;
                        n.z = this.random.get() - 0.5;
                        if (!n.locked) {
                r = R + n.r;
                        n.x = r * Math.cos(perm[i] * coef);
                        _results.push(n.y = r * Math.sin(perm[i] * coef))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.timedLayout = function(nodes, time) {
                var iter, x, _i, _ref;
                        if (this.nodeCount <= 1) {
                return
                }
                iter = 0;
                        if (time < 0.1) {
                iter = 2;
                        this.forceReductionFactor = Math.min(this.forceReductionFactor, time * 10)
                } else {
                iter = Math.min(6, Math.round(2 + time * 10))
                }
                this.zAxisAttraction = this.nodeRepulsionFactor / 28;
                        this.temperature = this.unitTemperature;
                        for (x = _i = 0, _ref = iter - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
                this.randomNodePermutation();
                        this.applyAspect(1 / this.nodesAspect);
                        this.repulsiveForceTree.temperature = this.zAxisAttraction * 1.75;
                        this.repulsiveForceTree.buildTree(this.nodePermutation);
                        this.applyAspect(this.nodesAspect);
                        this.moveNodesIncremental();
                        if (this.aspectRatio) {
                this.updateAspectRatio(this.forceReductionFactor)
                }
                }
                return this.storeNodes(nodes)
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.moveNodesGlobal = function() {
                var forceFactor, fsum, fx, fy, fz, i, len, n1, randomness, _i, _ref, _results;
                        this.initIteration();
                        randomness = this.temperature * 0.5;
                        forceFactor = this.forceReductionFactor;
                        _results = [];
                        for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
                n1 = this.nodes[i];
                        if (n1.locked) {
                continue
                }
                this.calculateForce(i, 0.5);
                        this.oldForceX[i] = fx = this.forceX[i];
                        this.oldForceY[i] = fy = this.forceY[i];
                        this.oldForceZ[i] = fz = this.forceZ[i];
                        fsum = this.forceSum[i];
                        fx *= fsum;
                        fy *= fsum;
                        fz *= fsum;
                        len = fx * fx + fy * fy + fz * fz;
                        if (len < this.temperature * this.temperature && len > 0.001) {
                len = this.temperature / Math.sqrt(len);
                        fx *= len;
                        fy *= len;
                        fz *= len
                }
                n1.x += fx * forceFactor + (this.random.get() - 0.5) * randomness;
                        n1.y += fy * forceFactor + (this.random.get() - 0.5) * randomness;
                        _results.push(n1.z += fz * forceFactor + (this.random.get() - 0.5) * randomness)
                }
                return _results
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.moveNodesIncremental = function() {
                var cfx, cfy, curLen, dx, dy, dz, freezedNodes, fsum, i, len, n1, scal, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
                        this.initIteration();
                        for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
                if (!this.nodes[i].locked) {
                this.calculateForce(i, 0)
                }
                }
                scal = 0;
                        len = 0;
                        freezedNodes = new Array(this.nodeCount);
                        for (i = _j = 0, _ref1 = this.nodeCount - 1; _j <= _ref1; i = _j += 1) {
                if (this.nodes[i].locked) {
                continue
                }
                dx = this.forceX[i];
                        dy = this.forceY[i];
                        dz = this.forceZ[i];
                        fsum = this.forceSum[i];
                        curLen = dx * dx + dy * dy + dx * dx;
                        if (curLen * fsum * fsum > this.unitTemperature * this.unitTemperature * 0.05 * 0.05) {
                len += curLen;
                        scal += this.oldForceX[i] * dx + this.oldForceY[i] * dy + this.oldForceZ[i] * dz
                } else {
                freezedNodes[i] = true
                }
                }
                if (scal > 1e-7) {
                this.forceReductionFactor *= 1 + 0.4 / 1.618033989
                } else {
                if (scal < - 1e-7) {
                this.forceReductionFactor /= 1.4
                }
                }
                cfx = this.globalForceX / this.nodeCount;
                        cfy = this.globalForceY / this.nodeCount;
                        for (i = _k = 0, _ref2 = this.nodeCount - 1; _k <= _ref2; i = _k += 1) {
                this.forceX[i] += cfx;
                        this.forceY[i] += cfy
                }
                this.forceReductionFactor = Math.min(1, this.forceReductionFactor);
                        this.forceReductionFactor = Math.max(0.002, this.forceReductionFactor);
                        for (i = _l = 0, _ref3 = this.nodeCount - 1; _l <= _ref3; i = _l += 1) {
                n1 = this.nodes[i];
                        if (!n1.locked && !freezedNodes[i]) {
                fsum = this.forceSum[i] * this.forceReductionFactor;
                        n1.x += this.forceX[i] * fsum;
                        n1.y += this.forceY[i] * fsum;
                        n1.z += this.forceZ[i] * fsum
                }
                this.oldForceX[i] = this.forceX[i];
                        this.oldForceY[i] = this.forceY[i];
                        this.oldForceZ[i] = this.forceZ[i]
                }
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.initIteration = function() {
                var cx, cy, node, sum, _i, _len, _ref;
                        cx = 0;
                        cy = 0;
                        sum = 0;
                        _ref = this.nodes;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        sum += node.r;
                        cx += node.x * node.r;
                        cy += node.y * node.r
                }
                this.centerX = cx / sum;
                        this.centerY = cy / sum;
                        this.updateComponents();
                        this.globalForceX = 0;
                        return this.globalForceY = 0
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.applyAspect = function(aspect) {
                var node, _i, _len, _ref, _results;
                        _ref = this.nodes;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        _results.push(node.y *= aspect)
                }
                return _results
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.calculateForce = function(nnum, fractionOfOld) {
                var cdx, cdy, cfx, cfy, component, csize, dx, dy, dz, e, f, kz, len, n1, n2, vx, vy, vz, _i, _len, _ref;
                        n1 = this.nodes[nnum];
                        dx = this.oldForceX[nnum] * fractionOfOld;
                        dy = this.oldForceY[nnum] * fractionOfOld;
                        dz = this.oldForceZ[nnum] * fractionOfOld;
                        _ref = n1.edges;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                e = _ref[_i];
                        n2 = e.to;
                        vx = n1.x - n2.x;
                        vy = n1.y - n2.y;
                        vz = n1.z - n2.z;
                        len = Math.sqrt(vx * vx + vy * vy + vz * vz);
                        if (len < 0.01) {
                len = 0.01
                }
                f = (e.len - len) * e.K / len * this.linkForceFactor;
                        dx += f * vx;
                        dy += f * vy;
                        dz += f * vz
                }
                dx += n1.repulsiveForceX * this.nodeRepulsionFactor;
                        dy += n1.repulsiveForceY * this.nodeRepulsionFactor;
                        dz += n1.repulsiveForceZ * this.nodeRepulsionFactor;
                        kz = n1.zattr * this.zAxisAttraction;
                        dz -= n1.z * kz;
                        component = n1.component;
                        cdx = this.componentX[component] - this.centerX;
                        cdy = this.componentY[component] - this.centerY;
                        csize = Math.min(10, Math.sqrt(this.componentNodeCount[component]));
                        cfx = cdx * csize * this.componentCenterFactor;
                        cfy = cdy * csize * this.componentCenterFactor;
                        dx -= cfx;
                        dy -= cfy;
                        this.globalForceX += cfx;
                        this.globalForceY += cfy;
                        if (isNaN(dx)) {
                throw"Nan in layout"
                }
                this.forceX[nnum] = dx;
                        this.forceY[nnum] = dy;
                        this.forceZ[nnum] = dz;
                        return this.forceSum[nnum] = 1 / (n1.fsum + kz)
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.storeNodes = function(nodes) {
                var i, _i, _ref;
                        for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
                if (!this.nodes[i].locked) {
                nodes[i].x = this.nodes[i].x;
                        nodes[i].y = this.nodes[i].y
                }
                }
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.updateAspectRatio = function(fraction) {
                var curX, curY, cx, cy, i, incX, incY, invForce, n, newX, newY, node, ratio, scaleX, scaleY, side, sx, sy, x0, x1, y0, y1, _i, _j, _ref, _ref1, _results;
                        n = this.nodes;
                        x0 = x1 = n[0].x;
                        y0 = y1 = n[0].y;
                        for (i = _i = 1, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
                x0 = Math.min(x0, n[i].x);
                        x1 = Math.max(x1, n[i].x);
                        y0 = Math.min(y0, n[i].y);
                        y1 = Math.max(y1, n[i].y)
                }
                cx = (x0 + x1) / 2;
                        cy = (y0 + y1) / 2;
                        sx = x1 - x0;
                        sy = y1 - y0;
                        ratio = Math.sqrt(this.aspectRatio);
                        side = Math.sqrt(sx * sy);
                        scaleX = side * ratio / sx;
                        scaleY = side / ratio / sy;
                        scaleX = fraction * scaleX + (1 - fraction);
                        scaleY = fraction * scaleY + (1 - fraction);
                        incX = cx - cx * scaleX;
                        incY = cy - cy * scaleY;
                        invForce = 1 / this.forceReductionFactor;
                        _results = [];
                        for (i = _j = 0, _ref1 = this.nodeCount - 1; _j <= _ref1; i = _j += 1) {
                node = n[i];
                        curX = node.x;
                        curY = node.y;
                        node.x = newX = curX * scaleX + incX;
                        node.y = newY = curY * scaleY + incY;
                        this.forceX[i] += (newX - curX) * invForce;
                        _results.push(this.forceY[i] += (newY - curY) * invForce)
                }
                return _results
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.centerNodes = function() {
                var cx, cy, i, n, node, rr, x0, x1, y0, y1, _i, _j, _ref, _ref1, _results;
                        n = this.nodes;
                        x0 = x1 = n[0].x;
                        y0 = y1 = n[0].y;
                        for (i = _i = 1, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
                x0 = Math.min(x0, n[i].x);
                        x1 = Math.max(x1, n[i].x);
                        y0 = Math.min(y0, n[i].y);
                        y1 = Math.max(y1, n[i].y)
                }
                cx = (x0 + x1) / 2;
                        cy = (y0 + y1) / 2;
                        _results = [];
                        for (i = _j = 0, _ref1 = this.nodeCount - 1; _j <= _ref1; i = _j += 1) {
                node = n[i];
                        node.x -= cx;
                        node.y -= cy;
                        if (!node.locked) {
                rr = node.r * 0.3;
                        node.x += Math.random() * rr;
                        _results.push(node.y += Math.random() * rr)
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                Netchart_Layout_TimedSpringEmbedder.prototype.randomNodePermutation = function() {
                var i, i1, tmp, _i, _ref;
                        for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
                i1 = Math.floor(this.random.get() * (this.nodeCount - i)) + i;
                        tmp = this.nodePermutation[i];
                        this.nodePermutation[i] = this.nodePermutation[i1];
                        this.nodePermutation[i1] = tmp
                }
                };
                return Netchart_Layout_TimedSpringEmbedder
        })();
        var Base_Animator;
        Base_Animator = (function() {
        Base_Animator.prototype.formula = null;
                Base_Animator.prototype.startTime = null;
                Base_Animator.prototype.from = 0;
                Base_Animator.prototype.to = 0;
                Base_Animator.prototype.fromColor = null;
                Base_Animator.prototype.toColor = null;
                Base_Animator.prototype.t = 0;
                Base_Animator.prototype.startSpeed = 0;
                Base_Animator.prototype.easing_formulas = {"=": function(t) {
                return t
                }, "<>": function(t) {
                if (t < 0.5) {
                return 2 * t * t
                } else {
                return - 0.5 * ((t * 2 - 1) * (t * 2 - 3) - 1)
                }
                }, scroll: function(t) {
                return 1 - (1 - t) * (1 - t)
                }};
                function Base_Animator(from, to, duration, easing, startTime) {
                this.from = from;
                        this.to = to;
                        this.duration = duration;
                        if (easing == null) {
                easing = "<>"
                }
                if (this.from === void 0 || this.from === null) {
                this.from = this.to
                }
                this.startTime = startTime === void 0 ? new Date().getTime() : startTime;
                        this.x = this.from;
                        this.t = this.startTime;
                        if (!this.easing_formulas[easing]) {
                throw"Easing formula not defined: " + easing
                } else {
                this.formula = this.easing_formulas[easing]
                }
                }
        Base_Animator.prototype.jump = function(to) {
        this.to = to;
                this.from = to;
                this.x = to;
                return this.t = this.startTime = 0
        };
                Base_Animator.prototype.retarget = function(newTo, startTime) {
                startTime = startTime === void 0 ? new Date().getTime() : startTime;
                        if (this.finished(this.t)) {
                this.startSpeed = 0
                } else {
                this.startSpeed = this._getSpeed()
                }
                this.from = this.get(startTime);
                        this.to = newTo;
                        this.startTime = startTime;
                        return this
                };
                Base_Animator.prototype.retargetColor = function(newTo, startTime) {
                if (startTime === void 0) {
                startTime = this.t ? this.t : new Date().getTime()
                }
                this.startSpeed = 0;
                        this.from = this.x;
                        this.to = newTo;
                        this.fromColor = null;
                        this.toColor = null;
                        this.startTime = startTime;
                        return this
                };
                Base_Animator.prototype.switchCoordinates = function(trAdd, trMul) {
                this.from = this.from * trMul + trAdd;
                        this.x = this.x * trMul + trAdd;
                        this.to = this.to * trMul + trAdd;
                        return this.startSpeed = this.startSpeed * trMul
                };
                Base_Animator.prototype.updateAndGet = function(targetValue, time) {
                var changes;
                        changes = this.x !== targetValue;
                        if (targetValue !== this.to) {
                this.retarget(targetValue, time)
                }
                return[this.get(time), changes]
                };
                Base_Animator.prototype.updateAndGetFixed = function(targetValue, time) {
                var changes;
                        changes = this.x !== targetValue;
                        if (targetValue !== this.to) {
                this.startSpeed = 0;
                        this.startTime = time;
                        this.from = this.x;
                        this.to = targetValue;
                        this.fromColor = null;
                        this.toColor = null
                }
                return[this.get(time), changes]
                };
                Base_Animator.prototype.updateColorAndGet = function(targetValue, time) {
                var changes;
                        changes = this.x !== targetValue;
                        if (targetValue !== this.to) {
                this.retargetColor(targetValue, time)
                }
                return[this.getColor(time), changes]
                };
                Base_Animator.prototype.get = function(time) {
                var easingPerc, percentage, spx, xx;
                        if (this.duration <= 0) {
                this.t = time;
                        this.x = this.to;
                        return this.to
                }
                percentage = Math.min(1, Math.max(time - this.startTime, 0) / this.duration);
                        if (percentage >= 1) {
                this.t = time;
                        this.x = this.to;
                        return this.to
                }
                easingPerc = this.formula(percentage);
                        xx = easingPerc * (this.to - this.from);
                        if (this.startSpeed && percentage < 1) {
                spx = this.startSpeed * percentage * this.duration;
                        xx = xx * easingPerc + spx * (1 - easingPerc)
                }
                xx = this.from + xx;
                        this.t = time;
                        this.x = xx;
                        return xx
                };
                Base_Animator.prototype.getColor = function(time) {
                var fa, fb, fg, fr, p0, p1, percentage, ta, tb, tg, tr, xx, _ref, _ref1;
                        this.t = time;
                        if (this.duration <= 0 || this.from === this.to) {
                return this.to
                }
                if (this.fromColor == null) {
                this.fromColor = Base_CssColorParser.parseCSSColor(this.from)
                }
                if (this.toColor == null) {
                this.toColor = Base_CssColorParser.parseCSSColor(this.to)
                }
                percentage = Math.min(1, Math.max(time - this.startTime, 0) / this.duration);
                        p1 = this.formula(percentage);
                        p0 = 1 - p1;
                        _ref = this.fromColor, fr = _ref[0], fg = _ref[1], fb = _ref[2], fa = _ref[3];
                        _ref1 = this.toColor, tr = _ref1[0], tg = _ref1[1], tb = _ref1[2], ta = _ref1[3];
                        xx = "rgba(" + (Math.round(fr * p0 + tr * p1)) + "," + (Math.round(fg * p0 + tg * p1)) + "," + (Math.round(fb * p0 + tb * p1)) + "," + ((fa * p0 + ta * p1).toFixed(3)) + ")";
                        this.t = time;
                        this.x = xx;
                        return xx
                };
                Base_Animator.prototype.finished = function(time) {
                return time >= this.startTime + this.duration
                };
                Base_Animator.prototype._getSpeed = function() {
                var d, p0, p1, time;
                        time = this.t;
                        d = this.duration / 1000;
                        p0 = this.get(time - d / 2);
                        p1 = this.get(time + d / 2);
                        this.t = time;
                        return(p1 - p0) / d
                };
                return Base_Animator
        })();
        var Base_Graphics;
        Base_Graphics = (function() {
        function Base_Graphics() {
        }
        Base_Graphics.stroke = function(g, st) {
        if (st.lineWidth) {
        g.lineWidth = st.lineWidth
        }
        g.strokeStyle = st.lineColor;
                g.stroke();
                if (st.lineWidth) {
        return g.lineWidth = 1
        }
        };
                Base_Graphics.fill = function(g, st) {
                if (!st.fillColor) {
                return
                }
                g.fillStyle = st.fillColor;
                        if (st.shadowColor) {
                g.shadowOffsetX = st.shadowOffsetX;
                        g.shadowOffsetY = st.shadowOffsetY;
                        g.shadowBlur = st.shadowBlur;
                        g.shadowColor = st.shadowColor
                }
                g.fill();
                        if (st.shadowColor) {
                g.shadowBlur = 0;
                        return g.shadowColor = null
                }
                };
                Base_Graphics.fillGradient = function(g, st, x0, y0, x1, y1) {
                var grad, s, step, _i, _len, _ref;
                        if (st.fillGradient) {
                grad = g.createLinearGradient(x0, y0, x1, y1);
                        _ref = st.fillGradient;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                step = _ref[_i];
                        grad.addColorStop(step[0], step[1])
                }
                s = st.fillColor;
                        st.fillColor = grad;
                        this.fill(g, st);
                        return st.fillColor = s
                } else {
                return this.fill(g, st)
                }
                };
                Base_Graphics.paint = function(g, st) {
                if (st.shadowColor) {
                g.shadowOffsetX = st.shadowOffsetX;
                        g.shadowOffsetY = st.shadowOffsetY;
                        g.shadowBlur = st.shadowBlur;
                        g.shadowColor = st.shadowColor
                }
                if (st.lineColor) {
                g.lineWidth = st.lineWidth ? st.lineWidth : 1;
                        g.strokeStyle = st.lineColor;
                        g.stroke()
                }
                if (st.fillColor) {
                g.fillStyle = st.fillColor;
                        g.fill()
                }
                if (st.shadowColor) {
                g.shadowOffsetX = 0;
                        g.shadowOffsetY = 0;
                        g.shadowBlur = 0;
                        return g.shadowColor = null
                }
                };
                Base_Graphics.textStyle = function(g, st) {
                if (st.fillColor) {
                g.fillStyle = st.fillColor
                }
                if (st.font) {
                g.font = st.font
                }
                if (st.shadowColor) {
                g.shadowOffsetX = st.shadowOffsetX;
                        g.shadowOffsetY = st.shadowOffsetY;
                        g.shadowBlur = st.shadowBlur;
                        return g.shadowColor = st.shadowColor
                }
                };
                Base_Graphics.rectStyle = function(g, st) {
                if (st.hasOwnProperty("lineColor")) {
                g.strokeStyle = st.lineColor
                }
                if (st.hasOwnProperty("fillColor")) {
                return g.fillStyle = st.fillColor
                }
                };
                Base_Graphics.pushClip = function(g, x, y, w, h) {
                g.save();
                        g.beginPath();
                        g.rect(x, y, w, h);
                        return g.clip()
                };
                Base_Graphics.popClip = function(g) {
                return g.restore()
                };
                Base_Graphics.arcBetweenTwoPoints = function(g, x, y, r, x0, y0, x1, y1) {
                var a1, a2, counterclockwise, d, d1, d2, len, lenSq, mx, my, px, py, xa, xb, ya, yb;
                        mx = (x0 + x1) / 2;
                        my = (y0 + y1) / 2;
                        px = y1 - y0;
                        py = x0 - x1;
                        lenSq = px * px + py * py;
                        if (lenSq === 0) {
                return
                }
                len = Math.sqrt(lenSq);
                        r = Math.min(Math.max(r, len / 2), len * 3);
                        d = Math.sqrt(r * r / lenSq - 0.25);
                        xa = mx + px * d;
                        ya = my + py * d;
                        xb = mx - px * d;
                        yb = my - py * d;
                        d1 = (xa - x) * (xa - x) + (ya - y) * (ya - y);
                        d2 = (xb - x) * (xb - x) + (yb - y) * (yb - y);
                        if (d1 > d2) {
                x = xb;
                        y = yb
                } else {
                x = xa;
                        y = ya
                }
                a1 = Math.atan2(y0 - y, x0 - x);
                        a2 = Math.atan2(y1 - y, x1 - x);
                        if (a2 < a1) {
                a2 += Math.PI * 2
                }
                counterclockwise = Math.abs(a1 - a2) > Math.PI;
                        return g.arc(x, y, r, a1, a2, counterclockwise)
                };
                Base_Graphics.strokeMarker = function(g, shape, x, y, r) {
                var d2;
                        d2 = r * 1.41421356237;
                        if (shape === "rect") {
                g.moveTo(x - r, y - r);
                        g.lineTo(x + r, y - r);
                        g.lineTo(x + r, y + r);
                        g.lineTo(x - r, y + r);
                        return g.closePath()
                } else {
                if (shape === "romb") {
                g.moveTo(x - d2, y);
                        g.lineTo(x, y - d2);
                        g.lineTo(x + d2, y);
                        g.lineTo(x, y + d2);
                        g.closePath();
                        return g.fill()
                } else {
                if (shape === "triangle") {
                g.beginPath();
                        g.moveTo(x - d2, y + d2);
                        g.lineTo(x + d2, y + d2);
                        g.lineTo(x, y - d2);
                        g.closePath();
                        return g.fill()
                } else {
                if (shape === "triangle2") {
                g.beginPath();
                        g.moveTo(x - d2, y - d2);
                        g.lineTo(x + d2, y - d2);
                        g.lineTo(x, y + d2);
                        g.closePath();
                        return g.fill()
                } else {
                if (shape === "circle") {
                g.beginPath();
                        g.arc(x, y, r, 0, Math.PI * 2, true);
                        return g.closePath()
                } else {
                throw"unknown marker shape " + shape
                }
                }
                }
                }
                }
                };
                Base_Graphics.strokeBalloon = function(g, x0, y0, w, h) {
                var m, r, s, x, y;
                        w = Math.max(w, h * 2);
                        m = 5;
                        s = 4;
                        r = (h + s * 2) / 2;
                        x = x0;
                        y = y0;
                        g.moveTo(x, y);
                        x += m;
                        y += m;
                        g.lineTo(x, y);
                        x += w / 2 - s - m;
                        g.lineTo(x, y);
                        g.arc(x, y + r, r, - Math.PI / 2, Math.PI / 2);
                        y += r * 2;
                        x -= w - 2 * s;
                        g.lineTo(x, y);
                        g.arc(x, y - r, r, Math.PI * 0.5, Math.PI * 1.5);
                        y -= r * 2;
                        x += w / 2 - s - m;
                        g.lineTo(x, y);
                        x += m;
                        y -= m;
                        g.closePath();
                        return y0 + m + r
                };
                Base_Graphics.strokeBalloon2 = function(g, x0, y0, w, h) {
                var r, s, x, y;
                        s = 4;
                        r = (h + s * 2) / 2;
                        w = Math.max(w, h * 2) / 2 - s;
                        x = x0 + w;
                        y = y0 - r;
                        g.moveTo(x, y);
                        g.arc(x, y + r, r, - Math.PI / 2, Math.PI / 2, false);
                        y += r * 2;
                        x -= w * 2;
                        g.lineTo(x, y);
                        g.arc(x, y - r, r, Math.PI * 0.5, Math.PI * 1.5, false);
                        return g.closePath()
                };
                Base_Graphics.applyColorToImage = function(image, color, ignoreTransparent) {
                var a, b, c, cData, data, g, gr, h, i, r, w, _i, _j, _ref, _ref1, _ref2;
                        if (ignoreTransparent == null) {
                ignoreTransparent = true
                }
                _ref = Base_Graphics.parseColor(color), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
                        c = document.createElement("canvas");
                        w = c.width = image.width;
                        h = c.height = image.height;
                        gr = c.getContext("2d");
                        gr.drawImage(image, 0, 0);
                        cData = gr.getImageData(0, 0, w, h);
                        data = cData.data;
                        if (ignoreTransparent) {
                for (i = _i = 0, _ref1 = data.length; _i <= _ref1; i = _i += 4) {
                if (data[i + 3] !== 255) {
                continue
                }
                data[i] = (data[i] * r) >> 8;
                        data[i + 1] = (data[i + 1] * g) >> 8;
                        data[i + 2] = (data[i + 2] * b) >> 8
                }
                } else {
                for (i = _j = 0, _ref2 = data.length; _j <= _ref2; i = _j += 4) {
                data[i] = (data[i] * r) >> 8;
                        data[i + 1] = (data[i + 1] * g) >> 8;
                        data[i + 2] = (data[i + 2] * b) >> 8
                }
                }
                gr.putImageData(cData, 0, 0);
                        return c.toDataURL("image/png")
                };
                Base_Graphics.cropImageToCircle = function(image) {
                var canvas, g, old, size;
                        size = Math.min(image.width, image.height);
                        canvas = document.createElement("canvas");
                        canvas.width = size;
                        canvas.height = size;
                        g = canvas.getContext("2d");
                        g.drawImage(image, 0, 0, image.width, image.height, 0, 0, size, size);
                        old = g.globalCompositeOperation;
                        g.globalCompositeOperation = "xor";
                        g.fillStyle = "rgba(0,0,0,1)";
                        g.beginPath();
                        g.rect(0, 0, size, size);
                        g.moveTo(size, size / 2);
                        g.arc(size / 2, size / 2, size / 2, 0, - Math.PI * 2, true);
                        g.fill();
                        g.globalCompositeOperation = old;
                        return canvas.toDataURL("image/png")
                };
                Base_Graphics.parseColor = function(color) {
                return Base_CssColorParser.parseCSSColor(color)
                };
                Base_Graphics.normalizeColor = function(color) {
                var a, b, g, r, _ref;
                        _ref = Base_CssColorParser.parseCSSColor(color), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
                        return"rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")"
                };
                Base_Graphics.deriveColor = function(color, lighten, opacity) {
                var a, b, g, r, _ref;
                        _ref = Base_Graphics.parseColor(color), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
                        return this.deriveColorRGBA(r, g, b, a, lighten, opacity)
                };
                Base_Graphics.deriveColorRGBA = function(r, g, b, a, lighten, opacity) {
                var light;
                        light = (lighten - 1) * 255;
                        r = Math.round(Math.min(255, Math.max(0, r + light)));
                        g = Math.round(Math.min(255, Math.max(0, g + light)));
                        b = Math.round(Math.min(255, Math.max(0, b + light)));
                        a = Math.min(1, a * opacity);
                        return"rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")"
                };
                Base_Graphics.blendColors = function(c0, c1, proportion) {
                var a, a0, a1, b, b0, b1, g, g0, g1, r, r0, r1, _ref, _ref1;
                        _ref = Base_Graphics.parseColor(c0), r0 = _ref[0], g0 = _ref[1], b0 = _ref[2], a0 = _ref[3];
                        _ref1 = Base_Graphics.parseColor(c1), r1 = _ref1[0], g1 = _ref1[1], b1 = _ref1[2], a1 = _ref1[3];
                        r = Math.round(r1 * proportion + r0 * (1 - proportion));
                        g = Math.round(g1 * proportion + g0 * (1 - proportion));
                        b = Math.round(b1 * proportion + b0 * (1 - proportion));
                        a = a1 * proportion + a0 * (1 - proportion);
                        return"rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")"
                };
                Base_Graphics.copyHue = function(hue, brightness) {
                var a, a0, a1, b, b0, b1, br0, br1, g, g0, g1, r, r0, r1, _ref, _ref1;
                        _ref = Base_Graphics.parseColor(hue), r0 = _ref[0], g0 = _ref[1], b0 = _ref[2], a0 = _ref[3];
                        _ref1 = Base_Graphics.parseColor(brightness), r1 = _ref1[0], g1 = _ref1[1], b1 = _ref1[2], a1 = _ref1[3];
                        br0 = (r0 + g0 + b0) / 765;
                        br1 = (r1 + g1 + b1) / 765;
                        r = Math.round(r0 / br0 * br1);
                        g = Math.round(g0 / br0 * br1);
                        b = Math.round(b0 / br0 * br1);
                        a = a1;
                        return"rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")"
                };
                Base_Graphics.inverseColor = function(c0) {
                var a, b, g, r, _ref;
                        _ref = Base_Graphics.parseColor(c0), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
                        r = 255 - r;
                        g = 255 - g;
                        b = 255 - b;
                        return"rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")"
                };
                Base_Graphics.applyShadow = function(g, style) {
                if (style.shadowColor) {
                g.shadowOffsetX = style.shadowOffsetX;
                        g.shadowOffsetY = style.shadowOffsetY;
                        g.shadowBlur = style.shadowBlur;
                        return g.shadowColor = style.shadowColor
                }
                };
                Base_Graphics.clearShadow = function(g) {
                g.shadowOffsetX = 0;
                        g.shadowOffsetY = 0;
                        g.shadowBlur = 0;
                        return g.shadowColor = ""
                };
                return Base_Graphics
        })();
        var Base_Marker, Base_MarkerRenderer;
        Base_Marker = (function() {
        function Base_Marker() {
        }
        Base_Marker.prototype.data = null;
                Base_Marker.prototype.aspectRatio = 3;
                Base_Marker.prototype.align = "left";
                Base_Marker.prototype.text = null;
                Base_Marker.prototype.image = null;
                Base_Marker.prototype.backgroundStyle = null;
                Base_Marker.prototype.textStyle = null;
                Base_Marker.prototype.imageSlicing = null;
                Base_Marker.prototype.onClick = null;
                Base_Marker.prototype.onHover = null;
                Base_Marker.prototype.url = null;
                Base_Marker.prototype.measureDone = false;
                Base_Marker.prototype.loadedImage = null;
                Base_Marker.prototype.lines = null;
                Base_Marker.prototype.lineHeight = 0;
                Base_Marker.prototype.hwidth = 0;
                Base_Marker.prototype.hheight = 0;
                Base_Marker.prototype.x = null;
                Base_Marker.prototype.y = null;
                return Base_Marker
        })();
        Base_MarkerRenderer = (function() {
        function Base_MarkerRenderer(chart) {
        this.chart = chart;
                this.settings = this.chart.scene.settings;
                this.cache = {};
                this.textLayout = null
        }
        Base_MarkerRenderer.prototype.measure = function(g, item) {
        var done, h, hh, i, w, ww, _ref;
                if (item.measureDone) {
        return
        }
        done = true;
                w = 0;
                h = 0;
                if (item.text) {
        _ref = this.measureText(g, item), ww = _ref[0], hh = _ref[1];
                h = Math.max(h, hh);
                w += ww + h * 0.5
        } else {
        item.lines = []
        }
        if (item.image) {
        if (item.imageSlicing) {
        w += item.imageSlicing[2];
                h = Math.max(h, item.imageSlicing[3])
        } else {
        i = this.settings.getAssetImage(item.image);
                if (i && i.width) {
        w += i.width;
                h = Math.max(h, i.height)
        } else {
        done = false
        }
        }
        }
        if (w === 0) {
        w = 10;
                h = 10
        }
        item.hwidth = w / 2;
                item.hheight = h / 2;
                return item.measureDone = done
        };
                Base_MarkerRenderer.prototype.measureText = function(g, item) {
                var aspect, h, locationFromHeight, textLayout, w, words;
                        aspect = item.aspectRatio;
                        if (aspect > 0 && (words = item.text.split(" ")).length > 1) {
                item.words = words;
                        textLayout = new Base_LabelLayoutBase(g, {textStyle: item.textStyle, angle: 0, margin: 0, lineSpacing: 0.2, interLabelSpacing: 0});
                        locationFromHeight = function(height) {
                        return[0, 0, 0, 0, height * (aspect + 0.2)]
                        };
                        textLayout.fitLabelInRect(item, item.align, locationFromHeight, false);
                        w = item.hwidth * 2;
                        h = item.hheight * 2
                } else {
                g.font = item.textStyle.font;
                        item.lineHeight = h = g.measureText("M").width * 1.25;
                        item.lines = [item.text];
                        w = g.measureText(item.text).width
                }
                return[w, h]
                };
                Base_MarkerRenderer.prototype.paint = function(g, x, y, scale, item) {
                var background, hw, i, image, left, line, lineHeight, lines, r, right, slicing, x0, xx, y0, _i, _len, _results;
                        if (!item.measureDone) {
                this.measure(g, item)
                }
                image = item.image;
                        lines = item.lines;
                        background = item.backgroundStyle;
                        hw = item.hwidth;
                        r = item.hheight;
                        item.curx = x;
                        item.cury = y;
                        left = x - hw;
                        right = x + hw;
                        if (background) {
                g.beginPath();
                        if (hw === r) {
                g.arc(x, y, r, 0, Math.PI * 2)
                } else {
                xx = x + hw - r;
                        g.moveTo(xx, y - r);
                        g.arc(xx, y, r, - Math.PI / 2, Math.PI / 2, false);
                        xx = x - hw + r;
                        g.lineTo(xx, y + r);
                        g.arc(xx, y, r, Math.PI * 0.5, Math.PI * 1.5, false)
                }
                g.closePath();
                        Base_Graphics.paint(g, background)
                }
                if (image != null) {
                i = this.settings.getAssetImage(image);
                        if (i) {
                slicing = item.imageSlicing;
                        if (slicing) {
                g.drawImage(i, slicing[0], slicing[1], slicing[2], slicing[3], x - hw, y - r, slicing[2], slicing[3]);
                        left += slicing[2]
                } else {
                g.drawImage(i, x - hw, y - r);
                        left += image.width
                }
                }
                }
                if (lines.length > 0) {
                lineHeight = item.lineHeight;
                        g.textBaseline = "middle";
                        y0 = y - (lines.length - 1) * lineHeight / 2;
                        if (this.align === "left") {
                x0 = left;
                        g.textAlign = "start"
                } else {
                if (this.align === "right") {
                x0 = right;
                        g.textAlign = "end"
                } else {
                x0 = (left + right) / 2
                }
                }
                Base_Graphics.textStyle(g, item.textStyle);
                        _results = [];
                        for (_i = 0, _len = lines.length; _i < _len; _i++) {
                line = lines[_i];
                        g.fillText(line, x0, y0);
                        _results.push(y0 += lineHeight)
                }
                return _results
                }
                };
                return Base_MarkerRenderer
        })();
        var Linearchart_ValueAxis, __hasProp = {}.hasOwnProperty;
        Linearchart_ValueAxis = (function() {
        Linearchart_ValueAxis.prototype.lastMaxValue = 0;
                Linearchart_ValueAxis.prototype.lastMinValue = 0;
                Linearchart_ValueAxis.prototype.minValue = 0;
                Linearchart_ValueAxis.prototype.maxValue = 0;
                Linearchart_ValueAxis.prototype.scale = 0;
                Linearchart_ValueAxis.prototype.zeroY = 0;
                Linearchart_ValueAxis.prototype.logOffset = 1;
                Linearchart_ValueAxis.prototype.minValueAnimation = null;
                Linearchart_ValueAxis.prototype.maxValueAnimation = null;
                Linearchart_ValueAxis.prototype.axisChanged = false;
                Linearchart_ValueAxis.prototype.seriesDepth = 0;
                Linearchart_ValueAxis.prototype.seriesMinValue = null;
                Linearchart_ValueAxis.prototype.seriesMaxValue = null;
                Linearchart_ValueAxis.prototype.series = 0;
                Linearchart_ValueAxis.prototype.x0 = 0;
                Linearchart_ValueAxis.computeSize = function(context, options) {
                var size;
                        size = 0;
                        Base_Graphics.textStyle(context, options.style.valueLabel);
                        size += 2 * options.style.valueLabel.margin + context.measureText("999.9 M").width;
                        if (options.title) {
                Base_Graphics.textStyle(context, options.style.title);
                        size += 2 * options.style.title.margin + context.measureText("M").width * 1.25
                }
                return size
                };
                Linearchart_ValueAxis.computeMargins = function(context, valueAxisList) {
                var axis, leftMargin, leftPadding, rightMargin, rightPadding, size, _i, _len;
                        leftPadding = 0;
                        rightPadding = 0;
                        leftMargin = 0;
                        rightMargin = 0;
                        for (_i = 0, _len = valueAxisList.length; _i < _len; _i++) {
                axis = valueAxisList[_i];
                        if (!axis.enabled) {
                continue
                }
                size = Linearchart_ValueAxis.computeSize(context, axis);
                        if (axis.side === "left") {
                if (axis.position !== "inside") {
                leftMargin += size
                } else {
                leftPadding += size
                }
                } else {
                if (axis.position !== "inside") {
                rightMargin += size
                } else {
                rightPadding += size
                }
                }
                }
                return[leftMargin, leftPadding, rightPadding, rightMargin]
                };
                Linearchart_ValueAxis.placeAxis = function(context, axisToInstanceMap) {
                var axis, inst, k, lip, lop, rip, rop, scene, size, v, valueAxisList, _i, _len, _results;
                        scene = null;
                        for (k in axisToInstanceMap) {
                if (!__hasProp.call(axisToInstanceMap, k)) {
                continue
                }
                v = axisToInstanceMap[k];
                        scene = v.scene;
                        break
                }
                valueAxisList = scene.settings.computedValueAxisList;
                        lop = scene.x0 - scene.leftMargin;
                        lip = scene.x0;
                        rip = scene.x0 + scene.width;
                        rop = scene.x0 + scene.width;
                        _results = [];
                        for (_i = 0, _len = valueAxisList.length; _i < _len; _i++) {
                axis = valueAxisList[_i];
                        if (!axis.enabled || !axisToInstanceMap.hasOwnProperty(axis.id)) {
                continue
                }
                inst = axisToInstanceMap[axis.id];
                        size = Linearchart_ValueAxis.computeSize(context, inst.options);
                        inst.size = size;
                        if (axis.side === "left") {
                if (axis.position !== "inside") {
                inst.x0 = lop;
                        _results.push(lop += size)
                } else {
                inst.x0 = lip;
                        _results.push(lip += size)
                }
                } else {
                if (axis.position !== "inside") {
                inst.x0 = rop;
                        _results.push(rop += size)
                } else {
                rip -= size;
                        _results.push(inst.x0 = rip)
                }
                }
                }
                return _results
                };
                function Linearchart_ValueAxis(chart, options) {
                this.options = options;
                        this.events = chart.events;
                        this.scene = chart.scene;
                        this.isLogScale = this.options.logScale;
                        this.isInside = this.options.position === "inside";
                        this.locations = [];
                        this.values = [];
                        this.cachedUnits = []
                }
        Linearchart_ValueAxis.prototype.recieveSeriesGeometry = function(min, max, depth) {
        if (min !== void 0) {
        if (this.seriesMinValue !== void 0) {
        this.seriesMinValue = Math.min(min, this.seriesMinValue)
        } else {
        this.seriesMinValue = min
        }
        }
        if (max !== void 0) {
        if (this.seriesMaxValue !== void 0) {
        this.seriesMaxValue = Math.max(max, this.seriesMaxValue)
        } else {
        this.seriesMaxValue = max
        }
        return this.seriesDepth = Math.max(depth, this.seriesDepth)
        }
        };
                Linearchart_ValueAxis.prototype.process = function(event) {
                var hasChanges, max, min;
                        hasChanges = event.changes.bounds || false;
                        if (event.changes.settings) {
                this.isLogScale = this.options.logScale;
                        this.isInside = this.options.position === "inside";
                        hasChanges = true
                }
                if (this.shouldChangeScale()) {
                if (this.seriesMinValue !== this.lastMinValue) {
                hasChanges = true;
                        if ((this.lastMinValue == null) || event.changes.displayUnit || this.minValue === this.maxValue) {
                this.minValueAnimation = null
                } else {
                if (this.minValueAnimation != null) {
                this.minValueAnimation.retarget(this.seriesMinValue)
                } else {
                this.minValueAnimation = new Base_Animator(this.lastMinValue, this.seriesMinValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, event.time)
                }
                }
                this.lastMinValue = this.seriesMinValue
                }
                if (this.seriesMaxValue !== this.lastMaxValue) {
                hasChanges = true;
                        if ((this.lastMaxValue == null) || event.changes.displayUnit || this.minValue === this.maxValue) {
                this.maxValueAnimation = null
                } else {
                if (this.maxValueAnimation != null) {
                this.maxValueAnimation.retarget(this.seriesMaxValue)
                } else {
                this.maxValueAnimation = new Base_Animator(this.lastMaxValue, this.seriesMaxValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, event.time)
                }
                }
                this.lastMaxValue = this.seriesMaxValue
                }
                }
                this.seriesMaxValue = void 0;
                        this.seriesMinValue = void 0;
                        if (this.minValueAnimation) {
                hasChanges = true;
                        min = this.minValueAnimation.get(event.time);
                        if (this.minValueAnimation.finished(event.time)) {
                this.minValueAnimation = null
                }
                } else {
                min = this.lastMinValue
                }
                if (this.maxValueAnimation) {
                hasChanges = true;
                        max = this.maxValueAnimation.get(event.time);
                        if (this.maxValueAnimation.finished(event.time)) {
                this.maxValueAnimation = null
                }
                } else {
                max = this.lastMaxValue
                }
                this.axisChanged = hasChanges;
                        if (hasChanges) {
                this.computeNewScale(min, max)
                }
                if (this.minValueAnimation || this.maxValueAnimation) {
                return event.animating = true
                }
                };
                Linearchart_ValueAxis.prototype.afterProcess = function(event) {
                var logMul, logUnit, step, textAboveLine, v, value, valuePerLine, valueY, y, y0, y1, _ref;
                        if (!this.axisChanged) {
                return
                }
                this.axisChanged = false;
                        if (!this.options.enabled) {
                return
                }
                this.locations = [];
                        this.values = [];
                        textAboveLine = parseInt(this.options.style.valueLabel.font) / 2 * 1.5;
                        y0 = this.scene.y0;
                        y1 = y0 + this.scene.height;
                        if (!(this.scale > 0)) {
                step = this.options.style.labelSpacing;
                        y = y1 - step;
                        v = 100;
                        while (y > y0) {
                this.locations.push(y | 0);
                        this.values.push(v);
                        if (this.options.logScale) {
                v *= 10
                } else {
                v += 100
                }
                y -= step
                }
                return
                }
                if (!this.isLogScale) {
                valuePerLine = this.calcLinearValuePerLine();
                        value = 0;
                        while (true) {
                value += valuePerLine;
                        valueY = this.zeroY - this.valueToRelativeY(value);
                        if (valueY - textAboveLine <= y0) {
                break
                }
                this.locations.push(valueY | 0);
                        this.values.push(value)
                }
                value = 0;
                        while (true) {
                value -= valuePerLine;
                        valueY = this.zeroY - this.valueToRelativeY(value);
                        if (valueY >= y1) {
                break
                }
                this.locations.push(valueY | 0);
                        this.values.push(value)
                }
                } else {
                _ref = this.calcExpValuePerLine(), logUnit = _ref[0], logMul = _ref[1];
                        value = 1 / logUnit;
                        while (true) {
                value *= logMul;
                        valueY = this.zeroY - this.valueToRelativeY(value);
                        if (valueY - textAboveLine < y0) {
                break
                }
                this.locations.push((valueY | 0) - 0.5);
                        this.values.push(value)
                }
                value = - 1 / logUnit;
                        while (true) {
                value *= logMul;
                        valueY = this.zeroY - this.valueToRelativeY(value);
                        if (valueY >= y1) {
                break
                }
                this.locations.push((valueY | 0) - 0.5);
                        this.values.push(value)
                }
                }
                if (this.minValue < 0 && this.maxValue > 0) {
                this.locations.push(this.zeroY | 0);
                        return this.values.push(0)
                }
                };
                Linearchart_ValueAxis.prototype.paintUnder = function(context) {
                if (this.options.enabled && this.series > 0 && this.locations.length > 0) {
                return this.paintZeroLine(context)
                }
                };
                Linearchart_ValueAxis.prototype.paint = function(context, seriesContext) {
                if (this.options.enabled && this.locations.length > 0) {
                this.paintGrid(seriesContext);
                        return this.paintLabels(context)
                }
                };
                Linearchart_ValueAxis.prototype.shouldChangeScale = function() {
                var seriesMax, seriesMin, tolerance;
                        seriesMin = this.seriesMinValue;
                        seriesMax = this.seriesMaxValue;
                        if (seriesMin === void 0 || seriesMax === void 0) {
                return false
                }
                if (this.lastMinValue === void 0 || this.lastMaxValue === void 0 || !(this.lastMinValue < this.lastMaxValue)) {
                return true
                }
                if (this.options.zeroLine === "center") {
                seriesMax = Math.max(seriesMax, - seriesMin);
                        seriesMin = - seriesMax
                } else {
                if (this.options.zeroLine === "visible") {
                seriesMin = Math.min(seriesMin, 0);
                        seriesMax = Math.max(seriesMax, 0)
                }
                }
                if (seriesMin < this.minValue || seriesMax > this.maxValue) {
                return true
                }
                tolerance = (this.lastMaxValue - this.lastMinValue) * this.options.scaleAdjustmentTolerance;
                        if (seriesMin > this.lastMinValue + tolerance || seriesMax < this.lastMaxValue - tolerance) {
                return true
                }
                return false
                };
                Linearchart_ValueAxis.prototype.computeNewScale = function(min, max) {
                var diff, height, max2, min2, minStep, range, topPos, y0;
                        height = this.scene.height;
                        y0 = this.scene.y0;
                        if (this.options.zeroLine === "center") {
                max = Math.max(max, - min);
                        min = - max
                } else {
                if (this.options.zeroLine === "visible") {
                min = Math.min(min, 0);
                        max = Math.max(max, 0)
                }
                }
                if (!height > 0 || !(min < max)) {
                this.minValue = 0;
                        this.maxValue = 0;
                        this.logOffset = 1;
                        this.scale = 0;
                        this.zeroY = y0 + height;
                        return
                }
                minStep = this.options.scaleMinUnit;
                        if (minStep > 0) {
                if (min < 0) {
                min = Math.floor(min / minStep) * minStep
                }
                if (max > 0) {
                max = Math.ceil(max / minStep) * minStep
                }
                }
                diff = max - min;
                        if (min !== 0 && min !== - 100) {
                if (this.isLogScale) {
                min = Base_Helpers.sign(min) * Math.pow(Math.abs(min), 1 - Base_Helpers.sign(min) * this.options.scaleAdjustmentTolerance)
                } else {
                min2 = min - diff * this.options.scaleAdjustmentTolerance;
                        if (min > 0) {
                min = Math.max(0, min2)
                } else {
                if (min < 0) {
                min = Math.min(0, min2)
                }
                }
                }
                }
                if (max !== 0 && max !== 100) {
                if (this.isLogScale) {
                max = Base_Helpers.sign(max) * Math.pow(Math.abs(max), 1 + Base_Helpers.sign(max) * this.options.scaleAdjustmentTolerance)
                } else {
                max2 = max + diff * this.options.scaleAdjustmentTolerance;
                        if (max > 0) {
                max = Math.max(0, max2)
                } else {
                if (max < 0) {
                max = Math.min(0, max2)
                }
                }
                }
                }
                this.minValue = min;
                        this.maxValue = max;
                        if (!this.isLogScale) {
                range = max - min
                } else {
                if (min <= 0 || max >= 0) {
                this.logOffset = 1;
                        range = Math.log(max + this.logOffset) + Math.log( - min + this.logOffset)
                } else {
                if (min < 0) {
                this.logOffset = 1 - min;
                        range = Math.log(max + this.logOffset)
                } else {
                if (max > 0) {
                this.logOffset = 1 + max;
                        range = Math.log( - min + this.logOffset)
                }
                }
                }
                }
                this.scale = height / range;
                        topPos = this.valueToRelativeY(min);
                        return this.zeroY = y0 + height + topPos
                };
                Linearchart_ValueAxis.prototype.valueToRelativeY = function(value) {
                if (!this.isLogScale) {
                return this.scale * value
                } else {
                if (value > 0) {
                return this.scale * Math.log(value + this.logOffset)
                } else {
                if (value < 0) {
                return - this.scale * Math.log( - value + this.logOffset)
                } else {
                return 0
                }
                }
                }
                };
                Linearchart_ValueAxis.prototype.calcLinearValuePerLine = function() {
                var base, desired, orderOfMagnitude;
                        desired = this.options.style.labelSpacing / this.scale;
                        orderOfMagnitude = Math.log(desired) / Math.log(10);
                        base = Math.pow(10, Math.floor(orderOfMagnitude - 1));
                        base = Math.max(base, this.options.scaleMinUnit);
                        while (base < desired) {
                if (base * 2 >= desired) {
                return base * 2
                }
                if (base > 10 && base * 2.5 >= desired) {
                return base * 2.5
                }
                if (base * 5 >= desired) {
                return base * 5
                }
                base *= 10
                }
                return base
                };
                Linearchart_ValueAxis.prototype.calcExpValuePerLine = function() {
                var pixelsPer10Times, stepSize, unit, valueMultiplier;
                        pixelsPer10Times = this.valueToRelativeY(10) - this.valueToRelativeY(1);
                        valueMultiplier = 10;
                        unit = 10;
                        stepSize = pixelsPer10Times;
                        if (stepSize > this.options.style.labelSpacing * 4) {
                return[2, 2]
                }
                while (stepSize < this.options.style.labelSpacing) {
                valueMultiplier *= 10;
                        stepSize += pixelsPer10Times
                }
                return[unit, valueMultiplier]
                };
                Linearchart_ValueAxis.prototype.getUnitAndName = function(base, settings) {
                var digitsAfterComma, i, m, name, s, u, unit, x, _ref;
                        base = Math.abs(base);
                        i = this.isLogScale ? "log" : "lin";
                        if (typeof this.cachedUnits[i] === "undefined") {
                this.cachedUnits[i] = []
                }
                unit = 1;
                        name = "";
                        if (this.cachedUnits[i][base]) {
                return this.cachedUnits[i][base]
                }
                _ref = settings.localization.valueUnits;
                        for (u in _ref) {
                m = _ref[u];
                        s = Math.abs(base / m);
                        if (i === "lin") {
                if (s < 1000 && s >= 1) {
                unit = m;
                        name = u;
                        break
                }
                } else {
                if (i === "log") {
                if (base === Math.round(base / m) * m && unit < m) {
                unit = m;
                        name = u
                }
                }
                }
                }
                digitsAfterComma = 0;
                        if (base > 0) {
                x = 1;
                        while (base < x) {
                digitsAfterComma += 1;
                        x /= 10
                }
                }
                this.cachedUnits[i][base] = [unit, digitsAfterComma, name];
                        return[unit, digitsAfterComma, name]
                };
                Linearchart_ValueAxis.prototype.paintGrid = function(g) {
                var i, x1, x2, y, _i, _j, _len, _len1, _ref, _ref1;
                        if (!this.options.hgrid) {
                return
                }
                x1 = this.scene.x0;
                        x2 = this.scene.x0 + this.scene.width;
                        g.beginPath();
                        g.lineWidth = 1;
                        _ref = this.locations;
                        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                y = _ref[i];
                        if (this.values[i] === 0) {
                continue
                }
                g.moveTo(x1, y);
                        g.lineTo(x2, y)
                }
                Base_Graphics.stroke(g, this.options.style.hgrid1);
                        if (this.options.style.hgrid2 != null) {
                g.beginPath();
                        _ref1 = this.locations;
                        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                y = _ref1[i];
                        if (this.values[i] === 0) {
                continue
                }
                g.moveTo(x1, y + 1);
                        g.lineTo(x2, y + 1)
                }
                return Base_Graphics.stroke(g, this.options.style.hgrid2)
                }
                };
                Linearchart_ValueAxis.prototype.paintZeroLine = function(g) {
                var d, x1, x2, z;
                        d = Math.max(this.options.style.baseLineDepth, this.seriesDepth);
                        x1 = this.scene.x0;
                        x2 = this.scene.x0 + this.scene.width;
                        z = this.zeroY;
                        g.beginPath();
                        if (d > 0) {
                g.fillStyle = this.options.style.baseLineFillStyle;
                        g.lineWidth = this.options.style.baseLineWidth;
                        g.moveTo(x1, z);
                        g.lineTo(x1 + d, z - d);
                        g.lineTo(x2, z - d);
                        g.lineTo(x2, z);
                        g.closePath();
                        return g.fill()
                } else {
                g.strokeStyle = this.options.style.baseLineStyle;
                        g.lineWidth = Math.max(1, this.options.style.baseLineWidth);
                        g.moveTo(x1, z);
                        g.lineTo(x2, z);
                        return g.stroke()
                }
                };
                Linearchart_ValueAxis.prototype.paintLabels = function(g) {
                var align, centerX, centerY, fractionDigits, height, i, isRightSide, labelX, margin, name, reverseDirection, tickx, titleWidth, unitMultiplier, unitName, value, valueY, x0, x1, y, y0, _i, _j, _len, _ref, _ref1, _ref2, _ref3;
                        x0 = this.x0;
                        x1 = this.x0 + this.size;
                        isRightSide = this.options.side === "right";
                        if (this.options.title) {
                y0 = this.scene.y0;
                        height = this.scene.height;
                        Base_Graphics.textStyle(g, this.options.style.title);
                        titleWidth = g.measureText("M").width * 1.25;
                        reverseDirection = this.options.style.title.reverseDirection;
                        margin = this.options.style.title.margin;
                        align = this.options.style.title.alignment;
                        centerY = y0 + height * 0.5;
                        g.save();
                        if (isRightSide) {
                centerX = x1 - margin - titleWidth * 0.5;
                        if (reverseDirection) {
                g.transform(0, - 1, 1, 0, centerX, centerY)
                } else {
                g.transform(0, 1, - 1, 0, centerX, centerY)
                }
                x1 -= titleWidth + margin * 2
                } else {
                centerX = x0 + margin + titleWidth * 0.5;
                        if (reverseDirection) {
                g.transform(0, 1, - 1, 0, centerX, centerY)
                } else {
                g.transform(0, - 1, 1, 0, centerX, centerY)
                }
                x0 += titleWidth + margin * 2
                }
                g.textBaseline = "middle";
                        if (align === "left") {
                g.textAlign = "left";
                        g.fillText(this.options.title, - (height / 2 - margin), 0)
                } else {
                if (align === "right") {
                g.textAlign = "right";
                        g.fillText(this.options.title, height / 2 - margin, 0)
                } else {
                g.textAlign = "center";
                        g.fillText(this.options.title, 0, 0)
                }
                }
                g.restore()
                }
                if (this.isInside) {
                g.textAlign = "center";
                        g.textBaseline = "middle";
                        labelX = (x0 + x1) / 2
                } else {
                if (isRightSide) {
                g.textAlign = "start";
                        g.textBaseline = "middle";
                        tickx = x0;
                        labelX = x0 + 7
                } else {
                g.textAlign = "end";
                        g.textBaseline = "middle";
                        tickx = x1 - 4;
                        labelX = x1 - 7
                }
                }
                if (!this.isInside) {
                g.beginPath();
                        _ref = this.locations;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                y = _ref[_i];
                        g.moveTo(tickx, y);
                        g.lineTo(tickx + 4, y)
                }
                Base_Graphics.stroke(g, this.options.style.tick)
                }
                g.save();
                        g.lineWidth = 0;
                        g.strokeStyle = "";
                        g.shadowOffsetX = 0;
                        g.shadowOffsetY = 0;
                        Base_Graphics.textStyle(g, this.options.style.valueLabel);
                        for (i = _j = 0, _ref1 = this.locations.length - 1; _j <= _ref1; i = _j += 1) {
                value = this.values[i];
                        valueY = this.locations[i];
                        if (this.isLogScale) {
                _ref2 = this.getUnitAndName(value, this.scene.settings), unitMultiplier = _ref2[0], fractionDigits = _ref2[1], unitName = _ref2[2]
                } else {
                _ref3 = this.getUnitAndName(this.values[0], this.scene.settings), unitMultiplier = _ref3[0], fractionDigits = _ref3[1], unitName = _ref3[2]
                }
                name = (value / unitMultiplier).toFixed(fractionDigits);
                        if (unitMultiplier !== "" && value) {
                name = name + " " + unitName
                }
                if (this.isInside) {
                g.fillText(name, labelX, valueY)
                } else {
                g.fillText(name, labelX, valueY)
                }
                }
                g.restore()
                };
                return Linearchart_ValueAxis
        })();
        var Timechart_TimeSetup;
        Timechart_TimeSetup = (function() {
        Timechart_TimeSetup.prototype.settigns = null;
                function Timechart_TimeSetup(settings) {
                this.settings = settings;
                        true
                }
        Timechart_TimeSetup.isSmallerOrEqualUnit = function(smaller, bigger) {
        return Base_TimeStep.timeUnitDiffs[smaller] <= Base_TimeStep.timeUnitDiffs[bigger]
        };
                Timechart_TimeSetup.isSmallerUnit = function(smaller, bigger) {
                return Base_TimeStep.timeUnitDiffs[smaller] < Base_TimeStep.timeUnitDiffs[bigger]
                };
                Timechart_TimeSetup.prototype.toBiggerDisplayPeriod = function(unit) {
                var best, p, _i, _len, _ref;
                        best = null;
                        _ref = this.settings.area.displayPeriodsParsed;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                p = _ref[_i];
                        if ((p.displayPeriod != null) && p.displayPeriod.approxTime() > unit.approxTime() && (best === null || p.displayPeriod.approxTime() < best.approxTime())) {
                best = p.displayPeriod
                }
                }
                return best
                };
                Timechart_TimeSetup.prototype.getBiggerDisplayPeriod = function(from, to) {
                var best, bestD, dt, p, proportion, unitdt, _i, _len, _ref;
                        dt = Math.abs(to - from);
                        bestD = 0;
                        best = null;
                        _ref = this.settings.area.displayPeriodsParsed;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                p = _ref[_i];
                        if (!((p.displayPeriod != null) && (p.displayPeriod.unit != null))) {
                continue
                }
                unitdt = p.displayPeriod.approxTime();
                        proportion = dt / unitdt;
                        if (proportion < 0.9 && proportion > bestD) {
                bestD = proportion;
                        best = p
                }
                }
                return best
                };
                Timechart_TimeSetup.prototype.getClosestDisplayPeriod = function(dt, unitHint, allowMultiples) {
                var above, aboveT, below, belowT, p, pt, _i, _len, _ref;
                        below = null;
                        belowT = 0;
                        above = null;
                        aboveT = Infinity;
                        _ref = this.settings.area.displayPeriodsParsed;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                p = _ref[_i];
                        if (!((p.displayPeriod != null) && (p.displayPeriod.unit != null))) {
                continue
                }
                pt = p.displayPeriod.approxTime();
                        if (pt <= dt && ((below == null) || belowT < pt)) {
                below = p;
                        belowT = pt
                }
                if (pt >= dt && ((above == null) || aboveT > pt)) {
                above = p;
                        aboveT = pt
                }
                }
                if (allowMultiples) {
                if ((unitHint != null) && unitHint.approxTime() < dt * 0.8) {
                return{displayPeriod: unitHint}
                }
                if (((above != null) && aboveT < dt * 1.2) || (below == null)) {
                return above
                } else {
                return below
                }
                } else {
                if ((below != null) && (belowT > dt * 0.8 || aboveT > dt * 1.2)) {
                return below
                } else {
                return above
                }
                }
                };
                Timechart_TimeSetup.prototype.isAllowedDisplayUnit = function(unit) {
                var u, _i, _len, _ref;
                        _ref = this.settings.area.displayUnitsParsed;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                u = _ref[_i];
                        if (u.step === unit.step && (u.count = unit.count)) {
                return true
                }
                }
                return false
                };
                Timechart_TimeSetup.prototype.computeDisplayUnit = function(oldFrom, oldTo, oldUnit, from, to, scene) {
                var diff, displayUnit, displayUnitDiff, maxUnitTime, maxUnitWidth, minUnitTime, oldUnitTime, step, width, zoom, _i, _len, _ref;
                        width = Math.max(scene.width, 10);
                        maxUnitWidth = Math.min(width / 3, this.settings.timeAxis.maxUnitWidth);
                        minUnitTime = (to - from) / width * this.settings.timeAxis.minUnitWidth;
                        maxUnitTime = (to - from) / width * maxUnitWidth;
                        if ((oldFrom != null) && (oldTo != null) && (oldUnit != null)) {
                zoom = (oldTo - oldFrom) / (to - from);
                        oldUnitTime = oldUnit.approxTime();
                        if (zoom === 1) {
                return oldUnit
                } else {
                if (zoom > 1) {
                if (oldUnitTime <= maxUnitTime) {
                return oldUnit
                }
                } else {
                if (oldUnitTime >= minUnitTime) {
                return oldUnit
                }
                }
                }
                }
                displayUnit = null;
                        displayUnitDiff = 0;
                        _ref = this.settings.area.displayUnitsParsed;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                step = _ref[_i];
                        if (step.approxTime() < this.settings.area.minUnit.approxTime()) {
                continue
                }
                diff = step.approxTime();
                        if (displayUnit === null || (diff < maxUnitTime && diff > displayUnitDiff) || (displayUnitDiff > maxUnitTime && diff < displayUnitDiff && diff > minUnitTime)) {
                displayUnit = step;
                        displayUnitDiff = diff
                }
                }
                if (!displayUnit) {
                console.error(oldFrom, oldTo, oldUnit, from, to, width);
                        throw"Could not calculate displayUnit"
                }
                return displayUnit
                };
                Timechart_TimeSetup.prototype.tryComputeDisplayPeriod = function(periodStr, anchorStr, unitStr, dataFrom, dataTo, scene, curTime) {
                var anchor, from, fromS, maxTimeScale, maxUnit, minTimeScale, minUnit, period, to, toS, unit, _ref, _ref1;
                        from = null;
                        to = null;
                        if ((periodStr != null) && Base_Helpers.arrayContains(periodStr, ">")) {
                _ref = periodStr.split(">"), fromS = _ref[0], toS = _ref[1];
                        from = parseInt(fromS);
                        to = parseInt(toS)
                } else {
                if (periodStr === "max" && (dataFrom != null) && (dataTo != null)) {
                from = dataFrom;
                        to = anchorStr === "now" ? curTime : dataTo
                } else {
                if (periodStr !== "max") {
                period = Base_TimeStep.parse(periodStr);
                        if (anchorStr === "now") {
                anchor = curTime
                } else {
                if (anchorStr === "newestData" && (dataTo != null)) {
                anchor = dataTo
                } else {
                if (Base_Helpers.isNumber(anchorStr)) {
                anchor = parseFloat(anchorStr)
                }
                }
                }
                if ((period != null) && (anchor != null)) {
                from = period.sub(anchor);
                        to = anchor
                }
                }
                }
                }
                if (from === null || to === null) {
                return[null, null, null]
                }
                _ref1 = this.computeTimeScaleRange(scene), minTimeScale = _ref1[0], maxTimeScale = _ref1[1], minUnit = _ref1[2], maxUnit = _ref1[3];
                        unit = unitStr === "auto" ? null : Base_TimeStep.parse(unitStr);
                        if (to - from > maxTimeScale) {
                unit = maxUnit;
                        from = to - maxTimeScale
                }
                if (to - from < minTimeScale) {
                unit = minUnit;
                        from = to - minTimeScale
                }
                return[from, to, unit]
                };
                Timechart_TimeSetup.prototype.computeTimeScaleRange = function(scene, unitSteps) {
                var diff, maxDiff, maxTime, maxUnit, minDiff, minTime, minUnit, step, width, _i, _len;
                        if (unitSteps == null) {
                unitSteps = this.settings.area.displayUnitsParsed
                }
                minUnit = null;
                        minDiff = 0;
                        maxUnit = null;
                        maxDiff = Infinity;
                        for (_i = 0, _len = unitSteps.length; _i < _len; _i++) {
                step = unitSteps[_i];
                        diff = step.approxTime();
                        if (minUnit === null || minDiff > diff) {
                minUnit = step;
                        minDiff = diff
                }
                if (maxUnit === null || maxDiff < diff) {
                maxUnit = step;
                        maxDiff = diff
                }
                }
                width = Math.max(10, scene.width);
                        maxTime = width / this.settings.timeAxis.minUnitWidth * maxDiff;
                        minTime = width / this.settings.timeAxis.maxUnitWidth * minDiff;
                        return[minTime, maxTime, minUnit, maxUnit]
                };
                Timechart_TimeSetup.prototype.preventOverscale = function(scene, units, origin, from, to, displayFrom, displayTo) {
                var center, downscale, maxTime, minTime, offset, time, _ref;
                        if (displayFrom < displayTo && to - from > displayTo - displayFrom) {
                center = (displayFrom + displayTo) / 2;
                        offset = (displayTo - displayFrom) * this.settings.advanced.maxZoomOutFactor / 2;
                        return[center - offset, center + offset]
                } else {
                _ref = this.computeTimeScaleRange(scene, units), minTime = _ref[0], maxTime = _ref[1];
                        maxTime *= 0.99;
                        minTime *= 1.01;
                        time = to - from;
                        time = Math.min(time, maxTime);
                        time = Math.max(time, minTime);
                        downscale = time / (to - from);
                        if (origin == null) {
                origin = (from + to) / 2
                }
                if (from === to) {
                console.error("From = To, trouble", from, to)
                }
                return[origin + (from - origin) * downscale, origin + (to - origin) * downscale]
                }
                };
                Timechart_TimeSetup.prototype.preventOverscroll = function(unit, from, to, dataFrom, dataTo) {
                var dfrom, dfrom0, diff, dto, dto0, proportion;
                        dataFrom = unit.roundTimeDown(dataFrom);
                        dataTo = unit.roundTimeUp(dataTo);
                        diff = to - from;
                        proportion = this.settings.interaction.scrolling.noDataSnapBackProportion;
                        dfrom0 = dataFrom - from;
                        dto0 = dataTo - to;
                        dataFrom -= diff * (1 - proportion);
                        dataTo += diff * (1 - proportion);
                        dfrom = dataFrom - from;
                        dto = dataTo - to;
                        if (dfrom0 > 0 && dto0 < 0) {
                1
                } else {
                if (dfrom > 0) {
                from += Math.min(dfrom, dto);
                        to += Math.min(dfrom, dto)
                } else {
                if (dto < 0) {
                from += Math.max(dfrom, dto);
                        to += Math.max(dfrom, dto)
                }
                }
                }
                return[from, to]
                };
                Timechart_TimeSetup.prototype.scroll = function(from, to, displayUnit, direction, count, unit) {
                var step;
                        if (unit === "displayUnit") {
                step = displayUnit.clone()
                } else {
                if (unit === "page") {
                step = this.getTimeRangeStep(from, to)
                } else {
                if (Base_TimeStep.isGoodUnit(unit)) {
                step = Base_TimeStep.parse(unit)
                } else {
                Base_Helpers.error("Incorrect scroll unit: " + unit);
                        return
                }
                }
                }
                step.count *= count;
                        if (direction === "<") {
                return[step.sub(from), step.sub(to)]
                } else {
                return[step.add(from), step.add(to)]
                }
                };
                Timechart_TimeSetup.prototype.getTimeRangeStep = function(from, to) {
                var biggestStep, ff, step, tt, unit, _i, _len, _ref;
                        from = Math.round(from);
                        to = Math.round(to);
                        biggestStep = null;
                        _ref = Base_TimeStep.knownUnits;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                unit = _ref[_i];
                        step = new Base_TimeStep(unit, 1);
                        ff = step.roundTimeRound(from);
                        tt = step.roundTimeRound(to);
                        if (from === ff && to === tt && (biggestStep === null || biggestStep.approxTime() < step.approxTime())) {
                biggestStep = step
                }
                }
                biggestStep.count = Math.max(1, biggestStep.numberOfUnits(from, to));
                        return biggestStep
                };
                return Timechart_TimeSetup
        })();
        var PieChart_Renderer_Flat, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        PieChart_Renderer_Flat = (function(_super) {
        __extends(PieChart_Renderer_Flat, _super);
                function PieChart_Renderer_Flat() {
                return PieChart_Renderer_Flat.__super__.constructor.apply(this, arguments)
                }
        PieChart_Renderer_Flat.prototype.paintSlices = function(g, x, y, slices) {
        var slice, _i, _len, _results;
                _results = [];
                for (_i = 0, _len = slices.length; _i < _len; _i++) {
        slice = slices[_i];
                _results.push(this.strokeAndPaint(g, x, y, slice))
        }
        return _results
        };
                return PieChart_Renderer_Flat
        })(PieChart_Renderer_Base);
        var PieChart_Renderer_Can, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        PieChart_Renderer_Can = (function(_super) {
        __extends(PieChart_Renderer_Can, _super);
                function PieChart_Renderer_Can() {
                return PieChart_Renderer_Can.__super__.constructor.apply(this, arguments)
                }
        PieChart_Renderer_Can.prototype.paintPie = function(context, x, y, r0, r1, a0, a1, pie) {
        var depth, offset, _i, _len, _ref, _results;
                PieChart_Renderer_Can.__super__.paintPie.call(this, context, x, y, r0, r1, a0, a1, pie);
                depth = this.settings.pie.depth;
                if (depth > 0 && pie.allSlices.length > 0) {
        context.fillStyle = "rgba(0,0,0,0.05)";
                _ref = [5, 10, 18];
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        offset = _ref[_i];
                context.beginPath();
                context.arc(x, y + offset + depth, r1, a0, a1, false);
                context.arc(x, y + offset + depth, r0, a1, a0, true);
                context.closePath();
                _results.push(context.fill())
        }
        return _results
        }
        };
                PieChart_Renderer_Can.prototype.paintSlices = function(g, x, y, slices) {
                var PI, density, depth, i, leftAngle, numSteps, params, rightAngle, slice, stepOffset, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _results;
                        depth = this.settings.pie.depth;
                        density = 2 * this.settings.advanced.renderQuality;
                        stepOffset = 1 / density;
                        numSteps = depth * density;
                        g.shadowOffsetX = 0;
                        g.shadowOffsetY = 0;
                        g.shadowBlur = depth * 1.5;
                        g.shadowColor = "black";
                        g.fillStyle = "black";
                        for (_i = 0, _len = slices.length; _i < _len; _i++) {
                slice = slices[_i];
                        this.strokeSlice(g, x, y + depth, slice);
                        g.fill()
                }
                g.shadowColor = null;
                        g.shadowBlur = 0;
                        g.lineWidth = 1;
                        for (i = _j = 0; _j <= numSteps; i = _j += 1) {
                for (_k = 0, _len1 = slices.length; _k < _len1; _k++) {
                slice = slices[_k];
                        this.strokeSlice(g, x, y + depth - i * stepOffset, slice);
                        if (i >= numSteps - 1) {
                g.strokeStyle = Base_Graphics.deriveColor(slice.fillColor, 1.35, 1)
                } else {
                g.strokeStyle = Base_Graphics.deriveColor(slice.fillColor, 0.5 + i / numSteps * 0.2, 1)
                }
                g.stroke()
                }
                }
                PI = Math.PI;
                        g.shadowBlur = depth;
                        g.shadowColor = "rgba(0,0,0,0.1)";
                        g.fillStyle = "black";
                        for (_l = 0, _len2 = slices.length; _l < _len2; _l++) {
                slice = slices[_l];
                        params = slice.renderParams;
                        leftAngle = params[4];
                        rightAngle = params[5];
                        if (leftAngle === rightAngle) {
                continue
                }
                while (leftAngle > PI) {
                leftAngle -= PI * 2;
                        rightAngle -= PI * 2
                }
                if (leftAngle < 0) {
                if (rightAngle > 0) {
                rightAngle = Math.min(rightAngle, PI);
                        if (this.strokeInnerShadowSlice(g, x, y, slice, 0, rightAngle)) {
                g.fill()
                }
                }
                } else {
                if (rightAngle < PI) {
                if (this.strokeInnerShadowSlice(g, x, y, slice, leftAngle, rightAngle)) {
                g.fill()
                }
                } else {
                if (leftAngle < PI) {
                if (this.strokeInnerShadowSlice(g, x, y, slice, leftAngle, PI)) {
                g.fill()
                }
                }
                if (rightAngle > 2 * PI) {
                if (this.strokeInnerShadowSlice(g, x, y, slice, PI * 2, rightAngle)) {
                g.fill()
                }
                }
                }
                }
                }
                _results = [];
                        for (_m = 0, _len3 = slices.length; _m < _len3; _m++) {
                slice = slices[_m];
                        g.beginPath();
                        this.strokeSlice(g, x, y, slice);
                        _results.push(Base_Graphics.paint(g, slice))
                }
                return _results
                };
                PieChart_Renderer_Can.prototype.strokeInnerShadowSlice = function(context, x, y, slice, leftAngle, rightAngle) {
                var params, r0, r1;
                        params = slice.renderParams;
                        r0 = params[0] + 1;
                        r1 = Math.min(params[1] - 1, r0 + 10);
                        if (r0 >= params[1] || r1 <= params[0]) {
                return false
                }
                leftAngle += 1 / r0;
                        rightAngle -= 1 / r0;
                        if (leftAngle >= rightAngle) {
                return
                }
                context.beginPath();
                        context.arc(x, y, r1, leftAngle, rightAngle, false);
                        context.arc(x, y, r0, rightAngle, leftAngle, true);
                        context.closePath();
                        return true
                };
                return PieChart_Renderer_Can
        })(PieChart_Renderer_Base);
        var PieChart_Renderer_Smoothy, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        PieChart_Renderer_Smoothy = (function(_super) {
        __extends(PieChart_Renderer_Smoothy, _super);
                function PieChart_Renderer_Smoothy() {
                return PieChart_Renderer_Smoothy.__super__.constructor.apply(this, arguments)
                }
        PieChart_Renderer_Smoothy.prototype.gradients = {};
                PieChart_Renderer_Smoothy.prototype.paintSlices = function(g, x, y, slices) {
                var slice, _i, _len, _results;
                        this.g = g;
                        _results = [];
                        for (_i = 0, _len = slices.length; _i < _len; _i++) {
                slice = slices[_i];
                        this.strokeSlice(g, x, y, slice);
                        Base_Graphics.paint(g, slice);
                        _results.push(this.elegantGradient(x, y, slice))
                }
                return _results
                };
                PieChart_Renderer_Smoothy.prototype.getRadialGradient = function(x, y, sr0, x1, y1, sr1, angle) {
                var c1, gradient;
                        c1 = Math.abs(Math.sin(angle));
                        gradient = this.g.createRadialGradient(x, y, sr0, x1, y1, sr1);
                        this.addColorStops(gradient, c1, angle);
                        return gradient
                };
                PieChart_Renderer_Smoothy.prototype.getLinearGradient = function(g, x, y, sr0, x1, y1, sr1, angle) {
                var c1, cosa, dr, gradient, rx0, rx1, ry0, ry1, sina;
                        dr = sr1 - sr0;
                        sina = Math.sin(angle);
                        cosa = Math.cos(angle);
                        rx0 = x + cosa * sr0;
                        ry0 = y + sina * sr0;
                        rx1 = rx0 + cosa * dr;
                        ry1 = ry0 + sina * dr;
                        c1 = Math.abs(sina);
                        gradient = this.g.createLinearGradient(rx0, ry0, rx1, ry1);
                        this.addColorStops(gradient, c1, angle);
                        return gradient
                };
                PieChart_Renderer_Smoothy.prototype.addColorStops = function(g, c1, angle) {
                var black, coef1, coef2, coef3, coef4, coef5, col1, col2, white;
                        black = "0,0,0";
                        white = "255,255,255";
                        if (angle <= 0 || angle > Math.PI) {
                col1 = black;
                        col2 = white
                } else {
                col1 = white;
                        col2 = black
                }
                coef1 = 0.4 * c1;
                        coef2 = 0.2 * c1;
                        coef3 = 0.1 * c1;
                        coef4 = 0.3 * c1;
                        coef5 = 0.5 * c1;
                        g.addColorStop(0, "rgba(" + col1 + "," + coef1.toFixed(3) + ")");
                        g.addColorStop(0.1, "rgba(" + col1 + "," + coef2.toFixed(3) + ")");
                        g.addColorStop(0.1, "rgba(" + col1 + "," + coef3.toFixed(3) + ")");
                        g.addColorStop(0.4, "rgba(" + black + "," + 0.1 + ")");
                        g.addColorStop(0.9, "rgba(" + col2 + "," + coef3.toFixed(3) + ")");
                        g.addColorStop(0.95, "rgba(" + col2 + "," + coef4.toFixed(3) + ")");
                        return g.addColorStop(1, "rgba(" + col2 + "," + coef5.toFixed(3) + ")")
                };
                PieChart_Renderer_Smoothy.prototype.elegantGradient = function(xx, yy, slice) {
                var a1, a2, as1, as2, inc, quality, sr0, sr1, _results;
                        sr0 = slice.renderParams[0];
                        sr1 = slice.renderParams[1];
                        a1 = slice.renderParams[2];
                        a2 = slice.renderParams[3];
                        quality = this.settings.advanced.renderQuality;
                        inc = Math.PI / Math.max(1, 180 * quality);
                        as1 = a1;
                        _results = [];
                        while (as1 < a2) {
                as2 = Math.min(as1 + inc, a2);
                        this.g.beginPath();
                        this.g.arc(xx, yy, sr1, as1, as2);
                        this.g.arc(xx, yy, sr0, as2, as1, true);
                        this.g.closePath();
                        Base_Graphics.paint(this.g, {fillColor: this.getRadialGradient(xx, yy, sr0, xx, yy, sr1, as1)});
                        _results.push(as1 = as2)
                }
                return _results
                };
                return PieChart_Renderer_Smoothy
        })(PieChart_Renderer_Base);
        var PieChart_Renderer_Bevel, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        }, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        PieChart_Renderer_Bevel = (function(_super) {
        __extends(PieChart_Renderer_Bevel, _super);
                function PieChart_Renderer_Bevel() {
                this.getSmartGradient = __bind(this.getSmartGradient, this);
                        return PieChart_Renderer_Bevel.__super__.constructor.apply(this, arguments)
                }
        PieChart_Renderer_Bevel.prototype.gradients = {};
                PieChart_Renderer_Bevel.prototype.paintSlices = function(g, x, y, slices) {
                var slice, _i, _len, _results;
                        this.g = g;
                        _results = [];
                        for (_i = 0, _len = slices.length; _i < _len; _i++) {
                slice = slices[_i];
                        this.strokeAndPaint(g, x, y, slice);
                        _results.push(this.smartGradient(x, y, slice))
                }
                return _results
                };
                PieChart_Renderer_Bevel.prototype.getSmartGradient = function(x, y, sr0, sr1, side, position) {
                var c1, c2, e, gradient, n, x1, x2, y1, y2;
                        n = "g" + side + position + sr0 + sr1;
                        if ((this.gradients[n] != null) && false) {
                return this.gradients[n]
                }
                if (side === "inside") {
                if (position === "top") {
                y1 = x1 = x2 = y2 = 0;
                        y1 = sr1 - sr0;
                        y2 = y;
                        c1 = "rgba(0,0,0,0.3)";
                        c2 = "rgba(0,0,0,0)"
                } else {
                y1 = x1 = x2 = y2 = 0;
                        y1 = y;
                        y2 = y + sr0;
                        c1 = "rgba(255,255,255,0)";
                        c2 = "rgba(255,255,255,0.3)"
                }
                } else {
                if (position === "top") {
                y1 = x1 = x2 = y2 = 0;
                        y2 = y;
                        c1 = "rgba(255,255,255,0.3)";
                        c2 = "rgba(255,255,255,0)"
                } else {
                y1 = x1 = x2 = y2 = 0;
                        y1 = y;
                        y2 = y + sr1;
                        c1 = "rgba(0,0,0,0)";
                        c2 = "rgba(0,0,0,0.3)"
                }
                }
                try {
                gradient = this.g.createLinearGradient(x1, y1, x2, y2);
                        gradient.addColorStop(0, c1);
                        gradient.addColorStop(1, c2);
                        this.gradients[n] = gradient;
                        return gradient
                } catch (_error) {
                e = _error;
                        ;
                        throw"Could not create linear gradient: " + e
                }
                };
                PieChart_Renderer_Bevel.prototype.smartOuterShineTop = function(x, y, sr0, sr1, a1, a2, a3, a4) {
                var s;
                        if (a1 > 0 && a2 < Math.PI) {
                return
                }
                if (a2 > 0 && a1 < 0) {
                a2 = 0;
                        a4 = 0
                }
                if (a1 > 0 && a1 < Math.PI) {
                a1 = Math.PI;
                        a3 = Math.PI
                }
                s = {renderParams: [sr1 - 0.1 * (sr1 - sr0), sr1, a1, a2, a3, a4], x: 0, y: 0};
                        s.fillColor = this.getSmartGradient(x, y, sr0, sr1, "outside", "top");
                        return this.strokeAndPaint(this.g, x, y, s)
                };
                PieChart_Renderer_Bevel.prototype.smartOuterShineBottom = function(x, y, sr0, sr1, a1, a2, a3, a4) {
                var s;
                        if (a2 < 0 || a1 > Math.PI) {
                return
                }
                if (a1 < 0) {
                a1 = 0;
                        a3 = 0
                }
                if (a2 > Math.PI) {
                a2 = Math.PI;
                        a4 = Math.PI
                }
                s = {renderParams: [sr1 - 0.1 * (sr1 - sr0), sr1, a1, a2, a3, a4], x: 0, y: 0};
                        s.fillColor = this.getSmartGradient(x, y, sr0, sr1, "outside", "bottom");
                        return this.strokeAndPaint(this.g, x, y, s)
                };
                PieChart_Renderer_Bevel.prototype.smartInnerShineTop = function(x, y, sr0, sr1, a1, a2, a3, a4) {
                var s;
                        if (a1 > 0 && a2 < Math.PI) {
                return
                }
                if (a2 > 0 && a1 < 0) {
                a2 = 0;
                        a4 = 0
                }
                if (a1 > 0 && a1 < Math.PI) {
                a1 = Math.PI;
                        a3 = Math.PI
                }
                s = {renderParams: [sr0, sr0 + 0.1 * (sr1 - sr0), a1, a2, a3, a4], x: 0, y: 0};
                        s.fillColor = this.getSmartGradient(x, y, sr0, sr1, "inside", "top");
                        return this.strokeAndPaint(this.g, x, y, s)
                };
                PieChart_Renderer_Bevel.prototype.smartInnerShineBottom = function(x, y, sr0, sr1, a1, a2, a3, a4) {
                var s;
                        if (a2 < 0 || a1 > Math.PI) {
                return
                }
                if (a1 < 0) {
                a1 = 0;
                        a3 = 0
                }
                if (a2 > Math.PI) {
                a2 = Math.PI;
                        a4 = Math.PI
                }
                s = {renderParams: [sr0, sr0 + 0.1 * (sr1 - sr0), a1, a2, a3, a4], x: 0, y: 0};
                        s.fillColor = this.getSmartGradient(x, y, sr0, sr1, "inside", "bottom");
                        return this.strokeAndPaint(this.g, x, y, s)
                };
                PieChart_Renderer_Bevel.prototype.smartGradient = function(x, y, slice) {
                var a1, a2, a3, a4, sr0, sr1;
                        x = x + slice.x;
                        y = y + slice.y;
                        sr0 = slice.renderParams[0];
                        sr1 = slice.renderParams[1];
                        a1 = slice.renderParams[2];
                        a2 = slice.renderParams[3];
                        a3 = slice.renderParams[4];
                        a4 = slice.renderParams[5];
                        this.smartOuterShineTop(x, y, sr0, sr1, a1, a2, a3, a4);
                        this.smartOuterShineBottom(x, y, sr0, sr1, a1, a2, a3, a4);
                        this.smartInnerShineTop(x, y, sr0, sr1, a1, a2, a3, a4);
                        this.smartInnerShineBottom(x, y, sr0, sr1, a1, a2, a3, a4)
                };
                return PieChart_Renderer_Bevel
        })(PieChart_Renderer_Base);
        var Linearchart_Renderer_Columns;
        Linearchart_Renderer_Columns = (function() {
        function Linearchart_Renderer_Columns(scene) {
        this.scene = scene;
                this.prevy = []
        }
        Linearchart_Renderer_Columns.prototype.paintStack = function(context, series, centers, radii, ystack, styles, zeroY) {
        var approxWidth, i, prevy, ser, style, _i, _j, _len, _ref, _results;
                this.zeroY = zeroY;
                if (!(centers.length > 0)) {
        return
        }
        prevy = this.prevy;
                if (prevy.length < centers.length) {
        prevy = this.prevy = new Array(centers.length)
        }
        for (i = _i = 0, _ref = centers.length - 1; _i <= _ref; i = _i += 1) {
        prevy[i] = zeroY
        }
        approxWidth = radii[0] + radii[radii.length - 1];
                _results = [];
                for (i = _j = 0, _len = series.length; _j < _len; i = ++_j) {
        ser = series[i];
                style = styles[i];
                if (approxWidth >= 2 || style) {
        _results.push(this.plainColumns(context, ser.style, centers, radii, prevy, ystack, style, i))
        } else {
        _results.push(this.outline(context, ser.style, centers, radii, prevy, ystack[i]))
        }
        }
        return _results
        };
                Linearchart_Renderer_Columns.prototype.outline = function(context, style, centers, radii, ybase, yvalues) {
                var i, len, prevX, x0, x1, y, y0, zeroY, _i, _ref, _results;
                        len = centers.length;
                        if (!(len > 1)) {
                return
                }
                if (style.strokeStyle) {
                context.fillStyle = style.lineColor
                } else {
                context.fillStyle = style.fillColor
                }
                zeroY = this.zeroY;
                        _results = [];
                        for (i = _i = 0, _ref = len - 1; _i <= _ref; i = _i += 1) {
                x0 = centers[i] - radii[i];
                        x1 = centers[i] + radii[i];
                        y = yvalues[i];
                        if (y !== null) {
                y0 = ybase[i];
                        y = zeroY - y;
                        context.fillRect(x0, y0, x1 - x0 + 0.5, y - y0);
                        ybase[i] = y
                }
                _results.push(prevX = x1)
                }
                return _results
                };
                Linearchart_Renderer_Columns.prototype.plainColumns = function(context, style, centers, radii, ybase, yvaluesAll, styles, yindex) {
                var bottom, center, cheight, cleft, ctop, curStyle, cwidth, depth, depthColor, fillStyle, h, i, isFirst, isLast, j, minHeight, newStyle, paintTop, r, shadowColor, strokeWidth, top, y, y0, y1, yvalues, zeroY, _i, _len, _ref, _results;
                        _ref = [this.scene.y0, this.scene.height], top = _ref[0], h = _ref[1];
                        minHeight = style.minHeight;
                        bottom = top + h;
                        zeroY = this.zeroY;
                        yvalues = yvaluesAll[yindex];
                        curStyle = null;
                        depth = style.depth;
                        shadowColor = style.shadowColor;
                        _results = [];
                        for (i = _i = 0, _len = centers.length; _i < _len; i = ++_i) {
                center = centers[i];
                        y = yvalues[i];
                        if (y === null) {
                continue
                }
                r = radii[i];
                        y0 = ybase[i];
                        y1 = zeroY - y;
                        ybase[i] = y1;
                        cleft = center - r;
                        cwidth = r + r;
                        if (y0 < y1) {
                cheight = Math.max(y1 - y0, minHeight);
                        ctop = y0;
                        isFirst = true;
                        j = yindex - 1;
                        while (j > 0) {
                if (yvaluesAll[j][i] !== null) {
                isFirst = false;
                        break
                }
                j--
                }
                paintTop = isFirst
                } else {
                cheight = Math.max(y0 - y1, minHeight);
                        ctop = y0 - cheight;
                        isLast = true;
                        j = yindex + 1;
                        while (j < yvaluesAll.length) {
                if (yvaluesAll[j][i] !== null) {
                isLast = false;
                        break
                }
                j++
                }
                paintTop = isLast
                }
                newStyle = styles ? styles[i] : style;
                        if (!newStyle) {
                newStyle = style
                }
                if (curStyle !== newStyle) {
                curStyle = newStyle;
                        if (curStyle.lineColor) {
                context.lineWidth = strokeWidth = curStyle.lineWidth;
                        context.strokeStyle = curStyle.lineColor
                } else {
                strokeWidth = 0
                }
                fillStyle = curStyle.fillColor;
                        if ((curStyle.gradient != null) && curStyle.gradient !== 1 && fillStyle) {
                fillStyle = context.createLinearGradient(0, bottom, 0, bottom - h * 2 / 3);
                        fillStyle.addColorStop(0, Base_Graphics.deriveColor(curStyle.fillColor, curStyle.gradient, 1));
                        fillStyle.addColorStop(1, curStyle.fillColor)
                }
                context.fillStyle = fillStyle;
                        if (curStyle.fillColor && depth) {
                depthColor = curStyle.fillColor;
                        if (curStyle.depthBrightness != null) {
                depthColor = Base_Graphics.deriveColor(depthColor, curStyle.depthBrightness, 1)
                }
                } else {
                depthColor = null
                }
                }
                if (depthColor) {
                context.beginPath();
                        Base_Graphics.applyShadow(context, curStyle);
                        if (!paintTop) {
                context.moveTo(cleft + cwidth, ctop);
                        context.lineTo(cleft + cwidth + depth, ctop - depth);
                        context.lineTo(cleft + cwidth + depth, ctop + cheight - depth);
                        context.lineTo(cleft + cwidth, ctop + cheight);
                        context.lineTo(cleft + cwidth, ctop)
                } else {
                context.moveTo(cleft + depth, ctop - depth);
                        context.lineTo(cleft + cwidth + depth, ctop - depth);
                        context.lineTo(cleft + cwidth + depth, ctop + cheight - depth);
                        context.lineTo(cleft + cwidth, ctop + cheight);
                        context.lineTo(cleft + cwidth, ctop);
                        context.lineTo(cleft, ctop)
                }
                context.closePath();
                        context.fillStyle = depthColor;
                        context.fill();
                        Base_Graphics.clearShadow(context);
                        context.fillStyle = fillStyle
                }
                cwidth -= strokeWidth;
                        if (cwidth > 0) {
                cheight -= strokeWidth;
                        if (cheight > 0) {
                if (!depthColor && shadowColor) {
                Base_Graphics.applyShadow(context, curStyle)
                }
                if (fillStyle) {
                context.fillRect(cleft + strokeWidth / 2, ctop + strokeWidth / 2, cwidth, cheight);
                        if (!depthColor && shadowColor) {
                Base_Graphics.clearShadow(context)
                }
                }
                if (strokeWidth > 0) {
                context.strokeRect(cleft + strokeWidth / 2, ctop + strokeWidth / 2, cwidth, cheight);
                        if (!fillStyle && !depthColor && shadowColor) {
                _results.push(Base_Graphics.clearShadow(context))
                } else {
                _results.push(void 0)
                }
                } else {
                _results.push(void 0)
                }
                } else {
                if (strokeWidth > 0) {
                context.beginPath();
                        context.moveTo(cleft + strokeWidth / 2, y0);
                        context.lineTo(cleft + strokeWidth / 2 + cwidth, y0);
                        _results.push(context.stroke())
                } else {
                _results.push(void 0)
                }
                }
                } else {
                if (strokeWidth > 0) {
                context.beginPath();
                        context.moveTo(center, ctop + strokeWidth / 2);
                        context.lineTo(center, ctop + cheight - strokeWidth);
                        _results.push(context.stroke())
                } else {
                _results.push(void 0)
                }
                }
                }
                return _results
                };
                return Linearchart_Renderer_Columns
        })();
        var Linearchart_Renderer_Line;
        Linearchart_Renderer_Line = (function() {
        function Linearchart_Renderer_Line(scene) {
        this.scene = scene;
                this.prevy = []
        }
        Linearchart_Renderer_Line.prototype.paintStack = function(context, series, centers, radii, ystack, styles, zeroY) {
        var i, j, prevSegments, prevy, segments, ser, _i, _j, _k, _len, _ref, _ref1, _ref2, _results;
                this.zeroY = zeroY;
                if (!(centers.length > 0)) {
        return
        }
        prevy = this.prevy;
                if (prevy.length < centers.length) {
        prevy = this.prevy = new Array(centers.length)
        }
        for (i = _i = 0, _ref = centers.length - 1; _i <= _ref; i = _i += 1) {
        prevy[i] = zeroY
        }
        prevSegments = null;
                _results = [];
                for (i = _j = 0, _len = series.length; _j < _len; i = ++_j) {
        ser = series[i];
                segments = this.buildLineSegments(centers, zeroY, prevy, ystack[i], ser.data.noDataPolicy);
                if (ser.style.smoothing) {
        for (j = _k = 0, _ref1 = segments.length - 1; _k <= _ref1; j = _k += 2) {
        _ref2 = this.smoothLine(segments[j], segments[j + 1], ser.style.smoothing), segments[j] = _ref2[0], segments[j + 1] = _ref2[1]
        }
        }
        this.paintLine(context, ser.style, prevSegments, segments);
                this.simpleMarkers(context, ser.style, centers, zeroY, ystack[i]);
                _results.push(prevSegments = segments)
        }
        return _results
        };
                Linearchart_Renderer_Line.prototype.paintLine = function(context, style, prevSegments, segments) {
                var i, _i, _j, _ref, _ref1;
                        if (style.fillColor) {
                if (style.shadowColor) {
                Base_Graphics.applyShadow(context, style)
                }
                context.fillStyle = style.fillColor;
                        context.beginPath();
                        for (i = _i = 0, _ref = segments.length - 1; _i <= _ref; i = _i += 2) {
                this.addArea(context, segments[i], segments[i + 1], prevSegments)
                }
                context.fill();
                        if (style.shadowColor) {
                Base_Graphics.clearShadow(context)
                }
                }
                if (style.lineColor) {
                if (!style.fillColor && style.shadowColor) {
                Base_Graphics.applyShadow(context, style)
                }
                context.strokeStyle = style.lineColor;
                        context.lineWidth = style.lineWidth;
                        context.beginPath();
                        for (i = _j = 0, _ref1 = segments.length - 1; _j <= _ref1; i = _j += 2) {
                this.addLine(context, segments[i], segments[i + 1])
                }
                context.stroke();
                        if (!style.fillColor && style.shadowColor) {
                return Base_Graphics.clearShadow(context)
                }
                }
                };
                Linearchart_Renderer_Line.prototype.addLine = function(context, xlist, ylist) {
                var i, _i, _ref, _results;
                        context.moveTo(xlist[0], ylist[0]);
                        _results = [];
                        for (i = _i = 1, _ref = xlist.length - 1; _i <= _ref; i = _i += 1) {
                _results.push(context.lineTo(xlist[i], ylist[i]))
                }
                return _results
                };
                Linearchart_Renderer_Line.prototype.addArea = function(context, xlist, ylist, previousSegments) {
                var curY, curx, i, j, l, prevY, prevx, prop, x, x0, x1, xx, y, yy, yz, _i, _j, _k, _ref, _ref1;
                        context.moveTo(xlist[0], ylist[0]);
                        for (i = _i = 1, _ref = xlist.length - 1; _i <= _ref; i = _i += 1) {
                context.lineTo(xlist[i], ylist[i])
                }
                x0 = xlist[0];
                        x1 = xlist[xlist.length - 1];
                        yz = this.zeroY;
                        x = x1;
                        if (previousSegments) {
                for (j = _j = _ref1 = previousSegments.length - 2; _j >= 0; j = _j += - 2) {
                xx = previousSegments[j];
                        yy = previousSegments[j + 1];
                        if (xx.length < 2 || xx[0] > x || xx[xx.length - 1] < x0) {
                continue
                }
                l = xx.length - 1;
                        prevx = xx[l];
                        if (prevx < x) {
                context.lineTo(x, yz);
                        context.lineTo(prevx, yz);
                        x = prevx
                }
                for (i = _k = l; _k >= 0; i = _k += - 1) {
                curx = xx[i];
                        if (x === prevx) {
                context.lineTo(prevx, yy[i + 1]);
                        x = curx
                } else {
                if (x > prevx) {
                curY = yy[i];
                        prevY = yy[i + 1];
                        prop = (x - curx) / (prevx - curx);
                        y = curY + prop * (prevY - curY);
                        context.lineTo(x, y);
                        x = curx
                }
                }
                if (x <= x0) {
                x = x0;
                        curY = yy[i];
                        prevY = yy[i + 1];
                        prop = (x - curx) / (prevx - curx);
                        y = curY + prop * (prevY - curY);
                        context.lineTo(x, y);
                        break
                }
                prevx = curx
                }
                }
                }
                if (x !== x0) {
                context.lineTo(x, yz);
                        context.lineTo(x0, yz)
                }
                return context.closePath()
                };
                Linearchart_Renderer_Line.prototype.buildLineSegments = function(centers, zeroY, prevY, newY, nodataPolicy) {
                var i, segments, x, xe, y, ye, _i, _ref;
                        segments = [];
                        xe = [];
                        ye = [];
                        for (i = _i = 0, _ref = centers.length - 1; _i <= _ref; i = _i += 1) {
                x = centers[i];
                        y = newY[i];
                        if (y !== null) {
                xe.push(x);
                        ye.push(zeroY - y)
                } else {
                if (nodataPolicy === "zero") {
                xe.push(x);
                        ye.push(prevY[i])
                } else {
                if (nodataPolicy === "join") {
                } else {
                if (xe.length > 0) {
                segments.push(xe, ye);
                        xe = [];
                        ye = []
                }
                }
                }
                }
                }
                if (xe.length > 0) {
                segments.push(xe, ye)
                }
                return segments
                };
                Linearchart_Renderer_Line.prototype.simpleMarkers = function(context, style, xlist, zeroY, ylist) {
                var fill, i, marker, r, shape, x, y, _i, _len, _results;
                        if (!(style.marker && style.marker.shape && style.marker.width)) {
                return
                }
                marker = style.marker;
                        fill = marker.fillColor;
                        if (!fill) {
                fill = style.lineColor
                }
                if (!fill) {
                fill = style.fillColor
                }
                context.fillStyle = fill;
                        r = marker.width / 2;
                        shape = marker.shape;
                        _results = [];
                        for (i = _i = 0, _len = xlist.length; _i < _len; i = ++_i) {
                x = xlist[i];
                        y = ylist[i];
                        if (y === null) {
                continue
                }
                y = zeroY - y;
                        context.beginPath();
                        Base_Graphics.strokeMarker(context, shape, x, y, r);
                        _results.push(context.fill())
                }
                return _results
                };
                Linearchart_Renderer_Line.prototype.smoothLine = function(xlist, ylist, smoothing) {
                var c, dx, i, intermediatePoints, newx, newy, pointDistance, x, x1, _i, _ref;
                        c = new Base_MonotoneCurve(xlist, ylist);
                        x = xlist[0];
                        x1 = xlist[xlist.length - 1];
                        pointDistance = (x1 - x) / xlist.length;
                        if (pointDistance < 2) {
                return[xlist, ylist]
                }
                x1 = xlist[0];
                        newx = [];
                        newy = [];
                        newx.push(x1);
                        newy.push(ylist[0]);
                        for (i = _i = 1, _ref = xlist.length - 1; _i <= _ref; i = _i += 1) {
                x = x1;
                        x1 = xlist[i];
                        pointDistance = x1 - x;
                        intermediatePoints = Math.ceil(Math.min(50, Math.max(2, pointDistance / 3)));
                        dx = pointDistance / intermediatePoints;
                        while ((x += dx) < x1) {
                newx.push(x);
                        newy.push(c.interpolate(x))
                }
                newx.push(x1);
                        newy.push(c.interpolate(x1))
                }
                return[newx, newy]
                };
                return Linearchart_Renderer_Line
        })();
        var Netchart_Scrolling;
        Netchart_Scrolling = (function() {
        function Netchart_Scrolling(chart) {
        this.chart = chart;
                this.scene = chart.scene;
                this.events = chart.events;
                this.settings = this.scene.settings;
                this.pointer1 = null;
                this.pointer2 = null;
                this.x1 = 0;
                this.y1 = 0;
                this.x2 = 0;
                this.y2 = 0;
                this.centerX = 0;
                this.centerY = 0;
                this.centerDistance = 1;
                this.numPointers = 0
        }
        Netchart_Scrolling.prototype.onWheel = function(event) {
        var zoomChange;
                if (!(this.scene.xyInChart(event.x, event.y) && this.scene.settings.interaction.zooming.wheel)) {
        return
        }
        zoomChange = Math.pow(1 + this.scene.settings.interaction.zooming.sensitivity, event.wheely * 0.004);
                this.chart.autoZoom.zoom(zoomChange, event.x, event.y);
                event.consumed = true;
                return event.changes.position = true
        };
                Netchart_Scrolling.prototype.previewPointerDown = function(event) {
                return this.numPointers += 1
                };
                Netchart_Scrolling.prototype.previewPointerUp = function(event) {
                return this.numPointers -= 1
                };
                Netchart_Scrolling.prototype.previewPointerCancel = function(event) {
                return this.numPointers -= 1
                };
                Netchart_Scrolling.prototype.onPointerDown = function(event) {
                var dx, dy, len, _ref, _ref1, _ref2;
                        if (this.pointer1 === null) {
                this.pointer1 = event.identifier;
                        _ref = [event.x, event.y], this.x1 = _ref[0], this.y1 = _ref[1];
                        if (this.settings.interaction.panning.enabled) {
                return event.consumed = true
                }
                } else {
                if (this.pointer2 === null && this.settings.interaction.zooming.fingers) {
                this.pointer2 = event.identifier;
                        _ref1 = [event.x, event.y], this.x2 = _ref1[0], this.y2 = _ref1[1];
                        _ref2 = this.scene.fromDisplay((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2), this.centerX = _ref2[0], this.centerY = _ref2[1];
                        dx = this.x1 - this.x2;
                        dy = this.y1 - this.y2;
                        len = Math.sqrt(dx * dx + dy * dy);
                        this.centerDistance = len / this.scene.zoom;
                        return event.consumed = true
                }
                }
                };
                Netchart_Scrolling.prototype.onPointerDrag = function(event) {
                if (event.identifier === this.pointer1 && this.pointer2 === null) {
                if (this.settings.interaction.panning.enabled) {
                this.scene.centerX -= event.dx / this.scene.zoom;
                        this.scene.centerY -= event.dy / this.scene.zoom;
                        this.scene.autoZoomActive = false;
                        event.changes.position = true;
                        return event.consumed = true
                }
                } else {
                if (event.identifier === this.pointer1 && this.settings.interaction.zooming.fingers) {
                this.twoFingerDrag(event.x, event.y, this.x2, this.y2);
                        event.changes.position = true;
                        return event.consumed = true
                } else {
                if (event.identifier === this.pointer2 && this.settings.interaction.zooming.fingers) {
                this.twoFingerDrag(this.x1, this.y1, event.x, event.y);
                        event.changes.position = true;
                        return event.consumed = true
                }
                }
                }
                };
                Netchart_Scrolling.prototype.onPointerUp = function(event) {
                if (this.pointer2 === event.identifier) {
                return this.pointer2 = null
                } else {
                if (this.pointer1 === event.identifier) {
                if (this.pointer2 !== null) {
                this.pointer1 = this.pointer2;
                        this.pointer2 = null;
                        this.x1 = this.x2;
                        return this.y1 = this.y2
                } else {
                return this.pointer1 = null
                }
                }
                }
                };
                Netchart_Scrolling.prototype.onPointerCancel = function(event) {
                return this.onPointerUp(event)
                };
                Netchart_Scrolling.prototype.onDoubleClick = function(event) {
                var z;
                        z = this.settings.interaction.zooming.doubleClickZoom;
                        if (z) {
                this.chart.autoZoom.zoom(z, event.x, event.y);
                        event.changes.position = true;
                        return event.consumed = true
                }
                };
                Netchart_Scrolling.prototype.twoFingerDrag = function(x1, y1, x2, y2) {
                var cx, cy, dz, newLen, sceneX, sceneY, sx1, sy1, _ref;
                        sx1 = x2 - x1;
                        sy1 = y2 - y1;
                        newLen = Math.sqrt(sx1 * sx1 + sy1 * sy1) / this.scene.zoom;
                        cx = (x2 + x1) / 2;
                        cy = (y2 + y1) / 2;
                        _ref = this.scene.fromDisplay(cx, cy), sceneX = _ref[0], sceneY = _ref[1];
                        this.scene.centerX += this.centerX - sceneX;
                        this.scene.centerY += this.centerY - sceneY;
                        dz = newLen / this.centerDistance;
                        this.chart.autoZoom.zoom(dz, cx, cy);
                        this.x1 = x1;
                        this.y1 = y1;
                        this.x2 = x2;
                        return this.y2 = y2
                };
                return Netchart_Scrolling
        })();
        var Netchart_AutoZoom;
        Netchart_AutoZoom = (function() {
        function Netchart_AutoZoom(chart) {
        this.chart = chart;
                this.scene = chart.scene;
                this.events = chart.events;
                this.settings = this.scene.settings;
                this.animatorX = new Base_Animator(0, 0, this.settings.interaction.zooming.autoZoomDuration, "=");
                this.animatorY = new Base_Animator(0, 0, this.settings.interaction.zooming.autoZoomDuration, "=");
                this.animatorZ = new Base_Animator(0, 0, this.settings.interaction.zooming.autoZoomDuration, "=");
                this.numPointers = 0;
                this.resetZoom = false
        }
        Netchart_AutoZoom.prototype.zoom = function(zoomChange, displayX, displayY) {
        var dx, dy, extents, n, newZoom, o, scx, scy, vax0, vax1, vay0, vay1, vx0, vx1, vy0, vy1, x0, x1, xx, y0, y1, yy, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
                _ref = this.scene.getVisibleBounds(), vax0 = _ref[0], vay0 = _ref[1], vax1 = _ref[2], vay1 = _ref[3];
                extents = this.settings.interaction.zooming.zoomExtent;
                if (zoomChange > 1) {
        newZoom = Math.min(extents[1], this.scene.zoom * zoomChange)
        } else {
        if (zoomChange < 1) {
        newZoom = Math.max(extents[0], this.scene.zoom * zoomChange)
        } else {
        newZoom = this.scene.zoom
        }
        }
        zoomChange = newZoom / this.scene.zoom;
                if (displayX !== void 0 && displayY !== void 0) {
        _ref1 = this.scene.fromDisplay(displayX, displayY), scx = _ref1[0], scy = _ref1[1]
        } else {
        if (this.scene.selection.length > 0) {
        xx = 0;
                yy = 0;
                n = 0;
                _ref2 = this.scene.selection;
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        o = _ref2[_i];
                if (o.isNode) {
        xx += o.x;
                yy += o.y;
                n += 1
        }
        }
        if (n > 0) {
        scx = xx / n;
                scy = yy / n
        }
        }
        }
        if (scx && scy) {
        this.scene.centerX = (this.scene.centerX - scx) / zoomChange + scx;
                this.scene.centerY = (this.scene.centerY - scy) / zoomChange + scy
        } else {
        scx = this.scene.centerX;
                scy = this.scene.centerY
        }
        this.scene.zoom *= zoomChange;
                _ref3 = this.scene.getGraphBounds(), x0 = _ref3[0], y0 = _ref3[1], x1 = _ref3[2], y1 = _ref3[3];
                _ref4 = this.scene.getVisibleBounds(), vx0 = _ref4[0], vy0 = _ref4[1], vx1 = _ref4[2], vy1 = _ref4[3];
                if (scx < x0 || scx > x1) {
        if (vx0 > x0 && vx1 > x1) {
        dx = Math.max(x1 - vx1, x0 - vx0)
        } else {
        if (vx1 < x1 && vx0 < x0) {
        dx = Math.min(x1 - vx1, x0 - vx0)
        } else {
        dx = 0
        }
        }
        this.scene.centerX += dx
        }
        if (scy < y0 || scy > y1) {
        if (vy0 > y0 && vy1 > y1) {
        dy = Math.max(y1 - vy1, y0 - vy0)
        } else {
        if (vy1 < y1 && vy0 < x0) {
        dy = Math.min(y1 - vy1, y0 - vy0)
        } else {
        dy = 0
        }
        }
        this.scene.centerY += dy
        }
        this.animatorX.jump(this.scene.centerX);
                this.animatorY.jump(this.scene.centerY);
                this.animatorZ.jump(this.scene.zoom);
                return this.scene.autoZoomActive = false
        };
                Netchart_AutoZoom.prototype.previewPointerDown = function() {
                return this.numPointers += 1
                };
                Netchart_AutoZoom.prototype.previewPointerUp = function() {
                return this.numPointers -= 1
                };
                Netchart_AutoZoom.prototype.previewPointerCancel = function() {
                return this.numPointers -= 1
                };
                Netchart_AutoZoom.prototype.doAnimations = function(event) {
                var autoZoomLowerTreshold, autoZoomTreshold, autoZoomUpperTreshold, cx, cy, height, time, width, xDiff, yDiff, z, zoomDiff, _ref;
                        if (event.changes.settings && Base_Helpers.hasProp(event, "changes/settingsChanges/interaction/zooming")) {
                this.scene.autoZoomActive = this.scene.settings.interaction.zooming.autoZoom
                }
                if (this.resetZoom || event.changes.newGraph) {
                this.resetZoom = false;
                        return this.zoomToFit()
                } else {
                if (this.scene.autoZoomActive && this.numPointers === 0 && this.scene.nodes().length > 0) {
                time = event.time;
                        _ref = this.computeFitParams(), cx = _ref[0], cy = _ref[1], z = _ref[2];
                        autoZoomTreshold = 0.01;
                        autoZoomUpperTreshold = 1 + autoZoomTreshold;
                        autoZoomLowerTreshold = 1 - autoZoomTreshold;
                        zoomDiff = this.animatorZ.to / z;
                        if (zoomDiff > autoZoomUpperTreshold || zoomDiff < autoZoomLowerTreshold) {
                this.animatorZ.retargetColor(z)
                }
                width = this.scene.width;
                        xDiff = (this.animatorX.to - cx) * z / width;
                        if (xDiff > autoZoomTreshold || xDiff < - autoZoomTreshold) {
                this.animatorX.retargetColor(cx);
                        event.changes.positon = true
                }
                height = this.scene.height;
                        yDiff = (this.animatorY.to - cy) * z / height;
                        if (yDiff > autoZoomTreshold || yDiff < - autoZoomTreshold) {
                this.animatorY.retargetColor(cy);
                        event.changes.positon = true
                }
                this.scene.centerX = this.animatorX.get(time);
                        this.scene.centerY = this.animatorY.get(time);
                        this.scene.zoom = this.animatorZ.get(time);
                        if (!(this.animatorX.finished(time)) || !(this.animatorY.finished(time)) || !(this.animatorZ.finished(time))) {
                return event.animating = true
                }
                } else {
                this.animatorX.jump(this.scene.centerX);
                        this.animatorY.jump(this.scene.centerY);
                        return this.animatorZ.jump(this.scene.zoom)
                }
                }
                };
                Netchart_AutoZoom.prototype.zoomToFit = function() {
                var _ref;
                        _ref = this.computeFitParams(true), this.scene.centerX = _ref[0], this.scene.centerY = _ref[1], this.scene.zoom = _ref[2];
                        this.animatorX.jump(this.scene.centerX);
                        this.animatorY.jump(this.scene.centerY);
                        this.animatorZ.jump(this.scene.zoom);
                        return false
                };
                Netchart_AutoZoom.prototype.computeFitParams = function(reset) {
                var cx, cy, dx, dy, extents, h, sx0, sx1, sy0, sy1, visibleBottom, visibleLeft, visibleRight, visibleTop, w, x0, x1, y0, y1, zoom, _ref;
                        if (reset == null) {
                reset = false
                }
                _ref = this.scene.getGraphBounds(), x0 = _ref[0], y0 = _ref[1], x1 = _ref[2], y1 = _ref[3];
                        if (x0 === x1 && y0 === y1) {
                x0 = 0;
                        x1 = 1;
                        y0 = 0;
                        y1 = 1
                }
                w = this.scene.width;
                        h = this.scene.height;
                        sx0 = this.scene.settings.area.paddingLeft;
                        sx1 = this.scene.settings.area.paddingRight;
                        sy0 = this.scene.settings.area.paddingTop;
                        sy1 = this.scene.settings.area.paddingBottom;
                        if (sx0 <= 1) {
                sx0 = w * sx0
                }
                if (sx1 <= 1) {
                sx1 = w * (1 - sx1)
                } else {
                sx1 = w - sx1
                }
                if (sy0 <= 1) {
                sy0 = h * sy0
                }
                if (sy1 <= 1) {
                sy1 = h * (1 - sy1)
                } else {
                sy1 = h - sy1
                }
                zoom = Math.min((sx1 - sx0) / (x1 - x0), (sy1 - sy0) / (y1 - y0));
                        extents = this.scene.settings.interaction.zooming.zoomExtent;
                        zoom = Math.min(extents[1], zoom);
                        if (reset) {
                cx = (x0 + x1) / 2 - w * (this.scene.settings.area.centerX - 0.5) / zoom;
                        cy = (y0 + y1) / 2 - h * (this.scene.settings.area.centerY - 0.5) / zoom
                } else {
                cx = this.scene.centerX;
                        cy = this.scene.centerY
                }
                visibleLeft = cx + (sx0 - w / 2) / zoom;
                        visibleRight = cx + (sx1 - w / 2) / zoom;
                        visibleTop = cy + (sy0 - h / 2) / zoom;
                        visibleBottom = cy + (sy1 - h / 2) / zoom;
                        dx = - Math.max(0, visibleLeft - x0) + Math.max(0, x1 - visibleRight);
                        dy = - Math.max(0, visibleTop - y0) + Math.max(0, y1 - visibleBottom);
                        cx += dx;
                        cy += dy;
                        zoom *= this.scene.settings.interaction.zooming.autoZoomSize;
                        return[cx, cy, zoom]
                };
                return Netchart_AutoZoom
        })();
        var Base_Helpers, lastTime, requestAnimationFrame, __hasProp = {}.hasOwnProperty, __slice = [].slice;
        if (typeof String.prototype.trim === "undefined") {
String.prototype.trim = function() {
return this.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
        }
}
if (!window.requestAnimationFrame) {
requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame;
        if (!requestAnimationFrame) {
lastTime = 0;
        requestAnimationFrame = function(callback) {
        var currTime, id, timeToCall;
                currTime = new Date().getTime();
                timeToCall = Math.max(0, 16 - (currTime - lastTime));
                id = window.setTimeout(function() {
                return callback(currTime + timeToCall)
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id
        }
}
window.requestAnimationFrame = requestAnimationFrame
        }
Base_Helpers = (function() {
function Base_Helpers() {
}
Base_Helpers.prototype.baseCSSClass = "DWSL";
        Base_Helpers.extend = function(object, other) {
        var key, val;
                if (object == null) {
        return{}
        }
        for (key in other) {
        if (!__hasProp.call(other, key)) {
            continue
        }
            val = other[key];
            object[key] = val;
        }
        return object
        };
        Base_Helpers.extend1 = function(object, other) {
        var key, val;
        
        if (object == null) {
            return{}
        }

                
        for (key in other) {
            if (!__hasProp.call(other, key)) {
                continue
            }
            val = other[key];
            
            
//            if (object.id == 6)    {   
//                console.log(" BEFORE I AM OBJECT " + object.id  + "! key:" +key + " object[key]: " + object[key] + " val:" + val);    
//            }
            
            
            if (typeof object[key] == "undefined") {
                object[key] = new Array(); 
            }

            object[key].push(val);
            
            
//                        if (object.id == 6)    {   
//                console.log(" AFTRE I AM OBJECT " + object.id  + "! key:" +key + " object[key]: " + object[key] + " val:" + val);    
//            }
            
        }
        
        return object
        };
        
        Base_Helpers.extendDeep = function(object, other) {
        var key, val, valBefore;
                if (object == null) {
        return other
        }
        for (key in other) {
        if (!__hasProp.call(other, key)) {
        continue
        }
        val = other[key];
                valBefore = object[key];
                if (Base_Helpers.isObject(valBefore) && Base_Helpers.isObject(val)) {
        this.extendDeep(valBefore, val)
        } else {
        object[key] = val
        }
        }
        return object
        };
        Base_Helpers.configure = function(object, defaults) {
        var v;
                for (v in defaults) {
        if (typeof object[v] === "undefined" && defaults[v]) {
        object[v] = defaults[v]
        }
        }
        return object
        };
        Base_Helpers.clone = function(obj) {
        var key, r, val;
                r = {};
                for (key in obj) {
        if (!__hasProp.call(obj, key)) {
        continue
        }
        val = obj[key];
                r[key] = val
        }
        return r
        };
        Base_Helpers.isArray = function(source) {
        return source instanceof Array
        };
        Base_Helpers.isObject = function(source) {
        return source !== null && typeof source === "object"
        };
        Base_Helpers.isFunction = function(source) {
        return typeof source === "function"
        };
        Base_Helpers.isNumber = function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n)
        };
        Base_Helpers.isString = function(source) {
        return Object.prototype.toString.call(source) === "[object String]"
        };
        Base_Helpers.hasProperties = function(o) {
        var k, v;
                if (!o) {
        return false
        }
        for (k in o) {
        if (!__hasProp.call(o, k)) {
        continue
        }
        v = o[k];
                return true
        }
        return false
        };
        Base_Helpers.removeProperty = function(o) {
        var k, v;
                for (k in o) {
        if (!__hasProp.call(o, k)) {
        continue
        }
        v = o[k];
                delete o[k];
                return k
        }
        return null
        };
        Base_Helpers.removePropertyValue = function(o) {
        var k, v;
                for (k in o) {
        if (!__hasProp.call(o, k)) {
        continue
        }
        v = o[k];
                delete o[k];
                return[k, v]
        }
        return null
        };
        Base_Helpers.countProperties = function(o) {
        var c, k, v;
                c = 0;
                for (k in o) {
        if (!__hasProp.call(o, k)) {
        continue
        }
        v = o[k];
                c += 1
        }
        return c
        };
        Base_Helpers.realClone = function(source) {
        var a, d, k, o, v, _i, _len;
                o = this.isObject(source);
                a = this.isArray(source);
                if (a) {
        d = [];
                for (k = _i = 0, _len = source.length; _i < _len; k = ++_i) {
        v = source[k];
                if (typeof v !== "function") {
        d[k] = this.realClone(v)
        } else {
        d[k] = v
        }
        }
        } else {
        if (o) {
        d = {};
                for (k in source) {
        v = source[k];
                if (typeof v !== "function") {
        d[k] = this.realClone(v)
        } else {
        d[k] = v
        }
        }
        } else {
        d = source
        }
        }
        return d
        };
        Base_Helpers.arrayContains = function(arr, item) {
        var i, _i, _len;
                for (_i = 0, _len = arr.length; _i < _len; _i++) {
        i = arr[_i];
                if (i === item) {
        return true
        }
        }
        return false
        };
        Base_Helpers.removeFromArray = function(arr, item) {
        var i, removed, v;
                removed = false;
                for (i in arr) {
        v = arr[i];
                if (v === item) {
        arr.splice(i, 1);
                removed = true
        }
        }
        return removed
        };
        Base_Helpers.arraysEqual = function(arr1, arr2) {
        var i, _i, _ref;
                if (!((arr1 != null) && (arr2 != null))) {
        return false
        }
        if (arr1.length !== arr2.length) {
        return false
        }
        for (i = _i = 0, _ref = arr1.length - 1; _i <= _ref; i = _i += 1) {
        if (arr1[i] !== arr2[i]) {
        return false
        }
        }
        return true
        };
        Base_Helpers.log = function(message, arg) {
        if (typeof console !== "undefined" && console !== null) {
        if (arg != null) {
        return console.info(message, arg)
        } else {
        return console.info(message)
        }
        }
        };
        Base_Helpers.error = function(message, arg) {
        if (typeof console !== "undefined" && console !== null) {
        if (arg != null) {
        return console.error(message, arg)
        } else {
        return console.error(message)
        }
        }
        };
        Base_Helpers.getExtension = function(name) {
        var re;
                re = /(?:\.([^.]+))?$/;
                return re.exec(name)[1]
        };
        Base_Helpers.createDom = function(tagName, cl, innerHtml, container) {
        var el;
                el = document.createElement(tagName);
                if (cl != null) {
        el.className = cl
        }
        if (innerHtml != null) {
        el.innerHTML = innerHtml
        }
        if (container != null) {
        container.appendChild(el)
        }
        return el
        };
        Base_Helpers.createStyledDom = function(tagName, style, innerHtml, container) {
        var el, k, v;
                el = document.createElement(tagName);
                if (style != null) {
        for (k in style) {
        if (!__hasProp.call(style, k)) {
        continue
        }
        v = style[k];
                el.style[k] = v
        }
        }
        if (innerHtml != null) {
        el.innerHTML = innerHtml
        }
        if (container != null) {
        container.appendChild(el)
        }
        return el
        };
        Base_Helpers.hasClass = function(el, name) {
        return(el.className.length > 0) && new RegExp("(^|\\s)" + name + "(\\s|$)").test(el.className)
        };
        Base_Helpers.addClass = function(el, name) {
        if (!Base_Helpers.hasClass(el, name)) {
        if (el.className.length === 0) {
        return el.className = name
        } else {
        return el.className = el.className + " " + name
        }
        }
        };
        Base_Helpers.removeClass = function(el, name) {
        var replaceFn;
                replaceFn = function(w, match) {
                if (match === name) {
                return""
                } else {
                return w
                }
                };
                return el.className = el.className.replace(/(\S+)\s*/g, replaceFn).replace(/(^\s+|\s+$)/, "")
        };
        Base_Helpers.setClass = function(el, name) {
        return el.className = name
        };
        Base_Helpers.listen = function(node, event, fn) {
        if (node.addEventListener) {
        return node.addEventListener(event, fn)
        } else {
        return node.attachEvent("on" + event, fn)
        }
        };
        Base_Helpers.unlisten = function(node, event, fn) {
        if (node.removeEventListener) {
        return node.removeEventListener(event, fn)
        } else {
        return node.detachEvent("on" + event, fn)
        }
        };
        Base_Helpers.createEvent = function(type) {
        var event;
                if (document.createEvent) {
        event = document.createEvent("Event");
                event.initEvent(type, true, true)
        } else {
        event = document.createEventObject()
        }
        return event
        };
        Base_Helpers.canvasScaling = function() {
        var r;
                r = 1;
                if (window.devicePixelRatio) {
        r = window.devicePixelRatio
        } else {
        if (window.screen.systemXDPI) {
        r = window.screen.systemXDPI / window.screen.logicalXDPI
        }
        }
        return[r, r]
        };
        Base_Helpers.elementPos = function(obj) {
        var curLeft, curTop;
                curLeft = 0;
                curTop = 0;
                while (obj.offsetParent != null) {
        curLeft += obj.offsetLeft;
                curTop += obj.offsetTop;
                obj = obj.offsetParent
        }
        return[curLeft, curTop]
        };
        Base_Helpers.isParentOf = function(parent, child) {
        while (child != null) {
        if (child === parent) {
        return true
        }
        child = child.parentElement
        }
        return false
        };
        Base_Helpers.fadeIn = function(dom) {
        return dom.style.display = "block"
        };
        Base_Helpers.fadeOut = function(dom) {
        return dom.style.display = "none"
        };
        Base_Helpers.hide = function(dom) {
        return dom.style.display = "none"
        };
        Base_Helpers.show = function(dom) {
        return dom.style.display = "block"
        };
        Base_Helpers.wrapClass = function(base, c) {
        var o, x, y, _i, _len;
                if (!this.baseCSSClass) {
        this.baseCSSClass = "DVSL"
        }
        if (!base) {
        base = this.baseCSSClass
        }
        if (typeof base === "object") {
        if (base.objClass) {
        base = base.objClass
        } else {
        base = this.baseCSSClass
        }
        }
        x = c.split(",");
                o = "";
                for (_i = 0, _len = x.length; _i < _len; _i++) {
        y = x[_i];
                if (o) {
        o += " "
        }
        o += base + "-" + y
        }
        return o
        };
        Base_Helpers.getProp = function(obj, route) {
        var part, _i, _len, _ref;
                _ref = route.split("/");
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
                if (obj.hasOwnProperty(part)) {
        obj = obj[part]
        } else {
        return void 0
        }
        }
        return obj
        };
        Base_Helpers.hasProp = function(obj, route) {
        var part, _i, _len, _ref;
                _ref = route.split("/");
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
                if (obj.hasOwnProperty(part)) {
        obj = obj[part]
        } else {
        return false
        }
        }
        return obj !== void 0
        };
        Base_Helpers.getScroll = function() {
        var body, doc, left, top;
                doc = document.documentElement;
                body = document.body;
                left = doc && doc.scrollLeft || body && body.scrollLeft || 0;
                top = doc && doc.scrollTop || body && body.scrollTop || 0;
                return[left, top]
        };
        Base_Helpers.isWithIn = function(dot, box) {
        if (dot[0] < box[0] || dot[0] > box[2] || dot[1] < box[1] || dot[1] > box[3]) {
        return true
        } else {
        return false
        }
        };
        Base_Helpers.mixIn = function(target, src) {
        var k, v, _ref, _results;
                _ref = src.prototype;
                _results = [];
                for (k in _ref) {
        v = _ref[k];
                _results.push(target[k] = v)
        }
        return _results
        };
        Base_Helpers.sign = function(x) {
        if (!x) {
        return 0
        }
        if (x < 0) {
        return - 1
        }
        return 1
        };
        Base_Helpers.each = function() {
        var args, k, key, method, results, v, _i, _len, _ref, _ref1;
                key = arguments[0], method = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
                results = [];
                if (Base_Helpers.isArray(this[key])) {
        _ref = this[key];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
                if (v[method] != null) {
        results.push(v[method].apply(v, args))
        } else {
        console.error(v);
                throw"Object " + v + "does not have method: " + method
        }
        }
        } else {
        if (Base_Helpers.isObject(this[key])) {
        _ref1 = this[key];
                for (k in _ref1) {
        v = _ref1[k];
                if (v[method] != null) {
        results.push(v[method].apply(v, args))
        } else {
        console.error(v);
                throw"Object " + v + "does not have method " + method
        }
        }
        } else {
        console.error(key, method, args);
                throw"Called iterator each on non-object/non-array"
        }
        }
        return results
        };
        Base_Helpers.detectBrowser = function() {
        var m, n, tem, ua;
                n = navigator.appName;
                ua = navigator.userAgent;
                m = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
                if (m && (tem = ua.match(/version\/([\.\d]+)/i)) !== null) {
        m[2] = tem[1]
        }
        if (m) {
        m = [m[1], m[2]]
        } else {
        m = [n, navigator.appVersion, "-?"]
        }
        return m[0].toLowerCase()
        };
        Base_Helpers.nextIdentifier = 0;
        Base_Helpers.getIdentifier = function() {
        return Base_Helpers.nextIdentifier++
        };
        Base_Helpers.doRequest = function(url, params, success, fail) {
        var o, p, req, _i, _len;
                o = [];
                for (_i = 0, _len = params.length; _i < _len; _i++) {
        p = params[_i];
                o.push("" + (encodeURIComponent(p[0])) + "=" + (encodeURIComponent(p[1])))
        }
        o = o.join("&");
                if (url.indexOf("?") !== - 1) {
        url += "&" + o
        } else {
        url += "?" + o
        }
        if (window.XMLHttpRequest) {
        req = new XMLHttpRequest()
        } else {
        if (window.ActiveXObject) {
        req = new ActiveXObject("Microsoft.XMLHTTP")
        }
        }
        if (req) {
        req.onreadystatechange = (function(_this) {
        return function() {
        if (req.readyState === 4) {
        if (req.status === 200) {
        return success(req.responseText)
        } else {
        return fail()
        }
        }
        }
        })(this);
                req.open("GET", url, true);
                return req.send("")
        }
        };
        Base_Helpers.openUrl = function(url) {
        if (Base_Helpers.isString(url)) {
        return window.open(url)
        } else {
        return window.open(url.url, url.name, url.specs, url.replace)
        }
        };
        Base_Helpers.parseData = function(text, format, chart) {
        var data, error;
                data = null;
                if (format === "JSON") {
        if (typeof text === "string" || text instanceof String) {
        try {
        data = JSON.parse(text)
        } catch (_error) {
        error = _error;
                chart.error("Error: failed to parse JSON response: " + error + ": " + text);
                data = {error: "Error: failed to parse JSON response"}
        }
        } else {
        data = text
        }
        } else {
        chart.error("Unsupported data format: " + format)
        }
        return data
        };
        Base_Helpers.numberFormat = function(n, decPlaces, decSeparator, thouSeparator) {
        var i, j, sign;
                n = parseFloat(n);
                decPlaces = isNaN(decPlaces = Math.abs(decPlaces)) ? 2 : decPlaces;
                decSeparator = decSeparator === void 0 ? "." : decSeparator;
                thouSeparator = thouSeparator === void 0 ? " " : thouSeparator;
                sign = n < 0 ? "-" : "";
                i = parseInt(n = Math.abs( + n || 0).toFixed(decPlaces)) + "";
                j = (j = i.length) > 3 ? j % 3 : 0;
                return sign + (j ? i.substr(0, j) + thouSeparator : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + thouSeparator) + (decPlaces ? decSeparator + Math.abs(n - i).toFixed(decPlaces).slice(2) : "")
        };
        Base_Helpers.buildImage = function(src, onLoad) {
        var image;
                image = new Image();
                image.onload = function() {
                return onLoad(image)
                };
                image.src = src;
                if (image.complete) {
        onLoad(image)
        }
        return image
        };
        return Base_Helpers
        })();
        var Timechart_Data;
        Timechart_Data = (function() {
        var RequestData, TimeData;
                TimeData = (function() {
                TimeData.prototype.unit = "m";
                        TimeData.prototype.from = 0;
                        TimeData.prototype.to = 1000;
                        TimeData.prototype.values = null;
                        function TimeData(unit, from, to, values) {
                        this.unit = unit;
                                this.from = from;
                                this.to = to;
                                this.values = values
                        }
                TimeData.prototype.merge = function(newData, maxCount, events, append) {
                var addAfter, addBefore, from, toAdd, v;
                        if (!append && (this.from > newData.to || this.to < newData.from)) {
                this.values = newData.values;
                        this.from = newData.from;
                        this.to = newData.to;
                        return
                }
                if (newData.values.length > 0 && newData.from > newData.values[0][0]) {
                events.error("Data merge - oldest data before from")
                }
                if (newData.values.length > 0 && newData.to < newData.values[newData.values.length - 1][0]) {
                events.error("Data merge - newest data after to")
                }
                addBefore = 0;
                        while (addBefore < this.values.length && this.values[addBefore][0] < newData.from) {
                addBefore += 1
                }
                addAfter = this.values.length;
                        while (addAfter > 0 && this.values[addAfter - 1][0] >= newData.to) {
                addAfter -= 1
                }
                v = newData.values;
                        this.from = Math.min(this.from, newData.from);
                        this.to = Math.max(this.to, newData.to);
                        if (addBefore > 0) {
                from = Math.max(0, v.length + addBefore - maxCount);
                        v = this.values.slice(from, + (addBefore - 1) + 1 || 9000000000).concat(v);
                        if (from > 0) {
                this.from = this.values[from - 1][0] + 1
                }
                }
                if (addAfter < this.values.length) {
                toAdd = this.values.length - addAfter;
                        toAdd = Math.min(toAdd, maxCount - v.length);
                        v = v.concat(this.values.slice(addAfter, + (addAfter + toAdd) + 1 || 9000000000));
                        if (toAdd < this.values.length - addAfter) {
                this.to = this.values[addAfter + toAdd][0]
                }
                }
                return this.values = v
                };
                        return TimeData
                })();
                RequestData = (function() {
                RequestData.prototype.from = null;
                        RequestData.prototype.to = null;
                        RequestData.prototype.time = 0;
                        RequestData.prototype.unit = "y";
                        RequestData.prototype.callback = null;
                        function RequestData(unit, from, to, callback, time) {
                        this.unit = unit;
                                this.from = from;
                                this.to = to;
                                this.callback = callback;
                                this.time = time;
                                true
                        }
                return RequestData
                })();
                Timechart_Data.prototype.chart = null;
                Timechart_Data.prototype.scene = null;
                Timechart_Data.prototype.settings = null;
                Timechart_Data.prototype.noData = false;
                Timechart_Data.prototype.dataLimitFrom = null;
                Timechart_Data.prototype.dataLimitTo = null;
                Timechart_Data.prototype.dataFrom = null;
                Timechart_Data.prototype.dataTo = null;
                Timechart_Data.prototype.dataLimitFromUnit = null;
                Timechart_Data.prototype.dataLimitToUnit = null;
                Timechart_Data.prototype.cache = null;
                Timechart_Data.prototype.requests = {};
                function Timechart_Data(chart, settings) {
                this.chart = chart;
                        this.settings = settings;
                        this.scene = this.chart.scene;
                        this.cache = {};
                        this.requests = {};
                        this.updataDataLimit(null, null, this.settings.limitStart, this.settings.limitEnd, new Base_TimeStep("ms", 1));
                        if (this.settings.preloaded != null) {
                this.addData(new RequestData(this.settings.preloaded.unit, null, null, null, 0), this.settings.preloaded)
                }
                }
        Timechart_Data.prototype.remove = function() {
        var r, u, _ref, _results;
                this.scene.setMessage(this, null);
                _ref = this.requests;
                _results = [];
                for (u in _ref) {
        r = _ref[u];
                if (r) {
        _results.push(r.callback = null)
        } else {
        _results.push(void 0)
        }
        }
        return _results
        };
                Timechart_Data.prototype.determineDataLimits = function(unit, needFrom, needTo, callback) {
                var from, fromData, step, t, to, toData;
                        if (unit == null) {
                unit = "y"
                }
                while (unit != null) {
                if (Base_Helpers.arrayContains(this.settings.units, unit)) {
                break
                }
                unit = Base_TimeStep.toSmallerUnit[unit]
                }
                if (unit == null) {
                this.chart.error("Cannot load data - no suitable data unit configured")
                }
                step = new Base_TimeStep(unit, 1);
                        from = null;
                        to = null;
                        t = step.approxTime();
                        if ((this.dataLimitFromUnit != null) && this.dataLimitFromUnit.approxTime() <= t) {
                from = this.dataLimitFrom
                }
                if ((this.dataLimitToUnit != null) && this.dataLimitToUnit.approxTime() <= t) {
                to = this.dataLimitTo
                }
                if ((!needFrom || (from != null)) && (!needTo || (to != null))) {
                callback(this.dataLimitFrom, this.dataLimitTo, unit);
                        return
                }
                this.scene.setMessage(this, "Determining data bounds", 999);
                        toData = (function(_this) {
                        return function(f0, t0, from, to, unit) {
                        if (!unit) {
                        _this.scene.setMessage(_this, null);
                                return
                        }
                        if (!((_this.dataLimitTo != null) || !needTo)) {
                        if (t0 !== to) {
                        _this.scheduleDataLoading(unit, to, null, false, function(a, b, c) {
                        return toData(f0, to, a, b, c)
                        });
                                return
                        } else {
                        _this.dataLimitTo = to
                        }
                        }
                        return fromData(f0 + 1, f0, to, unit)
                        }
                        })(this);
                        fromData = (function(_this) {
                        return function(f0, from, to, unit) {
                        if (!unit) {
                        _this.scene.setMessage(_this, null);
                                return
                        }
                        if (!((_this.dataLimitFrom != null) || !needFrom)) {
                        if (f0 !== from) {
                        _this.scheduleDataLoading(unit, null, from, false, function(a, b, c) {
                        return fromData(from, a, b, c)
                        });
                                return
                        } else {
                        _this.dataLimitFrom = from
                        }
                        }
                        _this.scene.setMessage(_this, null);
                                return callback(_this.dataLimitFrom, _this.dataLimitTo, unit)
                        }
                        })(this);
                        return this.scheduleDataLoading(unit, null, null, false, (function(_this) {
                        return function(a, b, c) {
                        return toData(a, b - 1, a, b, c)
                        }
                        })(this))
                };
                Timechart_Data.prototype.getDataForRange = function(from, to, step, callback) {
                var data, endIndex, increasingDirection, loadFrom, loadTo, loadUnit, loadingNeeded, loadingStarted, resultFrom, resultTo, resultUnit, startIndex, _ref;
                        resultUnit = step.unit;
                        resultFrom = null;
                        resultTo = null;
                        while (resultUnit) {
                if (this.cache.hasOwnProperty(resultUnit)) {
                data = this.cache[resultUnit];
                        if (data !== null && data.from < to && data.to > from) {
                resultFrom = data.from;
                        resultTo = data.to;
                        data = data.values;
                        loadingNeeded = from < resultFrom || to > resultTo;
                        break
                }
                }
                resultUnit = Base_TimeStep.toSmallerUnit[resultUnit]
                }
                if (resultUnit === null) {
                loadingNeeded = true
                }
                loadingStarted = false;
                        if (loadingNeeded) {
                loadingNeeded &= (this.settings.dataFunction != null) || (this.settings.url != null) || (this.settings.urlByUnit != null);
                        loadFrom = from;
                        loadTo = to;
                        if (this.dataLimitFrom != null) {
                loadFrom = Math.max(this.dataLimitFrom, loadFrom)
                }
                if (this.dataLimitTo != null) {
                loadTo = Math.min(this.dataLimitTo, loadTo)
                }
                increasingDirection = false;
                        if (loadFrom >= resultFrom) {
                increasingDirection = true;
                        loadFrom = Math.max(loadFrom, resultTo)
                }
                if (loadTo <= resultTo) {
                loadTo = Math.min(loadTo, resultFrom)
                }
                loadingNeeded &= loadFrom < loadTo;
                        if (loadingNeeded && (!this.settings.minimizeRequests || !this.chart.scrolling.isActive())) {
                loadUnit = step.unit;
                        while (loadUnit != null) {
                if (Base_Helpers.arrayContains(this.settings.units, loadUnit) && this.cache[loadUnit] !== null) {
                loadingStarted = this.scheduleDataLoading(loadUnit, loadFrom, loadTo, increasingDirection, callback);
                        break
                }
                loadUnit = Base_TimeStep.toSmallerUnit[loadUnit]
                }
                }
                }
                if (resultUnit) {
                _ref = Timechart_Data.findSubrange(data, from, to), startIndex = _ref[0], endIndex = _ref[1];
                        return{unit: step.unit, count: step.count, from: resultFrom, to: resultTo, values: data, startIndex: startIndex, endIndex: endIndex, loading: loadingStarted}
                } else {
                if (loadingStarted) {
                return{unit: step.unit, count: step.count, from: resultFrom, to: resultTo, values: [], startIndex: 0, endIndex: 0, loading: true}
                } else {
                return{unit: null, count: null, from: null, to: null, values: [], startIndex: 0, endIndex: 0, loading: false}
                }
                }
                };
                Timechart_Data.prototype.updateData = function(dataUnit, newTo, callback) {
                var requestFrom, requestTo, u;
                        while (dataUnit != null) {
                if (Base_Helpers.arrayContains(this.settings.units, dataUnit)) {
                break
                }
                dataUnit = Base_TimeStep.toSmallerUnit[dataUnit]
                }
                if (!(this.cache.hasOwnProperty(dataUnit) && !this.requests[dataUnit])) {
                return
                }
                u = new Base_TimeStep(dataUnit, 1);
                        requestTo = u.roundTimeUp(newTo);
                        requestFrom = u.roundTimeDown(this.cache[dataUnit].from);
                        if (requestFrom <= requestTo) {
                return this.scheduleDataLoading(dataUnit, requestFrom, requestTo, true, callback)
                }
                };
                Timechart_Data.prototype.scheduleDataLoading = function(unit, from0, to0, isIncreasing, callback) {
                var bigFrom, bigTo, biggerUnit, df, fl, from, r, response, succ, time, timeUnitsAsked, to, u;
                        if (!unit) {
                throw"No unit"
                }
                this.chart.log("Scheduling data loading" + unit + "," + from0 + "," + to0);
                        time = new Date().getTime();
                        if (this.requests.hasOwnProperty(unit) && (this.requests[unit] != null)) {
                r = this.requests[unit];
                        if (r.time + this.settings.requestTimeout < time) {
                r.callback = null;
                        this.requests[unit] = null
                } else {
                this.chart.log("Already loading for selected period");
                        return true
                }
                }
                from = from0;
                        to = to0;
                        u = new Base_TimeStep(unit, 1);
                        if (from != null) {
                from = u.roundTimeDown(from)
                }
                if (to != null) {
                to = u.roundTimeUp(to)
                }
                if ((from != null) && (to != null)) {
                timeUnitsAsked = (to - from) / u.approxTime();
                        if (timeUnitsAsked > this.settings.requestMaxUnits) {
                if (isIncreasing) {
                to = u.add(from, this.settings.requestMaxUnits)
                } else {
                from = u.sub(to, this.settings.requestMaxUnits)
                }
                }
                }
                biggerUnit = this.getBiggerDataUnit(unit);
                        if (biggerUnit != null) {
                u = new Base_TimeStep(biggerUnit, 1);
                        if (from != null) {
                bigFrom = u.roundTimeDown(from);
                        if ((this.dataLimitFrom != null) && bigFrom <= this.dataLimitFrom) {
                from = this.dataLimitFrom
                }
                }
                if (to != null) {
                bigTo = u.roundTimeUp(to);
                        if ((this.dataLimitTo != null) && bigTo >= this.dataLimitTo) {
                to = this.dataLimitTo
                }
                }
                }
                r = new RequestData(unit, from, to, callback, time);
                        if (df = this.getDataFunction()) {
                succ = (function(_this) {
                return function(data) {
                return _this.dataRecievedRaw(r, data)
                }
                })(this);
                        fl = (function(_this) {
                        return function() {
                        return _this.dataFailed(r)
                        }
                        })(this);
                        this.requests[unit] = r;
                        if (this.settings.timestampInSeconds) {
                if (from != null) {
                from = from / 1000
                }
                if (to != null) {
                to = to / 1000
                }
                }
                response = df(from, to, unit, succ, fl);
                        this.chart.log("Data requested " + unit + ", " + from + ", " + to);
                        if ((response != null) && (Base_Helpers.isObject(response) || Base_Helpers.isString(response))) {
                this.dataRecievedRaw(r, response)
                }
                return true
                } else {
                this.chart.log("No data function. Cannot load data?");
                        return false
                }
                };
                Timechart_Data.prototype.dataRecievedRaw = function(request, data) {
                this.scene.setMessage("data", null);
                        this.requests[request.unit] = null;
                        return this.dataArrived(request, data)
                };
                Timechart_Data.prototype.dataArrived = function(request, rawData) {
                var data;
                        this.chart.log("Data arrived");
                        data = Base_Helpers.parseData(rawData, this.settings.format, this.chart);
                        return this.addData(request, data)
                };
                Timechart_Data.prototype.addData = function(request, parsedData, append) {
                var data, newData;
                        if (append == null) {
                append = false
                }
                if (parsedData === null) {
                return
                }
                this.cleanupData(parsedData);
                        if (parsedData.error) {
                if (parsedData.error === "no-unit" && request) {
                this.cache[request.unit] = null
                }
                this.chart.error(parsedData.errormessage ? parsedData.errormessage : parsedData.error);
                        return
                }
                if (request) {
                newData = this.analyzeData(parsedData, request)
                } else {
                newData = this.analyzeDataNoRequest(parsedData)
                }
                if (request && Base_TimeStep.timeUnitDiffs[newData.unit] > Base_TimeStep.timeUnitDiffs[request.unit]) {
                this.chart.error("Incorrect data - requested unit " + request.unit + ", got bigger unit - " + newData.unit);
                        this.cache[request.unit] = null;
                        if (request.callback != null) {
                return request.callback(null, null, null)
                }
                } else {
                if (request && (newData.unit !== request.unit)) {
                this.cache[request.unit] = null
                }
                if (newData.unit && (newData.from != null) && (newData.to != null)) {
                data = this.cache[newData.unit];
                        if (data != null) {
                this.cache[newData.unit].merge(newData, this.settings.cacheSize, this.chart, append)
                } else {
                this.cache[newData.unit] = newData
                }
                }
                if (request && (request.callback != null)) {
                return request.callback(newData.from, newData.to, newData.unit)
                }
                }
                };
                Timechart_Data.prototype.dataFailed = function(request) {
                if (this.cache[request.unit] == null) {
                this.cache[request.unit] = null
                }
                this.scene.setMessage("data", "Data request failed", 1000);
                        this.chart.error("Failed data loading request");
                        if (request.callback != null) {
                return request.callback(null, null, null)
                }
                };
                Timechart_Data.prototype.updataDataLimit = function(dataFrom, dataTo, limitFrom, limitTo, unit) {
                if (dataFrom != null) {
                if (this.dataFrom === null || this.dataFrom > dataFrom) {
                this.dataFrom = dataFrom
                }
                }
                if (dataTo != null) {
                if (this.dataTo === null || this.dataTo < dataTo) {
                this.dataTo = dataTo
                }
                }
                if (limitFrom != null) {
                this.dataLimitFrom = limitFrom;
                        this.dataLimitFromUnit = unit;
                        this.dataFrom = Math.max(this.dataFrom, limitFrom)
                }
                if (limitTo != null) {
                this.dataLimitTo = limitTo;
                        this.dataLimitToUnit = unit;
                        return this.dataTo = Math.min(this.dataTo, limitTo)
                }
                };
                Timechart_Data.prototype.cleanupData = function(data) {
                var a, dataFrom, dataTo, goodValues, i, prop, required, step, v, v1, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3;
                        if (data.error) {
                return
                }
                data.error = "bad-response";
                        if ((data.data != null) && (data.values == null)) {
                data.values = data.data
                }
                _ref = ["unit", "values"];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                required = _ref[_i];
                        if (!data.hasOwnProperty(required)) {
                data.errormessage = "Required field '" + required + "' not set in data";
                        return
                }
                }
                step = Base_TimeStep.parse(data.unit);
                        if (step === null) {
                data.errormessage = "Data error: unrecognized data unit: " + data.unit;
                        return
                }
                _ref1 = ["form", "to", "dataLimitForm", "dataLimitTo"];
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                prop = _ref1[_j];
                        if (data.hasOwnProperty(prop)) {
                v = data[prop];
                        if (v === null) {
                delete data[prop]
                } else {
                v1 = data[prop] = parseInt(v);
                        if (!Base_Helpers.isNumber(v1)) {
                data.errormessage = "Field " + prop + " needs to be an integer";
                        return
                }
                }
                }
                }
                data.error = null;
                        if ((data.from != null) && (data.to != null) && data.from >= data.to) {
                this.chart.error("Data logic error. from >= to: " + data.from + ", " + data.to);
                        delete data.from;
                        delete data.to
                }
                if ((data.dataLimitFrom != null) && (data.dataLimitTo != null) && data.dataLimitFrom >= data.dataLimitTo) {
                this.chart.error("Data logic error. dataLimitFrom >= dataLimitTo: " + data.dataLimitFrom + ", " + data.dataLimitTo);
                        delete data.dataLimitFrom;
                        delete data.dataLimitTo
                }
                if (data.values.length > 0) {
                goodValues = [];
                        _ref2 = data.values;
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                v = _ref2[_k];
                        if (!Base_Helpers.isArray(v)) {
                this.chart.error("Data error: expected values to contain array, got " + v)
                } else {
                v[0] = parseFloat(v[0]);
                        if (!Base_Helpers.isNumber(v[0])) {
                this.chart.error("Data error: time value not a number: " + v[0])
                } else {
                for (i = _l = 0, _len3 = v.length; _l < _len3; i = ++_l) {
                a = v[i];
                        if (a !== null) {
                v[i] = parseFloat(a);
                        if (!Base_Helpers.isNumber(v[i])) {
                this.chart.error("Data error: series value not a number or null: " + v[i]);
                        v[i] = null
                }
                }
                }
                goodValues.push(v)
                }
                }
                }
                data.values = goodValues;
                        if (this.settings.timestampInSeconds) {
                _ref3 = data.values;
                        for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
                v = _ref3[_m];
                        v[0] *= 1000
                }
                }
                data.values.sort(function(a, b) {
                return a[0] - b[0]
                });
                        dataFrom = data.values[0][0];
                        dataTo = data.values[data.values.length - 1][0]
                }
                if (this.settings.timestampInSeconds) {
                if (data.from) {
                data.from *= 1000
                }
                if (data.to) {
                data.to *= 1000
                }
                if (data.dataLimitFrom) {
                data.dataLimitFrom *= 1000
                }
                if (data.dataLimitTo) {
                data.dataLimitTo *= 1000
                }
                }
                if ((data.from != null) && dataFrom < data.from) {
                this.chart.error("Data logic error. Data time " + dataFrom + " outside [from, to) range: " + data.from + ", " + data.to);
                        data.from = dataFrom
                }
                if ((data.to != null) && dataTo >= data.to) {
                this.chart.error("Data logic error. Data time " + dataTo + " outside [from, to) range: " + data.from + ", " + data.to);
                        data.to = dataTo + 1
                }
                };
                Timechart_Data.prototype.analyzeDataNoRequest = function(data) {
                var dataFrom, dataTo, from, r, step, to;
                        if (!(data.from != null) && (data.dataLimitFrom != null)) {
                data.from = data.dataLimitFrom
                }
                if (!(data.to != null) && (data.dataLimitTo != null)) {
                data.to = data.dataLimitTo
                }
                from = data.from;
                        to = data.to;
                        step = Base_TimeStep.parse(data.unit);
                        if (data.values.length > 0) {
                dataFrom = data.values[0][0];
                        dataTo = data.values[data.values.length - 1][0];
                        dataFrom = step.roundTimeDown(dataFrom);
                        dataTo = step.roundTimeUp(dataTo + 1);
                        if (from == null) {
                from = dataFrom
                }
                if (to == null) {
                to = dataTo
                }
                }
                this.updataDataLimit(dataFrom, dataTo, data.dataLimitFrom, data.dataLimitTo, step);
                        r = new TimeData(data.unit, from, to, data.values);
                        if (data.error != null) {
                r.error = data.error
                }
                return r
                };
                Timechart_Data.prototype.analyzeData = function(data, request) {
                var dataFrom, dataTo, from, r, rdf, rdt, step, to;
                        if ((request.from == null) && (data.from == null) && (data.dataLimitFrom != null)) {
                data.from = data.dataLimitFrom
                }
                if ((request.to == null) && (data.to == null) && (data.dataLimitTo != null)) {
                data.to = data.dataLimitTo
                }
                from = data.from;
                        to = data.to;
                        dataFrom = null;
                        dataTo = null;
                        if ((from != null) && (to != null) && from >= to) {
                this.chart.error("Data logic error. from >= to: " + from + ", " + to)
                }
                step = Base_TimeStep.parse(data.unit);
                        if (data.values.length > 0) {
                dataFrom = data.values[0][0];
                        dataTo = data.values[data.values.length - 1][0];
                        dataFrom = step.roundTimeDown(dataFrom);
                        dataTo = step.roundTimeUp(dataTo + 1);
                        if (from == null) {
                if (request.from != null) {
                from = Math.min(request.from, dataFrom)
                } else {
                from = dataFrom
                }
                }
                if (to == null) {
                if (request.to != null) {
                to = Math.max(request.to, dataTo)
                } else {
                to = dataTo
                }
                }
                } else {
                if (from == null) {
                from = request.from
                }
                if (to == null) {
                to = request.to
                }
                if ((data.from != null) && (data.to != null)) {
                dataFrom = data.from;
                        dataTo = data.to
                } else {
                dataFrom = request.to;
                        dataTo = request.from;
                        if (request.from === null && request.to === null && (from == null) && (to == null) && (data.dataLimitFrom == null) && (data.dataLimitTo == null)) {
                this.noData = true;
                        data.dataLimitFrom = 0;
                        data.dataLimitTo = 0;
                        data.from = 0;
                        data.to = 0
                }
                }
                }
                this.updataDataLimit(dataFrom, dataTo, data.dataLimitFrom, data.dataLimitTo, step);
                        if ((request.from != null) && (data.to != null)) {
                rdt = step.roundTimeDown(data.to);
                        if (rdt <= request.from) {
                this.updataDataLimit(null, null, null, data.to, step)
                }
                }
                if ((request.to != null) && (data.from != null)) {
                rdf = step.roundTimeUp(data.from);
                        if (rdf >= request.to) {
                this.updataDataLimit(null, null, data.from, null, step)
                }
                }
                if (!((data.from != null) || (data.dataLimitFrom != null))) {
                if (((this.dataLimitFrom != null) && (request.from === null || (request.from <= this.dataLimitFrom && dataFrom > this.dataLimitFrom))) || ((this.dataLimitFrom == null) && (request.from == null))) {
                this.updataDataLimit(null, null, dataFrom, null, step);
                        from = dataFrom
                }
                }
                if (!((data.to != null) || (data.dataLimitTo != null))) {
                if (((this.dataLimitTo != null) && (request.to === null || (request.to >= this.dataLimitTo && dataTo < this.dataLimitTo))) || ((this.dataLimitTo == null) && (request.to == null))) {
                this.updataDataLimit(null, null, null, dataTo, step);
                        to = dataTo
                }
                }
                r = new TimeData(data.unit, from, to, data.values);
                        if (data.error != null) {
                r.error = data.error
                }
                return r
                };
                Timechart_Data.prototype.getBiggerDataUnit = function(unit) {
                var units;
                        while (unit != null) {
                unit = Base_TimeStep.toBiggerUnit[unit];
                        units = this.settings.units;
                        if (Base_Helpers.arrayContains(units, unit)) {
                return unit
                }
                }
                return null
                };
                Timechart_Data.binSearch = function(data, timestamp) {
                var i0, i1, ii;
                        i0 = 0;
                        if (!data) {
                throw"no data"
                }
                i1 = data.length - 1;
                        while (i0 < i1) {
                ii = ((i1 + i0) / 2) | 0;
                        if (data[ii][0] < timestamp) {
                i0 = ii + 1
                } else {
                if (data[ii][0] > timestamp) {
                i1 = ii
                } else {
                while (ii > 0 && data[ii - 1][0] === timestamp) {
                ii -= 1
                }
                return ii
                }
                }
                }
                if (i0 < data.length && data[i0][0] < timestamp) {
                return i0 + 1
                } else {
                return i0
                }
                };
                Timechart_Data.linSearchUp = function(data, start, dataIndex) {
                var i, _i, _ref, _ref1;
                        for (i = _i = _ref = start + 1, _ref1 = data.length - 1; _i <= _ref1; i = _i += 1) {
                if (data[i][dataIndex] !== null) {
                return i
                }
                }
                return - 1
                };
                Timechart_Data.linSearchDown = function(data, start, dataIndex) {
                var i, _i, _ref;
                        for (i = _i = _ref = start - 1; _i >= 0; i = _i += - 1) {
                if (data[i][dataIndex] !== null) {
                return i
                }
                }
                return - 1
                };
                Timechart_Data.findSubrange = function(data, from, to) {
                var i0, i1;
                        i0 = Timechart_Data.binSearch(data, from);
                        i1 = Timechart_Data.binSearch(data, to);
                        return[i0, i1]
                };
                Timechart_Data.prototype.getDataFunction = function() {
                var config;
                        config = this.settings;
                        if (config.dataFunction) {
                return config.dataFunction
                } else {
                if (config.url || Base_Helpers.hasProperties(config.urlByUnit)) {
                return function(from, to, step, success, fail) {
                var url;
                        if (Base_Helpers.hasProperties(config.urlByUnit)) {
                url = config.urlByUnit[step];
                        if (!url) {
                return'{"error":"no-unit", "errormessage":"no data url for this time unit: ' + step + '"}'
                }
                } else {
                url = config.url
                }
                return Timechart_Data.defaultDataFunction(from, to, step, success, fail, url)
                }
                } else {
                return null
                }
                }
                };
                Timechart_Data.defaultDataFunction = function(from, to, step, success, fail, url) {
                var params;
                        if (!url) {
                throw"No data URL"
                }
                if (!step) {
                throw"No step"
                }
                params = [];
                        if (from != null) {
                params.push(["from", from])
                }
                if (to != null) {
                params.push(["to", to])
                }
                params.push(["unit", step]);
                        return Base_Helpers.doRequest(url, params, success, fail)
                };
                return Timechart_Data
        })();
        var Piechart_Layers;
        Piechart_Layers = (function() {
        Piechart_Layers.prototype.scene = null;
                Piechart_Layers.prototype.container = null;
                Piechart_Layers.prototype.background = null;
                Piechart_Layers.prototype.canvas = null;
                Piechart_Layers.prototype.outerBorder = null;
                Piechart_Layers.prototype.mouseTrackLayer = null;
                function Piechart_Layers(chart) {
                this.chart = chart;
                        this.scene = chart.scene;
                        this.container = Base_Helpers.createDom("div", "DVSL-container");
                        this.container.style.position = "relative";
                        this.container.style.width = "100%";
                        this.container.style.height = "100%";
                        this.background = Base_Helpers.createDom("div", "DVSL-background", null, this.container);
                        this.setContainerStyle(this.background);
                        this.canvas = Base_Helpers.createDom("canvas", "DVSL-canvas", null, this.container);
                        this.setContainerStyle(this.canvas);
                        this.outerBorder = Base_Helpers.createDom("div", "DVSL-border", null, this.container);
                        this.setContainerStyle(this.outerBorder);
                        this.resizerBar = Base_Helpers.createDom("div", "DVSL-resizer", null, this.container);
                        this.mouseTrackLayer = Base_Helpers.createDom("div", null, null, this.container);
                        this.setContainerStyle(this.mouseTrackLayer);
                        this.updateSettings(this.scene.settings, "init");
                        this.updateSize()
                }
        Piechart_Layers.prototype.updateSize = function() {
        var setHeight, setWidth;
                setWidth = this.scene.settings.width;
                setHeight = this.scene.settings.height;
                if (this.scene.chartWidth > this.scene.settings.container.clientWidth && this.container && this.container.style.display !== "") {
        setWidth = this.scene.chartWidth
        }
        if (this.scene.chartHeight > this.scene.settings.container.clientHeight && this.container && this.container.style.display !== "") {
        setHeight = this.scene.chartHeight
        }
        if (setWidth) {
        this.container.style.width = "" + setWidth + "px"
        }
        if (setHeight) {
        this.container.style.height = "" + setHeight + "px"
        }
        this.resizerBar.style.width = "" + this.scene.width + "px";
                return this.resizerBar.style.left = "" + this.scene.x0 + "px"
        };
                Piechart_Layers.prototype.updateSettings = function(changes) {
                if (Base_Helpers.hasProp(changes, "advanced/themeCSSClass")) {
                if (this.curTheme != null) {
                Base_Helpers.removeClass(this.container, this.curTheme)
                }
                this.curTheme = this.scene.settings.advanced.themeCSSClass;
                        return Base_Helpers.addClass(this.container, this.curTheme)
                }
                };
                Piechart_Layers.prototype.setContainerStyle = function(c) {
                c.style.position = "absolute";
                        c.style.left = "0px";
                        c.style.right = "0px";
                        c.style.top = "0px";
                        return c.style.bottom = "0px"
                };
                return Piechart_Layers
        })();
        var Base_Scene;
        Base_Scene = (function() {
        Base_Scene.prototype.chartWidth = 1;
                Base_Scene.prototype.chartHeight = 1;
                Base_Scene.prototype.toolbarHeight = 0;
                Base_Scene.prototype.x0 = 0;
                Base_Scene.prototype.y0 = 0;
                Base_Scene.prototype.height = 100;
                Base_Scene.prototype.width = 100;
                Base_Scene.prototype.leftMargin = 0;
                Base_Scene.prototype.rightMargin = 0;
                Base_Scene.prototype.topMargin = 0;
                Base_Scene.prototype.bottomMargin = 0;
                Base_Scene.prototype.canvasScaleX = 1;
                Base_Scene.prototype.canvasScaleY = 1;
                Base_Scene.prototype.settings = null;
                Base_Scene.prototype.loading = true;
                function Base_Scene() {
                this.messages = {};
                        this.backStack = []
                }
        Base_Scene.prototype.getChartBounds = function() {
        return{left: this.x0 - this.leftMargin, top: this.y0 - this.topMargin, right: this.x0 + this.width + this.rightMargin, bottom: this.y0 + this.height + this.bottomMargin}
        };
                Base_Scene.prototype.setMessage = function(origin, msg, pri) {
                var changed;
                        if (msg != null) {
                changed = (this.messages[origin] == null) || this.messages[origin].msg !== msg || this.messages[origin].pri !== pri;
                        this.messages[origin] = {msg: msg, pri: pri}
                } else {
                changed = this.messages[origin] != null;
                        delete this.messages[origin]
                }
                return changed
                };
                Base_Scene.prototype.getMessage = function() {
                var k, m, mm, pri, _ref;
                        m = null;
                        pri = 0;
                        _ref = this.messages;
                        for (k in _ref) {
                mm = _ref[k];
                        if (mm.pri > pri) {
                m = mm.msg;
                        pri = mm.pri
                }
                }
                return m
                };
                Base_Scene.prototype.pushBack = function(state) {
                this.backStack.push(state);
                        if (this.backStack.length > 1000) {
                return this.backStack = this.backStack.slice(200)
                }
                };
                return Base_Scene
        })();
        var Base_MouseEvent, Base_MouseEvents, Base_MousePointer, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        }, __hasProp = {}.hasOwnProperty;
        Base_MouseEvent = (function() {
        Base_MouseEvent.prototype.time = 0;
                Base_MouseEvent.prototype.changes = {};
                Base_MouseEvent.prototype.consumed = false;
                Base_MouseEvent.prototype.defaultPrevented = false;
                Base_MouseEvent.prototype.preventDefault = function() {
                return this.defaultPrevented = true
                };
                Base_MouseEvent.prototype.x = 0;
                Base_MouseEvent.prototype.y = 0;
                Base_MouseEvent.prototype.dx = 0;
                Base_MouseEvent.prototype.dy = 0;
                Base_MouseEvent.prototype.vx = 0;
                Base_MouseEvent.prototype.vy = 0;
                Base_MouseEvent.prototype.wheely = 0;
                Base_MouseEvent.prototype.wheelx = 0;
                Base_MouseEvent.prototype.identifier = 0;
                Base_MouseEvent.prototype.pressed = false;
                Base_MouseEvent.prototype.consumed = false;
                Base_MouseEvent.prototype.touch = false;
                Base_MouseEvent.prototype.swipeUp = false;
                Base_MouseEvent.prototype.swipeDown = false;
                Base_MouseEvent.prototype.swipeLeft = false;
                Base_MouseEvent.prototype.swipeRight = false;
                function Base_MouseEvent(x, y, time, identifier) {
                this.x = x;
                        this.y = y;
                        this.time = time;
                        this.identifier = identifier;
                        1
                }
        Base_MouseEvent.prototype.distance = function(p) {
        return Math.sqrt((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y))
        };
                return Base_MouseEvent
        })();
        Base_MousePointer = (function() {
        function Base_MousePointer(event, settings) {
        this.settings = settings;
                this.identifier = event.identifier;
                this.x = event.x;
                this.y = event.y;
                this.pageX = event.pageX;
                this.pageY = event.pageY;
                this.time = event.time;
                this.pts = [[this.x, this.y, this.time]]
        }
        Base_MousePointer.prototype.moveTo = function(e) {
        if (e.time === this.time) {
        this.pts.pop()
        }
        this.time = e.time;
                if (e.x || e.y) {
        this.x = e.x;
                this.y = e.y
        }
        this.pts.push([this.x, this.y, this.time]);
                if (this.pts.length > 6) {
        return this.pts.unshift()
        }
        };
                Base_MousePointer.prototype.getPosAndSpeed = function(e, isUp) {
                var dt, fraction, fromI, i, lastI, smallestDt, vx, vy, _i, _j, _k;
                        e.x = this.x;
                        e.y = this.y;
                        lastI = this.pts.length - 2;
                        if (lastI >= 0) {
                e.dx = this.pts[lastI + 1][0] - this.pts[lastI][0];
                        e.dy = this.pts[lastI + 1][1] - this.pts[lastI][1]
                } else {
                e.dx = 0;
                        e.dy = 0
                }
                smallestDt = Infinity;
                        for (i = _i = 0; _i <= lastI; i = _i += 1) {
                dt = this.pts[i + 1][2] - this.pts[i][2];
                        smallestDt = Math.min(smallestDt, this.pts[i + 1][2] - this.pts[i][2])
                }
                smallestDt = Math.max(smallestDt, 20);
                        fromI = - 1;
                        for (i = _j = lastI; _j >= 0; i = _j += - 1) {
                dt = this.pts[i + 1][2] - this.pts[i][2];
                        if (dt > smallestDt * 2) {
                break
                }
                fromI = i
                }
                if (fromI === - 1) {
                e.vx = 0;
                        e.vy = 0;
                        return
                }
                vx = 0;
                        vy = 0;
                        fraction = 1;
                        for (i = _k = fromI; _k <= lastI; i = _k += 1) {
                dt = this.pts[i + 1][2] - this.pts[i][2];
                        vx = vx * (1 - fraction) + (this.pts[i + 1][0] - this.pts[i][0]) / dt * fraction;
                        vy = vx * (1 - fraction) + (this.pts[i + 1][1] - this.pts[i][1]) / dt * fraction;
                        fraction = 0.6
                }
                e.vx = vx * 1000;
                        return e.vy = vy * 1000
                };
                return Base_MousePointer
        })();
        Base_MouseEvents = (function() {
        Base_MouseEvents.prototype.ID_MOUSE = "mouse";
                Base_MouseEvents.prototype.EVENT_MOVE = "move";
                Base_MouseEvents.prototype.EVENT_DOWN = "down";
                Base_MouseEvents.prototype.EVENT_DRAG = "drag";
                Base_MouseEvents.prototype.EVENT_CANCEL = "cancel";
                Base_MouseEvents.prototype.EVENT_UP = "up";
                Base_MouseEvents.prototype.EVENT_LEAVE = "leave";
                Base_MouseEvents.prototype.EVENT_CLICK = "click";
                Base_MouseEvents.prototype.EVENT_RCLICK = "rclick";
                Base_MouseEvents.prototype.EVENT_DBLCLICK = "dblclick";
                Base_MouseEvents.prototype.EVENT_WHEEL = "mwheel";
                Base_MouseEvents.prototype.scaleX = 1;
                Base_MouseEvents.prototype.scaleY = 1;
                Base_MouseEvents.prototype.mm = 1;
                Base_MouseEvents.prototype.clickEvent = null;
                Base_MouseEvents.prototype.longPressTimeout = null;
                Base_MouseEvents.prototype.cachedContainerPosition = null;
                function Base_MouseEvents(container, settings) {
                this.container = container;
                        this.settings = settings;
                        this.handleTouchMove = __bind(this.handleTouchMove, this);
                        this.handleTouchCancel = __bind(this.handleTouchCancel, this);
                        this.handleTouchEnd = __bind(this.handleTouchEnd, this);
                        this.handleTouchStart = __bind(this.handleTouchStart, this);
                        this.handleMouseMove = __bind(this.handleMouseMove, this);
                        this.handleMouseUp = __bind(this.handleMouseUp, this);
                        this.handleMouseWheel = __bind(this.handleMouseWheel, this);
                        this.handleCMenu = __bind(this.handleCMenu, this);
                        this.handleMouseDown = __bind(this.handleMouseDown, this);
                        this.updateContainerPosition = __bind(this.updateContainerPosition, this);
                        this.listeners = {};
                        this.downPointers = {};
                        this.inPointers = {};
                        this.whiteList = [this.container];
                        Base_Helpers.listen(this.container, "mousedown", this.handleMouseDown);
                        Base_Helpers.listen(this.container, "contextmenu", this.handleCMenu);
                        Base_Helpers.listen(this.container, "mousewheel", this.handleMouseWheel);
                        Base_Helpers.listen(this.container, "DOMMouseScroll", this.handleMouseWheel);
                        Base_Helpers.listen(this.container, "touchstart", this.handleTouchStart);
                        Base_Helpers.listen(window, "mouseup", this.handleMouseUp);
                        Base_Helpers.listen(window, "mousemove", this.handleMouseMove);
                        Base_Helpers.listen(window, "touchend", this.handleTouchEnd);
                        Base_Helpers.listen(window, "touchcancel", this.handleTouchCancel);
                        Base_Helpers.listen(window, "touchmove", this.handleTouchMove);
                        Base_Helpers.listen(window, "resize", this.updateContainerPosition)
                }
        Base_MouseEvents.prototype.addWhiteList = function(item) {
        this.whiteList.push(item);
                Base_Helpers.listen(item, "mousedown", this.handleMouseDown);
                Base_Helpers.listen(item, "mousewheel", this.handleMouseWheel);
                Base_Helpers.listen(item, "DOMMouseScroll", this.handleMouseWheel);
                return Base_Helpers.listen(item, "touchstart", this.handleTouchStart)
        };
                Base_MouseEvents.prototype.remove = function() {
                var k, v, _i, _len, _ref;
                        Base_Helpers.unlisten(this.container, "mousedown", this.handleMouseDown);
                        Base_Helpers.unlisten(this.container, "contextmenu", this.handleCMenu);
                        Base_Helpers.unlisten(this.container, "mousewheel", this.handleMouseWheel);
                        Base_Helpers.unlisten(this.container, "DOMMouseScroll", this.handleMouseWheel);
                        Base_Helpers.unlisten(this.container, "touchstart", this.handleTouchStart);
                        if (this.whiteList != null) {
                _ref = this.whiteList;
                        for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
                v = _ref[k];
                        Base_Helpers.unlisten(v, "mousedown", this.handleMouseDown);
                        Base_Helpers.unlisten(v, "mousewheel", this.handleMouseWheel);
                        Base_Helpers.unlisten(v, "DOMMouseScroll", this.handleMouseWheel);
                        Base_Helpers.unlisten(v, "touchstart", this.handleTouchStart)
                }
                }
                Base_Helpers.unlisten(window, "mouseup", this.handleMouseUp);
                        Base_Helpers.unlisten(window, "mousemove", this.handleMouseMove);
                        Base_Helpers.unlisten(window, "touchend", this.handleTouchEnd);
                        Base_Helpers.unlisten(window, "touchcancel", this.handleTouchCancel);
                        return Base_Helpers.unlisten(window, "touchmove", this.handleTouchMove)
                };
                Base_MouseEvents.prototype.listen = function(eventName, func) {
                return this.listeners[eventName] = func
                };
                Base_MouseEvents.prototype.getContainerPosition = function() {
                var p;
                        if (this.cachedContainerPosition != null) {
                return this.cachedContainerPosition
                } else {
                p = Base_Helpers.elementPos(this.container);
                        this.cachedContainerPosition = p;
                        return p
                }
                };
                Base_MouseEvents.prototype.updateContainerPosition = function() {
                return this.cachedContainerPosition = null
                };
                Base_MouseEvents.prototype.handleMouseDown = function(event) {
                var e;
                        e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
                        this.downHappened(e, false);
                        if (e.consumed) {
                event.preventDefault();
                        return event.stopPropagation()
                }
                };
                Base_MouseEvents.prototype.handleCMenu = function(event) {
                var e, isRightMB, k, p, _ref;
                        if (event.which) {
                isRightMB = event.which === 3
                } else {
                isRightMB = event.button === 2
                }
                if (isRightMB) {
                e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
                        _ref = this.downPointers;
                        for (k in _ref) {
                if (!__hasProp.call(_ref, k)) {
                continue
                }
                p = _ref[k];
                        e = this.rebuildEvent(event, p, false);
                        this.cancelHappened(e)
                }
                this.rclickHappened(e);
                        if (e.consumed) {
                event.preventDefault();
                        return event.stopPropagation()
                }
                }
                };
                Base_MouseEvents.prototype.handleMouseWheel = function(event) {
                var e;
                        e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
                        e.wheely = event.wheelDelta | (event.detail * - 40);
                        this.wheelHappened(e);
                        if (e.consumed) {
                event.preventDefault();
                        return event.stopPropagation()
                }
                };
                Base_MouseEvents.prototype.handleMouseUp = function(event) {
                var e, removeAll;
                        if (event.shiftKey && event.ctrlKey) {
                this.ID_MOUSE = "mouse" + this.mm;
                        this.mm += 1;
                        return
                } else {
                removeAll = true
                }
                e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, false);
                        e.isRightMB = event.witch ? event.which === 3 : event.button === 2;
                        this.upHappened(e);
                        if (e.consumed) {
                event.preventDefault();
                        event.stopPropagation()
                }
                if (removeAll) {
                return this.removeLostTouches(event, [], [])
                }
                };
                Base_MouseEvents.prototype.handleMouseMove = function(event) {
                var e;
                        e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, false);
                        this.moveHappened(e);
                        if (e.consumed) {
                event.preventDefault();
                        return event.stopPropagation()
                }
                };
                Base_MouseEvents.prototype.handleTouchStart = function(event) {
                var consumed, e, list, t, _i, _len;
                        if (!this.isTargetOkay(event.target)) {
                return
                }
                this.removeLostTouches(event, event.touches, event.changedTouches);
                        consumed = false;
                        list = event.changedTouches || event.touches;
                        for (_i = 0, _len = list.length; _i < _len; _i++) {
                t = list[_i];
                        e = this.buildEvent(t, t.identifier, event.timeStamp, true);
                        this.downHappened(e, true);
                        consumed || (consumed = e.consumed)
                }
                if (consumed) {
                event.preventDefault();
                        return event.stopPropagation()
                }
                };
                Base_MouseEvents.prototype.handleTouchEnd = function(event) {
                var consumed, e, list, t, _i, _len;
                        list = event.changedTouches || event.touches;
                        consumed = false;
                        for (_i = 0, _len = list.length; _i < _len; _i++) {
                t = list[_i];
                        e = this.buildEvent(t, t.identifier, event.timeStamp, false);
                        this.upHappened(e);
                        this.pointerLeave(e);
                        consumed || (consumed = e.consumed);
                        this.removeLostTouches(event, event.touches)
                }
                if (consumed) {
                event.preventDefault();
                        return event.stopPropagation()
                }
                };
                Base_MouseEvents.prototype.handleTouchCancel = function(event) {
                var e, list, t, _i, _len;
                        list = event.changedTouches || event.touches;
                        for (_i = 0, _len = list.length; _i < _len; _i++) {
                t = list[_i];
                        e = this.buildEvent(t, t.identifier, event.timeStamp, false);
                        this.cancelHappened(e)
                }
                return this.removeLostTouches(event, event.touches)
                };
                Base_MouseEvents.prototype.handleTouchMove = function(event) {
                var consumed, e, list, t, _i, _len;
                        consumed = false;
                        this.removeLostTouches(event, event.touches);
                        list = event.changedTouches || event.touches;
                        for (_i = 0, _len = list.length; _i < _len; _i++) {
                t = list[_i];
                        e = this.buildEvent(t, t.identifier, event.timeStamp, true);
                        this.moveHappened(e);
                        consumed || (consumed = e.consumed)
                }
                if (consumed) {
                event.preventDefault();
                        return event.stopPropagation()
                }
                };
                Base_MouseEvents.prototype.removeLostTouches = function(event, touches, freshTouches) {
                var e, k, p, presentTouches, t, _i, _j, _len, _len1, _ref, _results;
                        presentTouches = [];
                        for (_i = 0, _len = touches.length; _i < _len; _i++) {
                t = touches[_i];
                        presentTouches[t.identifier] = true
                }
                _ref = this.downPointers;
                        for (k in _ref) {
                if (!__hasProp.call(_ref, k)) {
                continue
                }
                p = _ref[k];
                        if (!presentTouches[k]) {
                e = this.rebuildEvent(event, p, false);
                        this.upHappened(e)
                }
                }
                if (freshTouches != null) {
                _results = [];
                        for (_j = 0, _len1 = freshTouches.length; _j < _len1; _j++) {
                t = freshTouches[_j];
                        p = this.downPointers[t.identifier];
                        if (p != null) {
                console.log("Removing fresh touch " + t.identifier);
                        e = this.rebuildEvent(event, p, false);
                        _results.push(this.upHappened(e))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                }
                };
                Base_MouseEvents.prototype.rebuildEvent = function(event, obj, pressed) {
                var e;
                        e = new Base_MouseEvent(obj.x, obj.y, event.timeStamp, obj.identifier);
                        e.pageX = obj.pageX;
                        e.pageY = obj.pageY;
                        e.pressed = pressed;
                        e.shiftKey = event.shiftKey;
                        e.altKey = event.altKey;
                        e.ctrlKey = event.ctrlKey;
                        return e
                };
                Base_MouseEvents.prototype.buildEvent = function(event, id, timestamp, pressed) {
                var dx, dy, e, x, y, _ref;
                        _ref = this.getContainerPosition(), dx = _ref[0], dy = _ref[1];
                        x = event.pageX - dx;
                        y = event.pageY - dy;
                        e = new Base_MouseEvent(Math.round(x * this.scaleX), Math.round(y * this.scaleY), timestamp, id);
                        e.target = event.target;
                        e.pageX = event.pageX;
                        e.pageY = event.pageY;
                        e.shiftKey = event.shiftKey;
                        e.altKey = event.altKey;
                        e.ctrlKey = event.ctrlKey;
                        e.pressed = pressed;
                        return e
                };
                Base_MouseEvents.prototype.downHappened = function(e, isTouch) {
                var p;
                        if (!this.isTargetOkay(e.target)) {
                return
                }
                e.pressed = true;
                        if (this.downPointers[e.identifier] != null) {
                console.log("Unexpected down on already down pointer");
                        return
                }
                this.downPointers[e.identifier] = p = new Base_MousePointer(e, this.settings);
                        p.touch = isTouch;
                        this.inPointers[e.identifier] = true;
                        this.fireEvent(this.EVENT_DOWN, e);
                        if (isTouch) {
                return this.startLongPress(e)
                }
                };
                Base_MouseEvents.prototype.upHappened = function(e) {
                var fireClick, p;
                        this.cachedContainerPosition = null;
                        if (this.downPointers[e.identifier] == null) {
                return false
                }
                p = this.downPointers[e.identifier];
                        this.cancelLongPress(e);
                        p.moveTo(e);
                        p.getPosAndSpeed(e, true);
                        delete this.downPointers[e.identifier];
                        if (Math.abs(e.vx) > Math.abs(e.vy) * 2) {
                e.swipeSpeed = Math.abs(e.vx);
                        if (e.vx > 0) {
                e.swipeLeft = true
                }
                if (e.vx < 0) {
                e.swipeRight = true
                }
                } else {
                if (Math.abs(e.vy) > Math.abs(e.vx) * 2) {
                e.swipeSpeed = Math.abs(e.vy);
                        if (e.vy < 0) {
                e.swipeUp = true
                }
                if (e.vy > 0) {
                e.swipeDown = true
                }
                }
                }
                this.fireEvent(this.EVENT_UP, e);
                        if (!(p.scrolling || e.isRightMB || e.consumed)) {
                if ((this.clickEvent != null) && this.clickEvent.time + this.settings.doubleClickTimeout >= e.time && this.clickEvent.distance(e) < this.settings.doubleClickSensitivity) {
                this.clickEvent = null;
                        return this.fireEvent(this.EVENT_DBLCLICK, e)
                } else {
                if (this.settings.noClickOnDoubleClick) {
                this.clickEvent = e;
                        fireClick = (function(_this) {
                        return function() {
                        if (_this.clickEvent === e) {
                        _this.fireEvent(_this.EVENT_CLICK, _this.clickEvent);
                                return _this.clickEvent = null
                        }
                        }
                        })(this);
                        return setTimeout(fireClick, this.settings.doubleClickTimeout)
                } else {
                this.fireEvent(this.EVENT_CLICK, e);
                        return this.clickEvent = e
                }
                }
                }
                };
                Base_MouseEvents.prototype.cancelHappened = function(e) {
                var p;
                        this.cachedContainerPosition = null;
                        if (this.downPointers[e.identifier] == null) {
                return
                }
                this.cancelLongPress(e);
                        p = this.downPointers[e.identifier];
                        delete this.downPointers[e.identifier];
                        return this.fireEvent(this.EVENT_CANCEL, e)
                };
                Base_MouseEvents.prototype.moveHappened = function(e) {
                var p;
                        p = this.downPointers[e.identifier];
                        e.pressed = p != null;
                        if (p != null) {
                if (e.distance(p) >= this.settings.dragSensitivity || p.scrolling) {
                this.cancelLongPress(e);
                        p.scrolling = true;
                        p.moveTo(e);
                        p.getPosAndSpeed(e, false);
                        return this.fireEvent(this.EVENT_DRAG, e)
                }
                } else {
                if (this.clickEvent && this.settings.noClickOnDoubleClick) {
                if (this.clickEvent.distance(e) > this.settings.doubleClickSensitivity) {
                this.fireEvent(this.EVENT_CLICK, this.clickEvent);
                        return this.clickEvent = null
                }
                } else {
                if (this.isTargetOkay(e.target)) {
                this.inPointers[e.identifier] = true;
                        return this.fireEvent(this.EVENT_MOVE, e)
                } else {
                return this.pointerLeave(e)
                }
                }
                }
                };
                Base_MouseEvents.prototype.pointerLeave = function(e) {
                if (this.inPointers.hasOwnProperty(e.identifier)) {
                delete this.inPointers[e.identifier];
                        return this.fireEvent(this.EVENT_LEAVE, e)
                }
                };
                Base_MouseEvents.prototype.startLongPress = function(e) {
                var fireLongPress;
                        fireLongPress = (function(_this) {
                        return function() {
                        e.consumed = false;
                                _this.fireEvent(_this.EVENT_RCLICK, e);
                                if (e.consumed) {
                        return _this.downPointers[e.identifier].noClick = true
                        }
                        }
                        })(this);
                        this.cancelLongPress();
                        return this.longPressTimeout = setTimeout(fireLongPress, this.settings.longPressTimeout)
                };
                Base_MouseEvents.prototype.cancelLongPress = function() {
                if (this.longPressTimeout !== null) {
                clearTimeout(this.longPressTimeout);
                        return this.longPressTimeout = null
                }
                };
                Base_MouseEvents.prototype.wheelHappened = function(e) {
                return this.fireEvent(this.EVENT_WHEEL, e)
                };
                Base_MouseEvents.prototype.rclickHappened = function(e) {
                return this.fireEvent(this.EVENT_RCLICK, e)
                };
                Base_MouseEvents.prototype.fireEvent = function(name, event) {
                if (this.listeners[name]) {
                return this.listeners[name].call(this, event)
                }
                };
                Base_MouseEvents.prototype.isTargetOkay = function(target) {
                var k, v, _i, _len, _ref;
                        _ref = this.whiteList;
                        for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
                v = _ref[k];
                        if ((v === target) || Base_Helpers.isParentOf(v, target)) {
                return true
                }
                }
                return false
                };
                return Base_MouseEvents
        })();
        var Linearchart_Layers;
        Linearchart_Layers = (function() {
        Linearchart_Layers.prototype.chart = null;
                Linearchart_Layers.prototype.scene = null;
                Linearchart_Layers.prototype.container = null;
                Linearchart_Layers.prototype.background = null;
                Linearchart_Layers.prototype.canvas = null;
                Linearchart_Layers.prototype.valueAxisPanel = null;
                Linearchart_Layers.prototype.timeAxisPanel = null;
                Linearchart_Layers.prototype.outerBorder = null;
                Linearchart_Layers.prototype.mouseTrackLayer = null;
                Linearchart_Layers.prototype.curTheme = null;
                function Linearchart_Layers(chart) {
                this.chart = chart;
                        this.scene = this.chart.scene;
                        this.container = Base_Helpers.createDom("div", "DVSL-container");
                        this.container.style.position = "relative";
                        this.container.style.width = "100%";
                        this.container.style.height = "300px";
                        this.background = Base_Helpers.createDom("div", "DVSL-background", null, this.container);
                        this.setContainerStyle(this.background);
                        this.timeAxisPanel = Base_Helpers.createDom("div", "DVSL-TC-timeAxis", null, this.container);
                        this.setContainerStyle(this.timeAxisPanel);
                        this.canvas = Base_Helpers.createDom("canvas", "DVSL-canvas", null, this.container);
                        this.setContainerStyle(this.canvas);
                        this.valueAxisPanel = Base_Helpers.createDom("div", "DVSL-valueAxis", null, this.container);
                        this.setContainerStyle(this.valueAxisPanel);
                        this.secondaryValueAxisPanel = Base_Helpers.createDom("div", "DVSL-valueAxis", null, this.container);
                        this.setContainerStyle(this.secondaryValueAxisPanel);
                        this.resizerBar = Base_Helpers.createDom("div", "DVSL-resizer", null, this.container);
                        this.outerBorder = Base_Helpers.createDom("div", "DVSL-border", null, this.container);
                        this.setContainerStyle(this.outerBorder);
                        this.mouseTrackLayer = Base_Helpers.createDom("div", null, null, this.container);
                        this.mouseTrackLayer.tabIndex = 0;
                        this.mouseTrackLayer.style.outline = "none";
                        this.setContainerStyle(this.mouseTrackLayer);
                        this.updateSettings(this.scene.settings, "init");
                        this.updateSize()
                }
        Linearchart_Layers.prototype.updateSize = function() {
        var setHeight, setWidth;
                setWidth = this.scene.settings.width;
                setHeight = this.scene.settings.height;
                if (this.scene.chartWidth > this.scene.settings.container.clientWidth && this.container && this.container.style.display !== "") {
        setWidth = this.scene.chartWidth
        }
        if (this.scene.chartHeight > this.scene.settings.container.clientHeight && this.container && this.container.style.display !== "") {
        setHeight = this.scene.chartHeight
        }
        if (setWidth) {
        this.container.style.width = "" + setWidth + "px"
        }
        if (setHeight) {
        this.container.style.height = "" + setHeight + "px"
        }
        this.background.style.left = "" + this.scene.x0 + "px";
                this.background.style.width = "" + this.scene.width + "px";
                this.valueAxisPanel.style.width = "" + this.scene.leftMargin + "px";
                this.valueAxisPanel.style.bottom = "" + this.scene.bottomMargin + "px";
                this.secondaryValueAxisPanel.style.width = "" + this.scene.rightMargin + "px";
                this.secondaryValueAxisPanel.style.bottom = "" + this.scene.bottomMargin + "px";
                this.timeAxisPanel.style.top = "" + (this.scene.y0 + this.scene.height) + "px";
                this.timeAxisPanel.style.left = "" + this.scene.x0 + "px";
                this.timeAxisPanel.style.width = "" + this.scene.width + "px";
                this.outerBorder.style.left = "" + this.scene.x0 + "px";
                this.outerBorder.style.width = "" + this.scene.width + "px";
                this.resizerBar.style.width = "" + this.scene.width + "px";
                return this.resizerBar.style.left = "" + this.scene.x0 + "px"
        };
                Linearchart_Layers.prototype.updateSettings = function(changes) {
                if (Base_Helpers.getProp(changes, "advanced/themeCSSClass") != null) {
                if (this.curTheme != null) {
                Base_Helpers.removeClass(this.container, this.curTheme)
                }
                this.curTheme = this.scene.settings.advanced.themeCSSClass;
                        Base_Helpers.addClass(this.container, this.curTheme)
                }
                if ((changes.width != null) || (changes.height != null)) {
                return this.updateSize()
                }
                };
                Linearchart_Layers.prototype.setContainerStyle = function(c) {
                c.style.position = "absolute";
                        c.style.left = "0px";
                        c.style.right = "0px";
                        c.style.top = "0px";
                        return c.style.bottom = "0px"
                };
                return Linearchart_Layers
        })();
        var Linearchart_Highlight, Linearchart_Marker, Linearchart_Scene, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Linearchart_Marker = (function() {
        function Linearchart_Marker() {
        }
        Linearchart_Marker.prototype.time = 0;
                Linearchart_Marker.prototype.label = 0;
                Linearchart_Marker.prototype.style = null;
                return Linearchart_Marker
        })();
        Linearchart_Highlight = (function() {
        function Linearchart_Highlight() {
        }
        Linearchart_Highlight.prototype.from = 0;
                Linearchart_Highlight.prototype.to = 0;
                Linearchart_Highlight.prototype.style = null;
                return Linearchart_Highlight
        })();
        Linearchart_Scene = (function(_super) {
        __extends(Linearchart_Scene, _super);
                Linearchart_Scene.prototype.settings = null;
                Linearchart_Scene.prototype.bottomAxisSize = null;
                function Linearchart_Scene() {
                Linearchart_Scene.__super__.constructor.call(this);
                        this.highlights = {};
                        this.markers = []
                }
        Linearchart_Scene.prototype.xyInChart = function(x, y) {
        return(x >= this.x0) && (x < this.x0 + this.width) && (y >= this.y0) && (y < this.y0 + this.height)
        };
                Linearchart_Scene.prototype.xyInChartOrBottom = function(x, y) {
                return(x >= this.x0) && (x < this.x0 + this.width) && (y >= this.y0) && (y < this.y0 + this.height + this.bottomAxisSize)
                };
                Linearchart_Scene.prototype.xyInBottom = function(x, y) {
                return x >= this.x0 && x < this.x0 + this.width && y >= this.y0 + this.height && y < this.y0 + this.height + this.bottomAxisSize
                };
                Linearchart_Scene.prototype.timeToX = function(t) {
                throw"Need to implement timeToX"
                };
                Linearchart_Scene.prototype.setHighlight = function(name, from, to, style) {
                var h;
                        h = this.highlights[name];
                        if (h == null) {
                h = {};
                        this.highlights[name] = h
                }
                h.from = from;
                        h.to = to;
                        h.style = style;
                        return h
                };
                Linearchart_Scene.prototype.removeHighlight = function(name, keepTrack) {
                if (keepTrack == null) {
                keepTrack = false
                }
                if (this.highlights[name] == null) {
                return
                }
                this.highlights[name].keepTrack = keepTrack;
                        return delete this.highlights[name]
                };
                return Linearchart_Scene
        })(Base_Scene);
        var Linearchart_Scrolling;
        Linearchart_Scrolling = (function() {
        Linearchart_Scrolling.prototype.animationPriority = 1000;
                Linearchart_Scrolling.prototype.chart = null;
                Linearchart_Scrolling.prototype.scene = null;
                Linearchart_Scrolling.prototype.events = null;
                Linearchart_Scrolling.prototype.currentFrom = 0;
                Linearchart_Scrolling.prototype.currentTo = 0;
                Linearchart_Scrolling.prototype.pointer1 = null;
                Linearchart_Scrolling.prototype.pointer2 = null;
                Linearchart_Scrolling.prototype.t1 = 0;
                Linearchart_Scrolling.prototype.t2 = 0;
                Linearchart_Scrolling.prototype.x1 = 0;
                Linearchart_Scrolling.prototype.x2 = 0;
                Linearchart_Scrolling.prototype.scaleOrigin = null;
                Linearchart_Scrolling.prototype.initialZoom = null;
                Linearchart_Scrolling.prototype.dragStartFrom = null;
                Linearchart_Scrolling.prototype.dragStartTo = null;
                Linearchart_Scrolling.prototype.active = false;
                Linearchart_Scrolling.prototype.lastScrollingY = 0;
                Linearchart_Scrolling.prototype.scrollingActive = false;
                Linearchart_Scrolling.prototype.scalingActive = false;
                Linearchart_Scrolling.prototype.scrollingSpeed = null;
                Linearchart_Scrolling.prototype.scrollingDuration = null;
                Linearchart_Scrolling.prototype.from = null;
                Linearchart_Scrolling.prototype.to = null;
                Linearchart_Scrolling.prototype.highlight = null;
                Linearchart_Scrolling.prototype.hilghtRemoveWhenDone = false;
                function Linearchart_Scrolling(chart) {
                this.chart = chart;
                        this.scene = this.chart.scene;
                        this.events = this.chart.events
                }
        Linearchart_Scrolling.prototype.xyInArea = function(x, y) {
        return false
        };
                Linearchart_Scrolling.prototype.xyToPosition = function(x, y) {
                return 0
                };
                Linearchart_Scrolling.prototype.onStartDragging = function(oldFrom, oldTo, pos) {
                return null
                };
                Linearchart_Scrolling.prototype.onSnapWhileDragging = function(from, to, center, isScrolling, isScaling) {
                return[from, to]
                };
                Linearchart_Scrolling.prototype.onSnapAfterDragging = function(from, to, center, isScrolling, isScaling) {
                return[from, to]
                };
                Linearchart_Scrolling.prototype.onCancelDragging = function(oldFrom, toldTo) {
                return null
                };
                Linearchart_Scrolling.prototype.onZoomOut = function(from, to, center, scale) {
                if (scale == null) {
                scale = 2
                }
                return[center - (center - from) * scale, center + (to - center) * scale, center]
                };
                Linearchart_Scrolling.prototype.onZoomIn = function(from, to, center, scale) {
                if (scale == null) {
                scale = 0.5
                }
                return[center - (center - from) * scale, center + (to - center) * scale, center]
                };
                Linearchart_Scrolling.prototype.onScroll = function(from, to, direction) {
                if (direction === "<") {
                return[from * 2 - to, from]
                } else {
                return[to, 2 * to - from]
                }
                };
                Linearchart_Scrolling.prototype.onGoHome = function(from, to) {
                return[from, to, to]
                };
                Linearchart_Scrolling.prototype.onPositionChanged = function(from, to) {
                return 1
                };
                Linearchart_Scrolling.prototype.onAnimationDone = function(from, to) {
                return 1
                };
                Linearchart_Scrolling.prototype.getFrom = function() {
                if (this.panAnimF != null) {
                return this.panAnimF.to
                } else {
                return this.currentFrom
                }
                };
                Linearchart_Scrolling.prototype.getTo = function() {
                if (this.panAnimT != null) {
                return this.panAnimT.to
                } else {
                return this.currentTo
                }
                };
                Linearchart_Scrolling.prototype.onWheel = function(event) {
                var ds, from, origin, r, to;
                        if (!(this.currentFrom < this.currentTo)) {
                return
                }
                if (!this.xyInArea(event.x, event.y) || (!this.scene.settings.interaction.zooming.wheel) || (!this.scene.settings.interaction.zooming.enabled)) {
                return
                }
                this.active = true;
                        origin = this.scaleOrigin != null ? this.scaleOrigin : this.scene.xyToPosition(event.x, event.y);
                        ds = Math.pow(1 + this.scene.settings.interaction.zooming.sensitivity, event.wheely * 0.004);
                        from = this.getFrom();
                        to = this.getTo();
                        from = (from - origin) * ds + origin;
                        to = (to - origin) * ds + origin;
                        r = this.onSnapAfterDragging(from, to, origin, false, true);
                        if (r) {
                this.goToPosition(r[0], r[1], true);
                        if (this.pointer1 != null) {
                this.scalingActive = true
                }
                }
                event.consumed = true;
                        return this.active = false
                };
                Linearchart_Scrolling.prototype.onPointerDown = function(event) {
                var pos;
                        if (!(this.currentFrom < this.currentTo)) {
                return
                }
                if (!this.xyInArea(event.x, event.y) || (!this.scene.settings.interaction.scrolling.enabled && !this.scene.settings.interaction.zooming.enabled)) {
                return
                }
                pos = this.xyToPosition(event.x, event.y);
                        if (this.pointer1 === null) {
                this.pointer1 = event.identifier;
                        this.x1 = event.x;
                        this.t1 = pos;
                        this.scaleOrigin = pos;
                        this.onStartDragging(this.getFrom(), this.getTo(), pos);
                        this.lastScrollingY = event.y;
                        this.dragStartFrom = this.currentFrom;
                        this.dragStartTo = this.currentTo;
                        event.consumed = true;
                        if ((this.panAnimF != null) || (this.panAnimT != null)) {
                this.stopAnimations();
                        this.scrollingActive = true
                }
                this.scene.anchor = null;
                        this.chart.cancelChartUpdateNotify();
                        return event.noDefault = true
                } else {
                if (this.pointer2 === null) {
                this.pointer2 = event.identifier;
                        this.x2 = event.x;
                        this.t2 = pos;
                        this.initialZoom = this.currentTo - this.currentFrom;
                        this.scaleOrigin = (this.t1 + this.t2) / 2;
                        return event.consumed = true
                } else {
                if (this.scalingActive || this.scrollingActive) {
                return event.consumed = true
                }
                }
                }
                };
                Linearchart_Scrolling.prototype.onPointerDrag = function(event) {
                var ds, dt, from, pos, to, _ref, _ref1, _ref2, _ref3, _ref4;
                        pos = this.xyToPosition(event.x, event.y);
                        if (event.identifier === this.pointer1 && (this.pointer2 == null)) {
                this.scaleOrigin = this.t1;
                        this.x1 = event.x;
                        if (Math.abs(event.dx) > Math.abs(event.dy)) {
                this.lastScrollingY = event.y;
                        if (Math.abs(event.dx) > Math.abs(event.dy) * 4 && this.scene.settings.interaction.scrolling.enabled) {
                this.scrollingActive = true
                }
                } else {
                if (this.scene.settings.interaction.zooming.enabled && this.scene.settings.interaction.zooming.swipe && Math.abs(this.lastScrollingY - event.y) > this.scene.settings.interaction.zooming.upDownTreshold) {
                this.scalingActive = true
                }
                }
                from = this.getFrom();
                        to = this.getTo();
                        if (this.scalingActive) {
                this.clearZoomHighlight();
                        ds = Math.pow(1 + this.scene.settings.interaction.zooming.sensitivity, - event.dy / this.scene.height);
                        from = (from - this.scaleOrigin) * ds + this.scaleOrigin;
                        to = (to - this.scaleOrigin) * ds + this.scaleOrigin;
                        event.consumed = true
                }
                if (this.scrollingActive) {
                dt = this.t1 - pos;
                        from = from + dt;
                        to = to + dt;
                        event.consumed = true
                }
                _ref = this.onSnapWhileDragging(from, to, this.scaleOrigin, this.scrollingActive, this.scalingActive), from = _ref[0], to = _ref[1];
                        return this.goToPositionDragging(from, to)
                } else {
                if (event.identifier === this.pointer1 && this.scene.settings.interaction.scrolling.enabled) {
                this.x1 = event.x;
                        this.clearZoomHighlight();
                        _ref1 = this.twoPointerDrag(), from = _ref1[0], to = _ref1[1];
                        _ref2 = this.onSnapWhileDragging(from, to, this.scaleOrigin, this.scrollingActive, this.scalingActive), from = _ref2[0], to = _ref2[1];
                        this.goToPositionDragging(from, to);
                        return event.consumed = true
                } else {
                if (event.identifier === this.pointer2 && this.scene.settings.interaction.scrolling.enabled) {
                this.x2 = event.x;
                        this.clearZoomHighlight();
                        _ref3 = this.twoPointerDrag(), from = _ref3[0], to = _ref3[1];
                        _ref4 = this.onSnapWhileDragging(from, to, this.scaleOrigin, this.scrollingActive, this.scalingActive), from = _ref4[0], to = _ref4[1];
                        this.goToPositionDragging(from, to);
                        return event.consumed = true
                } else {
                if (this.scalingActive || this.scrollingActive) {
                return event.consumed = true
                }
                }
                }
                }
                };
                Linearchart_Scrolling.prototype.twoPointerDrag = function() {
                var centerFraction, centerT, dFraction, dt, dtInitial, from, maxVisible, maxZoom, minVisible, ta, targetVisible, tb, to, x1Pos, x2Pos;
                        maxZoom = this.scene.settings.interaction.zooming.fingersMaxZoom;
                        this.scaleOrigin = (this.t1 + this.t2) / 2;
                        dtInitial = this.t2 - this.t1;
                        x1Pos = this.xyToPosition(this.x1, 0);
                        x2Pos = this.xyToPosition(this.x2, 0);
                        if (this.scene.settings.interaction.scrolling.enabled && this.scene.settings.interaction.zooming.enabled && this.scene.settings.interaction.zooming.fingers && dtInitial !== 0) {
                centerT = (this.t1 + this.t2) / 2;
                        centerFraction = ((x1Pos + x2Pos) / 2 - this.currentFrom) / (this.currentTo - this.currentFrom);
                        dFraction = (x2Pos - x1Pos) / (this.currentTo - this.currentFrom);
                        if (dtInitial * dFraction > 0) {
                targetVisible = dtInitial / dFraction
                } else {
                targetVisible = Infinity
                }
                maxVisible = this.initialZoom * maxZoom;
                        minVisible = Math.max(this.initialZoom / maxZoom, this.scene.settings.area.minDisplayRange);
                        targetVisible = Math.max(minVisible, Math.min(maxVisible, targetVisible));
                        from = centerT - centerFraction * targetVisible;
                        to = centerT + (1 - centerFraction) * targetVisible;
                        this.scalingActive = true;
                        this.scrollingActive = true
                } else {
                if (this.scene.settings.interaction.scrolling.enabled) {
                ta = (this.t1 + this.t2) / 2;
                        tb = (x1Pos + x2Pos) / 2;
                        dt = ta - tb;
                        from += dt;
                        to += dt;
                        this.scrollingActive = true
                }
                }
                return[from, to]
                };
                Linearchart_Scrolling.prototype.onPointerUp = function(event) {
                var direction, dt, dur, from, r, speed, to, vx, _ref, _ref1, _ref2;
                        if (event.identifier === this.pointer2) {
                this.pointer2 = null;
                        event.consumed = true;
                        return this.scaleOrigin = this.t1
                } else {
                if (event.identifier === this.pointer1 && (this.pointer2 != null)) {
                this.pointer1 = this.pointer2;
                        this.pointer2 = null;
                        this.t1 = this.t2;
                        this.scaleOrigin = this.t1;
                        return event.consumed = true
                } else {
                if (event.identifier === this.pointer1) {
                this.pointer1 = null;
                        this.active = true;
                        if (this.scene.settings.interaction.scrolling.swipePageFlipping && event.swipeUp && this.scalingActive && event.swipeSpeed > this.scene.height / this.scene.settings.interaction.swipeSensitivity) {
                _ref = this.onZoomOut(this.dragStartFrom, this.dragStartTo, this.scaleOrigin), from = _ref[0], to = _ref[1]
                } else {
                if (this.scene.settings.interaction.scrolling.swipePageFlipping && event.swipeDown && this.scalingActive && event.swipeSpeed > this.scene.height / this.scene.settings.interaction.swipeSensitivity) {
                _ref1 = this.onZoomIn(this.dragStartFrom, this.dragStartTo, this.scaleOrigin), from = _ref1[0], to = _ref1[1]
                } else {
                if (this.scrollingActive || this.scalingActive) {
                if (this.scrollingActive && !this.scalingActive && this.scene.settings.interaction.scrolling.swipePageFlipping && (event.swipeLeft || event.swipeRight) && event.swipeSpeed > this.scene.width / this.scene.settings.interaction.swipeSensitivity * 0.7) {
                direction = event.swipeLeft ? "<" : ">";
                        _ref2 = this.onScroll(this.dragStartFrom, this.dragStartTo, direction), from = _ref2[0], to = _ref2[1]
                } else {
                from = this.currentFrom;
                        to = this.currentTo;
                        if (this.scrollingActive && !this.scalingActive) {
                vx = - event.vx;
                        if (vx > 0) {
                vx = Math.min(vx, this.scene.width * 2)
                } else {
                vx = Math.max(vx, - this.scene.width * 2)
                }
                speed = (this.xyToPosition(event.x, event.y) - this.xyToPosition(event.x - vx / 1000, event.y)) * 1000;
                        dur = Math.abs(event.vx / this.scene.width) / this.scene.settings.interaction.scrolling.kineticFriction;
                        dur = Math.min(dur, 1);
                        dt = dur * speed / 2;
                        this.scrollingSpeed = speed;
                        this.scrollingDuration = dur * 1000;
                        from += dt;
                        to += dt
                }
                }
                this.scaleOrigin = (from + to) / 2
                }
                }
                }
                if (from || to) {
                r = this.onSnapAfterDragging(from, to, this.scaleOrigin, this.scrollingActive, this.scalingActive);
                        if (r) {
                this.goToPosition(r[0], r[1], true)
                }
                event.consumed = true;
                        this.scaleOrigin = null
                }
                this.active = false;
                        this.dragStartFrom = null;
                        this.dragStartTo = null;
                        this.scalingActive = false;
                        return this.scrollingActive = false
                } else {
                if (this.scalingActive || this.scrollingActive) {
                return event.consumed = true
                }
                }
                }
                }
                };
                Linearchart_Scrolling.prototype.onPointerCancel = function(event) {
                var r;
                        if (event.identifier === this.pointer2) {
                this.pointer2 = null;
                        return this.scaleOrigin = this.t1
                } else {
                if (event.identifier === this.pointer1 && (this.pointer2 != null)) {
                this.pointer1 = this.pointer2;
                        this.t1 = this.t2;
                        this.scaleOrigin = this.t1;
                        this.pointer2 = null;
                        return this.t2 = null
                } else {
                if (event.identifier === this.pointer1) {
                this.active = true;
                        r = this.onCancelDragging(this.dragStartFrom, this.dragStartTo);
                        if (r) {
                this.goToPosition(r[0], r[1], false)
                }
                this.pointer1 = null;
                        this.t1 = null;
                        this.scaleOrigin = null;
                        this.dragStartFrom = null;
                        this.dragStartTo = null;
                        this.scalingActive = false;
                        this.scrollingActive = false;
                        return this.active = false
                }
                }
                }
                };
                Linearchart_Scrolling.prototype.onKeyDown = function(event) {
                var from, origin, r, scaling, scrolling, to, zoom, _ref, _ref1, _ref2, _ref3, _ref4;
                        this.active = true;
                        from = this.getFrom();
                        to = this.getTo();
                        if (!(from < to)) {
                return
                }
                origin = (from + to) / 2;
                        scrolling = false;
                        scaling = false;
                        if (event.keyCode === 37) {
                scrolling = true;
                        _ref = this.onScroll(from, to, "<"), from = _ref[0], to = _ref[1];
                        origin = (from + to) / 2
                } else {
                if (event.keyCode === 39) {
                scrolling = true;
                        _ref1 = this.onScroll(from, to, ">"), from = _ref1[0], to = _ref1[1];
                        origin = (from + to) / 2
                } else {
                if (event.keyCode === 36) {
                scaling = true;
                        scrolling = true;
                        _ref2 = this.onGoHome(from, to), from = _ref2[0], to = _ref2[1], origin = _ref2[2]
                } else {
                if (event.keyCode === 38) {
                zoom = this.scene.settings.interaction.zooming.keyboardFactor;
                        scaling = true;
                        _ref3 = this.onZoomOut(from, to, origin, zoom), from = _ref3[0], to = _ref3[1], origin = _ref3[2]
                } else {
                if (event.keyCode === 40) {
                zoom = 1 / this.scene.settings.interaction.zooming.keyboardFactor;
                        scaling = true;
                        _ref4 = this.onZoomIn(from, to, origin, zoom), from = _ref4[0], to = _ref4[1]
                }
                }
                }
                }
                }
                if (scaling || scrolling) {
                r = this.onSnapAfterDragging(from, to, origin, scrolling, scaling);
                        if (r) {
                this.goToPosition(r[0], r[1], true)
                }
                event.consumed = true
                }
                return this.active = false
                };
                Linearchart_Scrolling.prototype.goToPositionDragging = function(from, to) {
                var oldFromAnim, oldToAnim, _ref;
                        _ref = this.stopAnimations(), oldFromAnim = _ref[0], oldToAnim = _ref[1];
                        this.currentFrom = from;
                        this.currentTo = to;
                        this.clearZoomHighlight();
                        return this.onPositionChanged(from, to)
                };
                Linearchart_Scrolling.prototype.goToPosition = function(from, to, animate) {
                var diff, f, oldFromAnim, oldToAnim, t, _ref;
                        if (!(from < to)) {
                return
                }
                if (!(this.currentFrom < this.currentTo)) {
                animate = false
                }
                _ref = this.stopAnimations(), oldFromAnim = _ref[0], oldToAnim = _ref[1];
                        if (animate) {
                if (this.scrollingDuration > 0) {
                this.panAnimF = new Base_Animator(this.currentFrom, from, this.scrollingDuration, "scroll");
                        this.panAnimT = new Base_Animator(this.currentTo, to, this.scrollingDuration, "scroll");
                        this.scrollingDuration = null
                } else {
                if (oldFromAnim || oldToAnim) {
                this.panAnimF = oldFromAnim.retarget(from);
                        this.panAnimT = oldToAnim.retarget(to)
                } else {
                this.panAnimF = new Base_Animator(this.currentFrom, from, this.scene.settings.interaction.animationDelay, "<>");
                        this.panAnimT = new Base_Animator(this.currentTo, to, this.scene.settings.interaction.animationDelay, "<>")
                }
                }
                diff = Math.abs((from - to) / (this.currentFrom - this.currentTo + 1));
                        if (diff < 1 / this.scene.settings.interaction.zooming.zoomHighlightThreshold) {
                this.setZoomHighlight(from, to, true)
                } else {
                if (diff > this.scene.settings.interaction.zooming.zoomHighlightThreshold) {
                f = this.dragStartFrom != null ? this.dragStartFrom : this.currentFrom;
                        t = this.dragStartTo != null ? this.dragStartTo : this.currentTo;
                        this.setZoomHighlight(f, t, false)
                }
                }
                return this.events.notifySceneChanges({animation: true})
                } else {
                this.currentFrom = from;
                        this.currentTo = to;
                        this.clearZoomHighlight();
                        this.onPositionChanged(from, to);
                        return this.onAnimationDone(from, to)
                }
                };
                Linearchart_Scrolling.prototype.switchCoordinates = function(from, to) {
                var f0, t0, trAdd, trMul;
                        f0 = this.getFrom();
                        t0 = this.getTo();
                        if (f0 < t0) {
                trMul = (from - f0) / (to - t0);
                        trAdd = from - f0 * trMul;
                        this.currentFrom = this.currentFrom * trMul + trAdd;
                        this.currentTo = this.currentTo * trMul + trAdd;
                        if (this.panAnimF) {
                this.panAnimF.switchCoordinates(trAdd, trMul)
                }
                if (this.panAnimT) {
                return this.panAnimT.switchCoordinates(trAdd, trMul)
                }
                } else {
                this.stopAnimations();
                        this.currentFrom = from;
                        return this.currentTo = to
                }
                };
                Linearchart_Scrolling.prototype.doAnimations = function(event) {
                var newFrom, newTo, time;
                        time = event.time;
                        if ((this.panAnimF != null) || this.panAnimT) {
                newFrom = this.currentFrom;
                        newTo = this.currentTo;
                        if (this.panAnimF != null) {
                newFrom = this.currentFrom = this.panAnimF.get(time);
                        if (this.panAnimF.finished(time)) {
                this.panAnimF = null
                }
                }
                if (this.panAnimT != null) {
                newTo = this.currentTo = this.panAnimT.get(time);
                        if (this.panAnimT.finished(time)) {
                this.panAnimT = null
                }
                }
                if ((this.panAnimF != null) || this.panAnimT) {
                this.onPositionChanged(newFrom, newTo);
                        event.animating = true
                } else {
                this.stopAnimations();
                        this.onPositionChanged(newFrom, newTo);
                        this.onAnimationDone(newFrom, newTo)
                }
                }
                };
                Linearchart_Scrolling.prototype.stopAnimations = function() {
                var oldFrom, oldTo;
                        oldFrom = this.panAnimF;
                        oldTo = this.panAnimT;
                        this.panAnimF = null;
                        this.panAnimT = null;
                        if (this.highlight != null) {
                if (this.hilghtRemoveWhenDone) {
                this.clearZoomHighlight()
                } else {
                this.highlight.style.fillColor = this.scene.settings.area.style.zoomHighlightInactive.fillColor;
                        this.events.notifySceneChanges({highlight: true})
                }
                }
                return[oldFrom, oldTo]
                };
                Linearchart_Scrolling.prototype.isActive = function() {
                return this.active || this.panAnimF || this.pointer1
                };
                Linearchart_Scrolling.prototype.clearZoomHighlight = function() {
                if (this.highlight != null) {
                this.scene.removeHighlight("zoomTrace");
                        this.highlight = null;
                        return this.events.notifySceneChanges({highlight: true})
                }
                };
                Linearchart_Scrolling.prototype.setZoomHighlight = function(from, to, removeWhenDone) {
                this.highlight = this.scene.setHighlight("zoomTrace", from, to, this.scene.settings.area.style.zoomHighlight);
                        this.hilghtRemoveWhenDone = removeWhenDone;
                        return this.events.notifySceneChanges({highlight: true})
                };
                return Linearchart_Scrolling
        })();
        var Base_View;
        Base_View = (function() {
        Base_View.prototype.items = [];
                Base_View.prototype.ui = {};
                Base_View.prototype.options = {};
                Base_View.prototype.baseClass = "view";
                Base_View.prototype.relativeClass = "";
                Base_View.prototype.objClass = null;
                Base_View.prototype.parent = null;
                Base_View.prototype.createCoreContainer = true;
                Base_View.prototype.id = null;
                function Base_View(options) {
                var d;
                        Base_Helpers.extend(this.options, options);
                        this.items = [];
                        this.ui = {};
                        if (this.options.id) {
                this.id = this.options.id
                } else {
                d = new Date().getTime();
                        this.id = "o" + d
                }
                this.objClass = Base_Helpers.wrapClass(this, this.baseClass);
                        this.relativeClass = Base_Helpers.wrapClass(this, this.relativeClass);
                        if (this.createCoreContainer) {
                this.ui.container = Base_Helpers.createDom("div", this.objClass + " " + this.relativeClass, null, options.container ? options.container : null)
                }
                }
        Base_View.prototype.addItem = function(obj, options) {
        var o;
                o = {spot: "container"};
                Base_Helpers.extend(o, options);
                obj.parent = this;
                obj.id = this.id + "_o" + this.items.length;
                obj.init();
                this.items.push({obj: obj, options: o});
                return obj
        };
                Base_View.prototype.render = function() {
                var i, v, _i, _len, _ref;
                        if (this.items) {
                _ref = this.items;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                v = _ref[_i];
                        i = v.obj.render();
                        if (i) {
                this.ui[v.options.spot].appendChild(i)
                }
                }
                }
                return this.ui.container
                };
                Base_View.prototype.show = function(instant) {
                this.visible = true;
                        if (!instant) {
                return Base_Helpers.fadeIn(this.ui.container)
                } else {
                return Base_Helpers.show(this.ui.container)
                }
                };
                Base_View.prototype.hide = function(instant) {
                this.visible = false;
                        if (!instant) {
                return Base_Helpers.fadeOut(this.ui.container)
                } else {
                return Base_Helpers.hide(this.ui.container)
                }
                };
                Base_View.prototype.init = function() {
                return this
                };
                Base_View.prototype.remove = function() {
                var v, _i, _len, _ref;
                        _ref = this.items;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                v = _ref[_i];
                        v.obj.remove()
                }
                if (this.createCoreContainer && this.ui.container.parentNode) {
                return this.ui.container.parentNode.removeChild(this.ui.container)
                }
                };
                return Base_View
        })();
        var Base_Bar, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Base_Bar = (function(_super) {
        __extends(Base_Bar, _super);
                Base_Bar.prototype.visible = false;
                Base_Bar.prototype.panScene = false;
                Base_Bar.prototype.height = 48;
                Base_Bar.prototype.baseClass = "bar";
                Base_Bar.prototype.relativeClass = "";
                Base_Bar.prototype.chart = null;
                Base_Bar.prototype.scene = null;
                function Base_Bar(options, chart) {
                var defaultOptions;
                        this.chart = chart;
                        this.options = {};
                        this.scene = this.chart.scene;
                        defaultOptions = {};
                        Base_Helpers.configure(options, defaultOptions);
                        Base_Bar.__super__.constructor.call(this, options);
                        this.ui.left = Base_Helpers.createDom("ul", Base_Helpers.wrapClass(this, "items,left"), null, this.ui.container);
                        this.ui.right = Base_Helpers.createDom("ul", Base_Helpers.wrapClass(this, "items,right"), null, this.ui.container);
                        if (!this.visible) {
                this.hide(true)
                } else {
                this.show(true)
                }
                this.chart.events.addElement(this)
                }
        Base_Bar.prototype.remove = function() {
        this.chart.events.removeElement(this);
                return Base_Bar.__super__.remove.call(this)
        };
                Base_Bar.prototype.hide = function(instant) {
                Base_Bar.__super__.hide.call(this, instant);
                        return this.chart.events.hook("bar-closed")
                };
                Base_Bar.prototype.getLocationPreference = function() {
                return[this.height, this.panScene]
                };
                Base_Bar.prototype.setPosition = function(left, top, width) {
                this.ui.container.style.top = top + "px";
                        this.ui.container.style.left = left + "px";
                        return this.ui.container.style.width = width + "px"
                };
                return Base_Bar
        })(Base_View);
        var Linearchart_Series_Stack;
        Linearchart_Series_Stack = (function() {
        function Linearchart_Series_Stack(scene, cluster, options, va) {
        this.scene = scene;
                this.cluster = cluster;
                this.options = options;
                this.va = va;
                this.va.series++;
                this.series = [];
                this.seriesId = [];
                this.min = 0;
                this.max = 0;
                this.renderingType = null;
                this.needsAfterProcess = false;
                this.paddingLeft = 0;
                this.paddingRight = 0;
                this.centers = [];
                this.radii = [];
                this.vstack = [];
                this.ystack = [];
                this.xes = [];
                this.times = [];
                this.styles = [];
                this.calculatedDepth = 0
        }
        Linearchart_Series_Stack.prototype.addSeries = function(seriesId, seriesOptions) {
        if (!this.renderingType) {
        this.renderingType = seriesOptions.type
        }
        this.series.push(seriesOptions);
                this.seriesId.push(seriesId);
                this.calculatedDepth = Math.max(this.calculatedDepth, seriesOptions.style.depth);
                if (this.renderingType !== "line") {
        this.paddingLeft = Math.max(this.paddingLeft, seriesOptions.style.padding[0]);
                return this.paddingRight = Math.max(this.paddingRight, seriesOptions.style.padding[1])
        }
        };
                Linearchart_Series_Stack.prototype.afterInit = function() {
                if (this.renderingType === "line") {
                return this.renderer = new Linearchart_Renderer_Line(this.scene)
                } else {
                return this.renderer = new Linearchart_Renderer_Columns(this.scene)
                }
                };
                Linearchart_Series_Stack.prototype.process = function(seriesData) {
                this.processData(seriesData);
                        this.computeMinMax();
                        this.addLeads(seriesData);
                        return this.needsAfterProcess = true
                };
                Linearchart_Series_Stack.prototype.afterProcess = function() {
                if (this.needsAfterProcess || this.va.axisChanged) {
                this.needsAfterProcess = false;
                        return this.computeY()
                }
                };
                Linearchart_Series_Stack.prototype.paint = function(context) {
                if (!(this.ystack.length > 0)) {
                return
                }
                if (this.ystackNegative) {
                this.renderer.paintStack(context, this.series, this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY)
                }
                return this.renderer.paintStack(context, this.series, this.centers, this.radii, this.ystack, this.styles, this.va.zeroY)
                };
                Linearchart_Series_Stack.prototype.processData = function(dataMap) {
                var i, seriesId, slice, _i, _len, _ref, _results;
                        this.vstack = [];
                        this.styles = [];
                        slice = dataMap[this.seriesId[0]];
                        if (slice.times.length === 0) {
                return
                }
                this.xes = slice.xes.slice(slice.fromIndex, slice.toIndex);
                        this.times = slice.times.slice(slice.fromIndex, slice.toIndex);
                        this.centers = new Array(this.xes.length - 1);
                        this.radii = new Array(this.xes.length - 1);
                        this.cluster.computeStackCenterRadius(this, this.xes, this.centers, this.radii);
                        _ref = this.seriesId;
                        _results = [];
                        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                seriesId = _ref[i];
                        slice = dataMap[seriesId];
                        this.vstack.push(slice.values.slice(slice.fromIndex, slice.toIndex - 1));
                        if (slice.style) {
                _results.push(this.styles.push(slice.style.slice(slice.fromIndex, slice.toIndex - 1)))
                } else {
                _results.push(this.styles.push(null))
                }
                }
                return _results
                };
                Linearchart_Series_Stack.prototype.addLeads = function(dataMap) {
                var i, id, slice, _i, _len, _ref, _results;
                        _ref = this.seriesId;
                        _results = [];
                        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                id = _ref[i];
                        slice = dataMap[id];
                        if (slice.leadIn) {
                this.injectLead(slice.leadIn, i)
                }
                if (slice.leadOut) {
                _results.push(this.injectLead(slice.leadOut, i))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                Linearchart_Series_Stack.prototype.injectLead = function(lead, dataIndex) {
                var center, count, i, j, rad, t0, val, _i, _ref;
                        count = this.series.length;
                        val = lead.values[0];
                        t0 = lead.times[0];
                        center = [0];
                        rad = [0];
                        this.cluster.computeStackCenterRadius(this, lead.xes, center, rad);
                        center = center[0];
                        rad = rad[0];
                        i = 0;
                        while (i < this.centers.length && this.centers[i] < center) {
                i++
                }
                if (i === this.centers.length || this.centers[i] > center) {
                this.centers.splice(i, 0, center);
                        this.radii.splice(i, 0, rad);
                        this.times.splice(i, 0, t0);
                        for (j = _i = 0, _ref = count - 1; _i <= _ref; j = _i += 1) {
                this.vstack[j].splice(i, 0, null);
                        if (this.styles[j]) {
                this.styles[j].splice(i, 0, null)
                }
                }
                }
                return this.vstack[dataIndex][i] = val
                };
                Linearchart_Series_Stack.prototype.getSeparateNegative = function() {
                var v;
                        v = this.options.separateNegativeValues;
                        if (v === null) {
                v = this.renderingType !== "line"
                }
                return v
                };
                Linearchart_Series_Stack.prototype.computeMinMax = function() {
                var from, i, j, left, len, max, maxs, min, mins, right, s, separateNegativeValues, stacks, to, type, v, values, vstack, _i, _j, _k, _l, _m, _n, _o, _ref, _ref1, _ref2;
                        min = Infinity;
                        max = - Infinity;
                        if (this.vstack.length > 0) {
                vstack = this.vstack;
                        len = vstack[0].length;
                        stacks = vstack.length;
                        type = this.options.type;
                        separateNegativeValues = this.getSeparateNegative();
                        left = this.scene.x0;
                        right = left + this.scene.width;
                        from = 0;
                        to = len - 1;
                        while (from < len && this.centers[from] + this.radii[from] < left) {
                from += 1
                }
                while (to >= from && this.centers[to] - this.radii[to] > right) {
                to -= 1
                }
                if (type === "proportional") {
                min = 0;
                        max = 100
                } else {
                if (stacks === 1) {
                values = vstack[0];
                        for (i = _i = from; from <= to ? _i <= to : _i >= to; i = from <= to ? ++_i : --_i) {
                v = values[i];
                        if (v !== null) {
                min = Math.min(min, v);
                        max = Math.max(max, v)
                }
                }
                } else {
                if (type === "based") {
                for (i = _j = from; _j <= to; i = _j += 1) {
                for (j = _k = 0, _ref = stacks - 1; _k <= _ref; j = _k += 1) {
                v = vstack[j][i];
                        if (v !== null) {
                min = Math.min(min, v);
                        max = Math.max(max, v)
                }
                }
                }
                } else {
                if (type === "normal" && !separateNegativeValues) {
                for (i = _l = from; _l <= to; i = _l += 1) {
                s = 0;
                        for (j = _m = 0, _ref1 = stacks - 1; _m <= _ref1; j = _m += 1) {
                v = vstack[j][i];
                        if (v !== null) {
                s += v
                }
                min = Math.min(min, s);
                        max = Math.max(max, s)
                }
                }
                } else {
                if (type === "normal") {
                for (i = _n = from; _n <= to; i = _n += 1) {
                mins = 0;
                        maxs = 0;
                        for (j = _o = 0, _ref2 = stacks - 1; _o <= _ref2; j = _o += 1) {
                v = vstack[j][i];
                        if (v > 0) {
                maxs += v
                } else {
                if (v < 0) {
                mins += v
                }
                }
                min = Math.min(min, mins);
                        max = Math.max(max, maxs)
                }
                }
                } else {
                throw"stack.type unknown value: " + type
                }
                }
                }
                }
                }
                }
                this.min = min;
                        this.max = max;
                        if (min <= max) {
                return this.va.recieveSeriesGeometry(min, max, this.calculatedDepth)
                } else {
                return this.va.recieveSeriesGeometry(void 0, void 0, this.calculatedDepth)
                }
                };
                Linearchart_Series_Stack.prototype.computeY = function() {
                var count, i, j, minHeight, negv, posv, separateNegativeValues, stacks, sum, type, v, va, values, vstack, vv, y, ys, ystack, ystackNeg, _i, _j, _k, _l, _len, _len1, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
                        if (this.vstack.length === 0) {
                return
                }
                type = this.options.type;
                        separateNegativeValues = this.getSeparateNegative();
                        vstack = this.vstack;
                        stacks = vstack.length;
                        count = vstack[0].length;
                        va = this.va;
                        ystackNeg = null;
                        if (type === "proportional") {
                ystack = (function() {
                var _i, _len, _results;
                        _results = [];
                        for (_i = 0, _len = vstack.length; _i < _len; _i++) {
                i = vstack[_i];
                        _results.push([])
                }
                return _results
                })();
                        for (i = _i = 0, _ref = count - 1; _i <= _ref; i = _i += 1) {
                sum = 0;
                        for (j = _j = 0, _ref1 = stacks - 1; _j <= _ref1; j = _j += 1) {
                v = vstack[j][i];
                        if (v !== null) {
                sum += Math.abs(v)
                }
                }
                if (sum > 0) {
                sum *= 0.01;
                        vv = 0;
                        for (j = _k = 0, _ref2 = stacks - 1; _k <= _ref2; j = _k += 1) {
                v = vstack[j][i];
                        if (v !== null) {
                vv += Math.abs(v);
                        ystack[j].push(va.valueToRelativeY(vv / sum))
                } else {
                ystack[j].push(null)
                }
                }
                } else {
                for (j = _l = 0, _ref3 = stacks - 1; _l <= _ref3; j = _l += 1) {
                ystack[j].push(null)
                }
                }
                }
                } else {
                if (type === "based" || stacks === 1) {
                ystack = [];
                        for (j = _m = 0, _len = vstack.length; _m < _len; j = ++_m) {
                values = vstack[j];
                        ys = new Array(count);
                        minHeight = this.series[j].style.minHeight || 0;
                        for (i = _n = 0, _len1 = values.length; _n < _len1; i = ++_n) {
                v = values[i];
                        if (v !== null) {
                y = va.valueToRelativeY(v);
                        if (y > 0) {
                y = Math.max(y, minHeight)
                } else {
                y = Math.min(y, - minHeight)
                }
                ys[i] = y
                } else {
                ys[i] = null
                }
                }
                ystack.push(ys)
                }
                } else {
                if (type === "normal" && separateNegativeValues && (this.min < 0 && this.max > 0)) {
                ystack = (function() {
                var _len2, _o, _results;
                        _results = [];
                        for (_o = 0, _len2 = vstack.length; _o < _len2; _o++) {
                i = vstack[_o];
                        _results.push([])
                }
                return _results
                })();
                        ystackNeg = (function() {
                        var _len2, _o, _results;
                                _results = [];
                                for (_o = 0, _len2 = vstack.length; _o < _len2; _o++) {
                        i = vstack[_o];
                                _results.push([])
                        }
                        return _results
                        })();
                        for (i = _o = 0, _ref4 = count - 1; _o <= _ref4; i = _o += 1) {
                negv = 0;
                        posv = 0;
                        for (j = _p = 0, _ref5 = stacks - 1; _p <= _ref5; j = _p += 1) {
                v = vstack[j][i];
                        if (v > 0) {
                posv += v;
                        ystack[j].push(va.valueToRelativeY(posv));
                        ystackNeg[j].push(null)
                } else {
                if (v < 0) {
                negv += v;
                        ystack[j].push(null);
                        ystackNeg[j].push(va.valueToRelativeY(negv))
                } else {
                ystack[j].push(null);
                        ystackNeg[j].push(null)
                }
                }
                }
                }
                } else {
                if (type === "normal") {
                ystack = (function() {
                var _len2, _q, _results;
                        _results = [];
                        for (_q = 0, _len2 = vstack.length; _q < _len2; _q++) {
                i = vstack[_q];
                        _results.push([])
                }
                return _results
                })();
                        for (i = _q = 0, _ref6 = count - 1; _q <= _ref6; i = _q += 1) {
                vv = 0;
                        for (j = _r = 0, _ref7 = stacks - 1; _r <= _ref7; j = _r += 1) {
                v = vstack[j][i];
                        if (v !== null) {
                vv += v;
                        ystack[j].push(va.valueToRelativeY(vv))
                } else {
                ystack[j].push(null)
                }
                }
                }
                } else {
                throw"stack.type unknown value: " + type
                }
                }
                }
                }
                this.ystackNegative = ystackNeg;
                        return this.ystack = ystack
                };
                Linearchart_Series_Stack.prototype.exportData = function(from, to) {
                var avg, change, config, count, data, first, fromIndex, i, k, last, max, min, results, sum, times, toIndex, v, values, x, _i, _j, _k, _len, _len1, _ref, _ref1;
                        if (this.times && this.vstack) {
                times = this.times;
                        count = this.centers.length;
                        i = 0;
                        while (i < count && times[i + 1] <= from) {
                i++
                }
                fromIndex = i;
                        while (i < count && times[i + 1] < to) {
                i++
                }
                toIndex = i;
                        results = [];
                        _ref = this.vstack;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                values = _ref[_i];
                        sum = 0;
                        max = - Infinity;
                        min = Infinity;
                        first = null;
                        last = null;
                        count = 0;
                        for (i = _j = fromIndex; _j <= toIndex; i = _j += 1) {
                v = values[i];
                        if (v !== null && !isNaN(v)) {
                sum += v;
                        max = Math.max(max, v);
                        min = Math.min(min, v);
                        if (first === null) {
                first = v
                }
                last = v;
                        count += 1
                }
                }
                if (count > 0) {
                if (count > 0) {
                avg = Math.round(sum / count * 100) / 100
                }
                change = last - first;
                        results.push({sum: sum.toFixed(2), max: max.toFixed(2), min: min, first: first, last: last, count: count, avg: avg.toFixed(2), change: change.toFixed(2)})
                } else {
                results.push(null)
                }
                }
                } else {
                results = (function() {
                var _k, _len1, _ref1, _results;
                        _ref1 = this.series;
                        _results = [];
                        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
                x = _ref1[_k];
                        _results.push(null)
                }
                return _results
                }).call(this)
                }
                data = [];
                        _ref1 = this.series;
                        for (k = _k = 0, _len1 = _ref1.length; _k < _len1; k = ++_k) {
                config = _ref1[k];
                        data.push({name: config.name != null ? config.name : "", values: results[k], config: config})
                }
                return{name: this.options.name, data: data}
                };
                return Linearchart_Series_Stack
        })();
        var Linearchart_Series_Cluster;
        Linearchart_Series_Cluster = (function() {
        function Linearchart_Series_Cluster(scene) {
        this.scene = scene;
                this.stacks = [];
                this.idToStack = {};
                this.paddingSum = 0
        }
        Linearchart_Series_Cluster.prototype.addSeries = function(seriesId, seriesConfig, stackConfig, valueAxis) {
        var stack, stackId;
                if (seriesConfig.stack) {
        stackId = seriesConfig.stack + "#" + seriesConfig.type;
                stack = this.idToStack[stackId];
                if (!stack) {
        stack = this.idToStack[stackId] = new Linearchart_Series_Stack(this.scene, this, stackConfig, valueAxis);
                this.stacks.push(stack)
        }
        } else {
        stack = new Linearchart_Series_Stack(this.scene, this, stackConfig, valueAxis);
                this.stacks.push(stack)
        }
        return stack.addSeries(seriesId, seriesConfig)
        };
                Linearchart_Series_Cluster.prototype.afterInit = function() {
                var stack, _i, _len, _ref, _results;
                        _ref = this.stacks;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                stack = _ref[_i];
                        _results.push(stack.afterInit())
                }
                return _results
                };
                Linearchart_Series_Cluster.prototype.process = function(seriesData) {
                var stack, _i, _len, _ref, _results;
                        _ref = this.stacks;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                stack = _ref[_i];
                        _results.push(stack.process(seriesData))
                }
                return _results
                };
                Linearchart_Series_Cluster.prototype.afterProcess = function() {
                var stack, _i, _len, _ref, _results;
                        _ref = this.stacks;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                stack = _ref[_i];
                        _results.push(stack.afterProcess())
                }
                return _results
                };
                Linearchart_Series_Cluster.prototype.paint = function(context) {
                var stack, _i, _len, _ref, _results;
                        _ref = this.stacks;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                stack = _ref[_i];
                        _results.push(stack.paint(context))
                }
                return _results
                };
                Linearchart_Series_Cluster.prototype.exportData = function(from, to, result) {
                var s, _i, _len, _ref, _results;
                        _ref = this.stacks;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                        _results.push(result.push(s.exportData(from, to)))
                }
                return _results
                };
                Linearchart_Series_Cluster.prototype.computeStackCenterRadius = function(stack, xes, center, radius) {
                var approxStep, centerCoef, i, index, paddingAdd, paddingSubstract, radiusCoef, ss, sum, width, x, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _results;
                        if (xes.length < 2) {
                return
                }
                sum = this.stacks.length;
                        index = this.stacks.indexOf(stack);
                        centerCoef = (index + 0.5) / sum;
                        radiusCoef = 0.5 / sum;
                        paddingSubstract = 0;
                        paddingAdd = 0;
                        _ref = this.stacks;
                        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                ss = _ref[i];
                        paddingSubstract += ss.paddingLeft + ss.paddingRight
                }
                _ref1 = this.stacks;
                        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                ss = _ref1[i];
                        paddingAdd += ss.paddingLeft;
                        if (ss === stack) {
                break
                }
                paddingAdd += ss.paddingRight
                }
                approxStep = xes[1] - xes[0];
                        if (paddingSubstract > approxStep / 2) {
                paddingSubstract = approxStep / 2;
                        paddingAdd = paddingAdd / approxStep * (approxStep - paddingSubstract)
                }
                _results = [];
                        for (i = _k = 0, _ref2 = xes.length - 2; _k <= _ref2; i = _k += 1) {
                x = xes[i];
                        width = xes[i + 1] - x - paddingSubstract;
                        center[i] = x + width * centerCoef + paddingAdd;
                        _results.push(radius[i] = width * radiusCoef)
                }
                return _results
                };
                return Linearchart_Series_Cluster
        })();
        var Base_Bar_Item, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Base_Bar_Item = (function(_super) {
        __extends(Base_Bar_Item, _super);
                Base_Bar_Item.prototype.options = {};
                Base_Bar_Item.prototype.createCoreContainer = false;
                Base_Bar_Item.prototype.baseClass = "bar";
                function Base_Bar_Item(options) {
                this.options = {enclosureClass: null};
                        Base_Helpers.extend(this.options, options);
                        Base_Bar_Item.__super__.constructor.call(this)
                }
        Base_Bar_Item.prototype.init = function() {
        if (!this.options.bare || !this.ui.container) {
        this.ui.container = Base_Helpers.createDom("li", (this.options.enclosureClass != null ? Base_Helpers.wrapClass(this.parent, this.options.enclosureClass) : null))
        }
        if (this.options.onSceneChange || this.options.previewPointerDown) {
        return this.chart().events.addElement(this)
        }
        };
                Base_Bar_Item.prototype.chart = function() {
                if (this.parent instanceof Base_Bar && this.parent.chart) {
                return this.parent.chart
                } else {
                if (this.parent) {
                return this.parent.chart()
                }
                }
                };
                return Base_Bar_Item
        })(Base_View);
        var Base_Settings;
        Base_Settings = (function() {
        Base_Settings.defaults = {container: null, width: null, height: null, minHeight: 165, maxHeight: 2000, minWidth: 100, maxWidth: 4000, theme: null, assetsUrlBase: "", area: {style: {fillColor: "transparent", overlayColor: null}}, advanced: {highDpi: {"default": true, safari: false, firefox: true, msie: true, chrome: false}, pointer: {noClickOnDoubleClick: true, dragSensitivity: 10, doubleClickSensitivity: 40, doubleClickTimeout: 300, longPressTimeout: 500, speedAveragingPeriod: 200}, trackTouches: false, logging: false, style: {messageTextStyle: {fillColor: "#000", font: "15px Arial"}, loadingArcStyle: {r: 35, lineColor: "#444", lineWidth: 2}}, maxCanvasWidth: 2047, maxCanvasHeight: 2047, themeCSSClass: "DVSL-round", assets_applyMethod: "merge", assets: ["base.css"], builtinAssets: {"builtin-logo": Base_images_logo}, exportProxyURL: "http://developers.dvsl.co/export"}, interaction: {resizing: {enabled: true, advanced: {resizerHandleVisibilityTolerance: 45, resizerHandleEnableTolerance: 10}}}, events: {onError: null, onSettingsChange: null, onClick: null, onDoubleClick: null, onRightClick: null, onHoverChange: null, onSelectionChange: null, onChartUpdate: null, onPositionChange: null, onAnimationDone: null, chartUpdateDelay: 0}, title: {enabled: true, enabledOnExport: true, align: "center", margin: 25, style: {font: "20px Arial", fillColor: "#000"}, text: ""}, credits: {enabled: false, enabledOnExport: false, url: "http://zoomcharts.com", image: "builtin-logo", imageScaling: 0.5, location: "outside"}};
                function Base_Settings(scriptName) {
                var k, n, name, prefix, r, regs, v, _i, _j, _len, _len1, _ref, _ref1;
                        this._imageCache = {};
                        this._imageLoading = {};
                        this.applyDefaults(Base_Settings.defaults);
                        regs = [];
                        _ref = [scriptName, "zoomcharts"];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                name = _ref[_i];
                        regs.push(new RegExp("((file:///|https?://)[^/]+/.*?)/?" + name + "(-dev|.min|).js"));
                        regs.push(new RegExp("((file:///|https?://)[^/]+/.*/src)/?" + name))
                }
                _ref1 = document.getElementsByTagName("script");
                        for (k in _ref1) {
                v = _ref1[k];
                        if (!v.src) {
                continue
                }
                for (_j = 0, _len1 = regs.length; _j < _len1; _j++) {
                r = regs[_j];
                        if (n = v.src.match(r)) {
                if (n[1][n[1].length - 1] === "/") {
                prefix = ""
                } else {
                prefix = "/"
                }
                this.assetsUrlBase = n[1] + prefix + "assets/"
                }
                }
                }
                }
        Base_Settings.prototype.apply = function(settings) {
        var changes, theme;
                if (settings == null) {
        return
        }
        changes = {};
                theme = null;
                if (settings.theme != null) {
        theme = settings.theme;
                delete settings.theme
        }
        if (theme) {
        this.applyRec(this, theme, changes, 0);
                settings.theme = theme
        }
        this.applyRec(this, settings, changes, 0);
                return changes
        };
                Base_Settings.prototype.applyDefaults = function(settings) {
                var theme;
                        theme = settings.theme;
                        if (theme) {
                delete settings.theme;
                        this.apply(settings);
                        this.apply(theme);
                        return settings.theme = theme
                } else {
                return this.apply(settings)
                }
                };
                Base_Settings.prototype.applyRec = function(target, changes, changedProperties, depth) {
                var a, f, key, methodProp, o, oa, oo, origValue, skip, ta, value, vv, _i, _len;
                        if (depth > 10) {
                throw"Stack depth greater than 10, seems like recursive settings"
                }
                if (target === void 0) {
                console.error(depth, target, changes);
                        throw"Tried to applyRec on undefined"
                }
                for (key in changes) {
                value = changes[key];
                        origValue = target[key];
                        if (origValue !== void 0 && value === origValue) {
                continue
                }
                a = Base_Helpers.isArray(value);
                        o = Base_Helpers.isObject(value);
                        oa = Base_Helpers.isArray(origValue);
                        oo = Base_Helpers.isObject(origValue);
                        f = Base_Helpers.isFunction(value);
                        skip = false;
                        if (oa && !a) {
                console.error("Applying settings: Setting expected to be array but got something else: " + key + " = " + value);
                        skip = true
                }
                if (value !== null && oo && !o && !f) {
                console.error("Applying settings: Setting expected to be object but got something else: " + key + " = " + value);
                        skip = true
                }
                if (skip) {
                continue
                }
                if (o) {
                if (!(origValue != null)) {
                if (a) {
                target[key] = [];
                        changedProperties[key] = [];
                        oo = true
                } else {
                target[key] = {};
                        changedProperties[key] = {};
                        oo = true
                }
                }
                if (value === null || value === void 0) {
                target[key] = value;
                        changedProperties[key] = value
                }
                if (o && !oo) {
                target[key] = {};
                        changedProperties[key] = {}
                }
                if (key === "container") {
                target[key] = value;
                        changedProperties[key] = value
                } else {
                if (a) {
                methodProp = key + "_applyMethod";
                        if (changes[methodProp] === "merge" || target[methodProp] === "merge") {
                ta = target[key];
                        for (_i = 0, _len = value.length; _i < _len; _i++) {
                vv = value[_i];
                        if (!Base_Helpers.arrayContains(ta, vv)) {
                ta.push(vv)
                }
                }
                } else {
                target[key] = value
                }
                changedProperties[key] = value
                } else {
                if (!changedProperties.hasOwnProperty(key)) {
                changedProperties[key] = {}
                }
                this.applyRec(target[key], value, changedProperties[key], depth + 1)
                }
                }
                } else {
                if (value === void 0) {
                delete target[key];
                        changedProperties[key] = value
                } else {
                target[key] = value;
                        changedProperties[key] = value
                }
                }
                }
                return 1
                };
                Base_Settings.prototype.applyById = function(target, changes, changedProperties) {
                var c, ch, found, o, _i, _j, _len, _len1, _results;
                        _results = [];
                        for (_i = 0, _len = changes.length; _i < _len; _i++) {
                c = changes[_i];
                        found = false;
                        if (c.id) {
                for (_j = 0, _len1 = target.length; _j < _len1; _j++) {
                o = target[_j];
                        if (o.id === c.id) {
                ch = {};
                        this.applyRec(o, c, ch, 0);
                        changedProperties.push(ch);
                        found = true;
                        break
                }
                }
                }
                if (!found) {
                target.push(c);
                        _results.push(changedProperties.push(c))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                Base_Settings.prototype.getAssetUrl = function(asset) {
                if (this.advanced.builtinAssets.hasOwnProperty(asset)) {
                return this.advanced.builtinAssets[asset]
                }
                if (!((this.assetsUrlBase != null) && this.assetsUrlBase.length > 0)) {
                return asset
                }
                if (asset.indexOf("://") !== - 1 || asset.indexOf("data:") === 0 || asset.indexOf("//") === 0) {
                return asset
                }
                if (asset[0] === "/" || asset.indexOf("./") === 0) {
                return asset
                }
                if (this.assetsUrlBase[this.assetsUrlBase.length - 1] !== "/") {
                return this.assetsUrlBase + "/" + asset
                } else {
                return this.assetsUrlBase + asset
                }
                };
                Base_Settings.prototype.getAssetImage = function(asset, onLoad) {
                var loadFunc, url;
                        if (this._imageCache.hasOwnProperty(asset)) {
                return this._imageCache[asset]
                } else {
                if (this._imageLoading.hasOwnProperty(asset)) {
                return null
                } else {
                url = this.getAssetUrl(asset);
                        if (!url) {
                return null
                }
                loadFunc = (function(_this) {
                return function(image) {
                delete _this._imageLoading[asset];
                        _this._imageCache[asset] = image;
                        if (onLoad) {
                return onLoad(image)
                }
                }
                })(this);
                        this._imageLoading[asset] = Base_Helpers.buildImage(url, loadFunc);
                        return this._imageCache[asset]
                }
                }
                };
                return Base_Settings
        })();
        var Netchart_Link, Netchart_Node, Netchart_Scene, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Netchart_Node = (function() {
        Netchart_Node.prototype.id = "";
                Netchart_Node.prototype.x = null;
                Netchart_Node.prototype.y = null;
                Netchart_Node.prototype.isNode = true;
                Netchart_Node.prototype.isLink = false;
                Netchart_Node.prototype.removed = false;
                Netchart_Node.prototype.added = false;
                Netchart_Node.prototype.data = null;
                Netchart_Node.prototype.loading = false;
                Netchart_Node.prototype.links = null;
                Netchart_Node.prototype.dataLinks = null;
                Netchart_Node.prototype.userLock = false;
                Netchart_Node.prototype.expanded = false;
                Netchart_Node.prototype.focused = false;
                Netchart_Node.prototype.fillColor = null;
                Netchart_Node.prototype.lineColor = null;
                Netchart_Node.prototype.lineWidth = 1;
                Netchart_Node.prototype.image = null;
                Netchart_Node.prototype.imageSlicing = null;
                Netchart_Node.prototype.tintImage = false;
                Netchart_Node.prototype.radius = 10;
                Netchart_Node.prototype.hwidth = null;
                Netchart_Node.prototype.label = null;
                Netchart_Node.prototype.labelStyle = null;
                Netchart_Node.prototype.items = [];
                Netchart_Node.prototype.locks = 0;
                Netchart_Node.prototype.currentRadius = 0;
                Netchart_Node.prototype.currentHwidth = 0;
                Netchart_Node.prototype.currentLabel = null;
                Netchart_Node.prototype.currentItems = null;
                Netchart_Node.prototype.Messages = [];                  // keren
                Netchart_Node.prototype.runMovingMessage = false;       // keren
                Netchart_Node.prototype.runMovingMessageType = [];      // keren
                Netchart_Node.prototype.ifSendingMessageIndex = [];     // keren
                Netchart_Node.prototype.movingMessageSpeed = [];     // keren
                Netchart_Node.prototype.toNodeIdIndex = [];             // keren
                Netchart_Node.prototype.tick = null; // keren
                Netchart_Node.prototype.id1 = false; // keren
                Netchart_Node.prototype.id2 = false; // keren

                function Netchart_Node(id) {
                this.id = id;
                        this.links = []
                }
        return Netchart_Node
        })();
        Netchart_Link = (function() {
        function Netchart_Link() {
        }
                Netchart_Link.prototype.from = null;
                Netchart_Link.prototype.to = null;
                Netchart_Link.prototype.removed = false;
                Netchart_Link.prototype.isNode = false;
                Netchart_Link.prototype.isLink = true;
                Netchart_Link.prototype.data = null;
                Netchart_Link.prototype.multiId = null;
                Netchart_Link.prototype.radius = 1;
                Netchart_Link.prototype.length = 1;
                Netchart_Link.prototype.strength = 1;
                Netchart_Link.prototype.label = null;
                Netchart_Link.prototype.labelStyle = null;
                Netchart_Link.prototype.dashed = false;
                Netchart_Link.prototype.currentRadius = 0;
                Netchart_Link.prototype.direction = null;
                Netchart_Link.prototype.fromDecoration = null;
                Netchart_Link.prototype.toDecoration = null;
                Netchart_Link.prototype.items = [];
                Netchart_Link.prototype.toPieValue = 0;
                Netchart_Link.prototype.toPieColor = null;
                Netchart_Link.prototype.toPie0 = null;
                Netchart_Link.prototype.toPie1 = null;
                Netchart_Link.prototype.currentItems = null;
                //Netchart_Link.prototype.runMovingMessageType = [];      // keren
                //Netchart_Link.prototype.ifSendingMessageIndex = [];     // keren
                //Netchart_Link.prototype.toNodeIdIndex = [];  
                //Netchart_Link.prototype.runMovingMessage = null;        // keren
                Netchart_Link.prototype.runMovingMessageStepX = null;   // keren
                Netchart_Link.prototype.runMovingMessageStepY = null;   // keren
                //Netchart_Link.prototype.runMovingMessageType = null;    // keren
                Netchart_Link.prototype.Messages = [];  // keren
                Netchart_Link.prototype.tick = null;    // keren
                Netchart_Link.prototype.otherEnd = function(node) {
                if (node === this.from) {
                return this.to
                }
                if (node === this.to) {
                return this.from
                }
                return null
                };
                Netchart_Link.prototype.commonNode = function(link) {
                if (this.from === link.from || this.from === link.to) {
                return this.from
                }
                if (this.to === link.from || this.to === link.to) {
                return this.to
                }
                return null
                };
                return Netchart_Link
        })();
        Netchart_Scene = (function(_super) {
        __extends(Netchart_Scene, _super);
                Netchart_Scene.prototype.hoverNode = null;
                Netchart_Scene.prototype.hoverLink = null;
                Netchart_Scene.prototype.hoverItem = null;
                Netchart_Scene.prototype.centerX = 0;
                Netchart_Scene.prototype.centerY = 0;
                Netchart_Scene.prototype.zoom = 1;
                Netchart_Scene.prototype.autoZoomActive = false;
                Netchart_Scene.prototype.layoutActive = true;
                function Netchart_Scene() {
                Netchart_Scene.__super__.constructor.call(this);
                        this._nodes = [];
                        this._links = [];
                        this._nodesDel = null;
                        this._linksDel = null;
                        this.userNodeIds = {};
                        this.positionedNodeIds = {};
                        this.selection = [];
                        this.idToNode = {};
                        this.idToLink = {};
                        this.multilinks = null;
                        this.clearModified()
                }
        Netchart_Scene.prototype.nodes = function() {
        var n, node, _i, _len, _ref;
                if (this._nodesDel === null) {
        return this._nodes
        }
        n = [];
                _ref = this._nodes;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
                if (!this._nodesDel[node.id]) {
        n.push(node)
        }
        }
        this._nodes = n;
                this._nodesDel = null;
                return n
        };
                Netchart_Scene.prototype.links = function() {
                var n, node, _i, _len, _ref;
                        if (this._linksDel === null) {
                return this._links
                }
                n = [];
                        _ref = this._links;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        if (!this._linksDel[node.id]) {
                n.push(node)
                }
                }
                this._links = n;
                        this._linksDel = null;
                        return n
                };
                Netchart_Scene.prototype.addNode = function(nodeId) {
                var node;
                        this.nodes();
                        if (this.idToNode.hasOwnProperty(nodeId)) {
                node = this.idToNode[nodeId];
                        node.removed = false;
                        if (!node.added) {
                node.added = true
                }
                } else {
                if (this.deletedNodes.hasOwnProperty(nodeId)) {
                node = this.deletedNodes[nodeId];
                        node.removed = false;
                        if (!node.added) {
                node.added = true
                }
                this.idToNode[nodeId] = node;
                        this._nodes.push(node);
                        delete this.deletedNodes[nodeId]
                } else {
                node = new Netchart_Node(nodeId);
                        node.added = true;
                        this.idToNode[nodeId] = node;
                        this._nodes.push(node);
                        this.newNodes[nodeId] = node
                }
                }
                this.modifiedNodes[nodeId] = node;
                        return node
                };
                Netchart_Scene.prototype.touchNode = function(node) {
                return this.modifiedNodes[node.id] = node
                };
                Netchart_Scene.prototype.removeNode = function(node) {
                var nodeId;
                        nodeId = node.id;
                        if (!this.idToNode.hasOwnProperty(nodeId)) {
                return
                }
                Base_Helpers.removeFromArray(this.selection, node);
                        if (this.newNodes.hasOwnProperty(node.id)) {
                return this.deleteNode(node)
                } else {
                if (!node.removed) {
                node.removed = true
                }
                node.added = false;
                        return this.modifiedNodes[nodeId] = node
                }
                };
                Netchart_Scene.prototype.deleteNode = function(node) {
                if (this._nodesDel === null) {
                this._nodesDel = {}
                }
                this._nodesDel[node.id] = true;
                        Base_Helpers.removeFromArray(this.selection, node);
                        delete this.newNodes[node.id];
                        delete this.modifiedNodes[node.id];
                        delete this.idToNode[node.id];
                        return this.deletedNodes[node.id] = node
                };
                Netchart_Scene.prototype.addLink = function(linkId, from, to) {
                var link;
                        if (!(this.idToNode.hasOwnProperty(from) && this.idToNode.hasOwnProperty(to))) {
                throw"Cannot add link - missing nodes"
                }
                this.links();
                        if (this.idToLink.hasOwnProperty(linkId)) {
                link = this.idToLink[linkId];
                        link.removed = false;
                        if (!link.added) {
                link.added = true
                }
                } else {
                if (this.deletedLinks.hasOwnProperty(linkId)) {
                link = this.deletedLinks[linkId];
                        delete this.deletedLinks[linkId];
                        this.idToLink[linkId] = link;
                        this._links.push(link);
                        link.removed = false;
                        if (!link.added) {
                link.added = true
                }
                } else {
                link = new Netchart_Link();
                        link.added = true;
                        link.id = linkId;
                        this._links.push(link);
                        this.idToLink[linkId] = link;
                        this.newLinks[linkId] = link
                }
                }
                link.from = null;
                        link.to = null;
                        link.multiId = from < to ? from + "#" + to : to + "#" + from;
                        this.modifiedLinks[linkId] = link;
                        return link
                };
                Netchart_Scene.prototype.removeLink = function(link) {
                var linkId;
                        linkId = link.id;
                        if (!this.idToLink.hasOwnProperty(linkId)) {
                return
                }
                Base_Helpers.removeFromArray(this.selection, link);
                        if (this.newLinks.hasOwnProperty(linkId)) {
                return this.deleteLink(link)
                } else {
                link.added = false;
                        if (!link.removed) {
                link.removed = true
                }
                return this.modifiedLinks[linkId] = link
                }
                };
                Netchart_Scene.prototype.deleteLink = function(link) {
                if (this._linksDel === null) {
                this._linksDel = {}
                }
                this._linksDel[link.id] = true;
                        Base_Helpers.removeFromArray(this.selection, link);
                        if (this.newLinks.hasOwnProperty(link.id)) {
                delete this.newLinks[link.id]
                } else {
                this.deletedLinks[link.id] = link
                }
                delete this.modifiedLinks[link.id];
                        return delete this.idToLink[link.id]
                };
                Netchart_Scene.prototype.touchLink = function(link) {
                return this.modifiedLinks[link.id] = link
                };
                Netchart_Scene.prototype.getModified = function() {
                return[this.newNodes, this.newLinks, this.modifiedNodes, this.modifiedLinks, this.deletedNodes, this.deletedLinks]
                };
                Netchart_Scene.prototype.hasTopologyChanges = function() {
                return Base_Helpers.hasProperties(this.newNodes) || Base_Helpers.hasProperties(this.newLinks) || Base_Helpers.hasProperties(this.deletedNodes) || Base_Helpers.hasProperties(this.deletedLinks)
                };
                Netchart_Scene.prototype.hasStyleChanges = function() {
                return this.hasTopologyChanges() || Base_Helpers.hasProperties(this.modifiedLinks) || Base_Helpers.hasProperties(this.modifiedNodes)
                };
                Netchart_Scene.prototype.clearModified = function() {
                this.newNodes = {};
                        this.newLinks = {};
                        this.modifiedNodes = {};
                        this.modifiedLinks = {};
                        this.deletedNodes = {};
                        return this.deletedLinks = {}
                };
                Netchart_Scene.prototype.xyInChart = function(x, y) {
                return(x >= this.x0) && (x < this.x0 + this.width) && (y >= this.y0) && (y < this.y0 + this.height)
                };
                Netchart_Scene.prototype.toDisplay = function(x, y) {
                return[(x - this.centerX) * this.zoom + this.x0 + this.width * 0.5, (y - this.centerY) * this.zoom + this.y0 + this.height * 0.5]
                };
                Netchart_Scene.prototype.fromDisplay = function(x, y) {
                return[(x - this.x0 - this.width * 0.5) / this.zoom + this.centerX, (y - this.y0 - this.height * 0.5) / this.zoom + this.centerY]
                };
                Netchart_Scene.prototype.toDisplayTransform = function(x, y) {
                return[this.zoom, this.x0 + this.width * 0.5 - this.centerX * this.zoom, this.zoom, this.y0 + this.height * 0.5 - this.centerY * this.zoom]
                };
                Netchart_Scene.prototype.setActiveObject = function(obj, item) {
                if (this.hoverNode != null) {
                this.touchNode(this.hoverNode);
                        this.hoverNode.hovered = false
                }
                if (this.hoverLink != null) {
                this.touchLink(this.hoverLink);
                        this.hoverLink.hovered = false
                }
                this.hoverNode = null;
                        this.hoverLink = null;
                        this.hoverItem = item;
                        if (obj instanceof Netchart_Node) {
                this.hoverNode = obj;
                        obj.hovered = true;
                        return this.touchNode(this.hoverNode)
                } else {
                if (obj instanceof Netchart_Link) {
                this.hoverLink = obj;
                        obj.hovered = true;
                        return this.touchLink(this.hoverLink)
                } else {
                if (obj !== null) {
                throw"scene.setActiveObject invalid active object type " + obj
                }
                }
                }
                };
                Netchart_Scene.prototype.getVisibleBounds = function() {
                var x0, x1, y0, y1, _ref, _ref1;
                        _ref = this.fromDisplay(this.x0, this.y0), x0 = _ref[0], y0 = _ref[1];
                        _ref1 = this.fromDisplay(this.x0 + this.width, this.y0 + this.height), x1 = _ref1[0], y1 = _ref1[1];
                        return[x0, y0, x1, y1]
                };
                Netchart_Scene.prototype.getGraphBounds = function() {
                var node, nodes, r, w, x, x0, x1, y, y0, y1, z, _i, _len;
                        nodes = this.nodes();
                        if (nodes.length === 0) {
                return[0, 0, 0, 0]
                }
                x0 = Infinity;
                        x1 = - Infinity;
                        y0 = Infinity;
                        y1 = - Infinity;
                        z = this.zoom;
                        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
                node = nodes[_i];
                        if (node.removed) {
                continue
                }
                x = node.x;
                        y = node.y;
                        r = node.currentRadius;
                        if (node.renderRadius) {
                r = node.renderRadius / z
                }
                w = node.currentHwidth;
                        if (node.renderHwidth) {
                w = node.renderHwidth / z
                }
                w = w + r * 0.2;
                        r = r * 1.2;
                        x0 = Math.min(x0, x - w);
                        x1 = Math.max(x1, x + w);
                        y0 = Math.min(y0, y - r);
                        y1 = Math.max(y1, y + r)
                }
                return[x0, y0, x1, y1]
                };
                Netchart_Scene.prototype.findNodeAt = function(displayX, displayY, tolerance) {
                var best, distanceSq, insideSq, min, n, nodes, r, toleranceSq, x, y, _i, _len, _ref;
                        nodes = this.nodes();
                        _ref = this.fromDisplay(displayX, displayY), x = _ref[0], y = _ref[1];
                        min = tolerance / this.zoom;
                        best = null;
                        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
                n = nodes[_i];
                        if (n.removed) {
                continue
                }
                r = n.targetRadius;
                        distanceSq = (x - n.x) * (x - n.x) + (y - n.y) * (y - n.y);
                        toleranceSq = (r + min) * (r + min);
                        if (distanceSq < toleranceSq) {
                insideSq = r * r;
                        if (distanceSq < insideSq) {
                return n
                } else {
                min = Math.sqrt(distanceSq) - r
                }
                }
                }
                return best
                };
                Netchart_Scene.prototype.findLinkOrNodeAt = function(displayX, displayY, tolerance) {
                var best, cx, cy, distanceSq, dr, insideSq, l, links, min, n, nodes, nx, ny, r, toleranceSq, w, x, x0, x1, y, y0, y1, _i, _j, _len, _len1, _ref, _ref1, _ref2;
                        nodes = this.nodes();
                        _ref = this.fromDisplay(displayX, displayY), x = _ref[0], y = _ref[1];
                        min = tolerance / this.zoom;
                        best = null;
                        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
                n = nodes[_i];
                        if (n.removed) {
                continue
                }
                r = n.targetRadius;
                        w = n.hwidth;
                        nx = n.x;
                        ny = n.y;
                        if (r < w) {
                dr = w - r;
                        _ref1 = Base_Geometry.closestPointToLine(nx - dr, ny, nx + dr, ny, x, y), nx = _ref1[0], ny = _ref1[1]
                }
                distanceSq = (x - nx) * (x - nx) + (y - ny) * (y - ny);
                        toleranceSq = (r + min) * (r + min);
                        if (distanceSq < toleranceSq) {
                insideSq = r * r;
                        if (distanceSq < insideSq) {
                return n
                } else {
                min = Math.sqrt(distanceSq) - r;
                        best = n
                }
                }
                }
                links = this.links();
                        for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
                l = links[_j];
                        if (l.removed) {
                continue
                }
                r = l.targetRadius;
                        x0 = l.from.x;
                        y0 = l.from.y;
                        x1 = l.to.x;
                        y1 = l.to.y;
                        _ref2 = Base_Geometry.closestPointToLine(x0, y0, x1, y1, x, y), cx = _ref2[0], cy = _ref2[1];
                        distanceSq = (x - cx) * (x - cx) + (y - cy) * (y - cy);
                        toleranceSq = (r + min) * (r + min);
                        if (distanceSq < toleranceSq) {
                min = Math.sqrt(distanceSq) - r;
                        best = l
                }
                }
                return best
                };
                Netchart_Scene.prototype.findItem = function(displayX, displayY, obj, tolerance) {
                var h, hi, i, w, x, y, _i, _j, _len, _len1, _ref, _ref1;
                        if (!obj) {
                return null
                }
                hi = this.hoverItem;
                        _ref = obj.currentItems;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                i = _ref[_i];
                        if (i.data === hi && i.hwidth) {
                x = i.curx;
                        y = i.cury;
                        w = i.hwidth;
                        h = i.hheight;
                        if (displayX > x - w - tolerance && displayX < x + w + tolerance && displayY > y - h - tolerance && displayY < y + h + tolerance) {
                return i
                }
                }
                }
                _ref1 = obj.currentItems;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                i = _ref1[_j];
                        if (!i.hwidth) {
                continue
                }
                x = i.curx;
                        y = i.cury;
                        w = i.hwidth;
                        h = i.hheight;
                        if (displayX > x - w - tolerance && displayX < x + w + tolerance && displayY > y - h - tolerance && displayY < y + h + tolerance) {
                return i.data
                }
                }
                return null
                };
                Netchart_Scene.prototype.updateMultilinks = function() {
                var l, link, links, multiId, multiLinks, _i, _len;
                        if (!this.hasTopologyChanges()) {
                return
                }
                links = this.links();
                        multiLinks = {};
                        for (_i = 0, _len = links.length; _i < _len; _i++) {
                link = links[_i];
                        multiId = link.multiId;
                        if (!multiLinks.hasOwnProperty(multiId)) {
                multiLinks[multiId] = link
                } else {
                l = multiLinks[multiId];
                        if (Base_Helpers.isArray(l)) {
                l.push(link)
                } else {
                multiLinks[multiId] = [multiLinks[multiId], link]
                }
                }
                }
                return this.multilinks = multiLinks
                };
                return Netchart_Scene
        })(Base_Scene);
        var Netchart_Layout;
        Netchart_Layout = (function() {
        Netchart_Layout.prototype.animationPriority = 1000;
                function Netchart_Layout(chart) {
                this.chart = chart;
                        this.scene = chart.scene;
                        this.time = null;
                        this.idleSince = null;
                        this.nodeMap = null;
                        this.random = new Base_Random(1);
                        this.springs = new Netchart_Layout_TimedSpringEmbedder(this.random);
                        this.animationInProgress = false
                }
        Netchart_Layout.prototype.doAnimations = function(event) {
        var aliveProportion, animatingChanges, dt, dynamicLayout, freezeProportion, idleTimeout, majorChanges, newNodes, styleChanges, timeout, topologyChanges, _ref;
                this.settings = this.scene.settings.layout;
                idleTimeout = this.settings.layoutFreezeTimeout;
                if (!this.time || !this.animationInProgress) {
        dt = 30
        } else {
        dt = Math.min(1000, event.time - this.time)
        }
        this.time = event.time;
                animatingChanges = this.animateChanges(event.time, event.changes.newGraph, dt);
                topologyChanges = this.scene.hasTopologyChanges();
                styleChanges = this.scene.hasStyleChanges();
                if (animatingChanges || topologyChanges || event.changes.coordinates || event.changes.layout || this.idleSince === null || event.changes.bounds) {
        this.idleSince = this.time
        }
        newNodes = {};
                majorChanges = false;
                if (topologyChanges) {
        this.random = new Base_Random(1);
                _ref = this.placeNewNodes(), newNodes = _ref[0], majorChanges = _ref[1]
        }
        dynamicLayout = this.settings.mode === "dynamic";
                if (dynamicLayout && this.idleSince + idleTimeout > this.time) {
        freezeProportion = (this.time - this.idleSince) / idleTimeout;
                aliveProportion = 1 - Math.pow(Math.max(0, (freezeProportion - 0.5) * 2), 2);
                timeout = majorChanges ? this.settings.initialLayoutMaxTime : this.settings.incrementalLayoutMaxTime;
                this.doLayout(event.time, dt * aliveProportion, topologyChanges | event.changes.layout, styleChanges, newNodes, timeout, majorChanges, dynamicLayout);
                if (this.springs.forceReductionFactor > 0.4 && this.scene.nodes().length > 1) {
        this.idleSince = this.time
        }
        this.placePies();
                this.animationInProgress = true;
                event.changes.position = true
        } else {
        if (animatingChanges) {
        this.animationInProgress = true;
                event.changes.position = true
        } else {
        this.animationInProgress = false
        }
        }
        if (this.animationInProgress) {
        return event.animating = true
        }
        };
                Netchart_Layout.prototype.animateChanges = function(time, instant, dt) {
                var animating, fadeProp, fadeTime, finishProp, l, link, linksToRemove, n, node, nodesToRemove, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3;
                        animating = false;
                        fadeTime = this.settings.fadeTime;
                        instant || (instant = !(fadeTime > 0) || dt > fadeTime);
                        nodesToRemove = [];
                        linksToRemove = [];
                        if (instant) {
                _ref = this.scene.nodes();
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        if (node.removed) {
                nodesToRemove.push(node)
                } else {
                if (node.hwidth !== node.currentHwidth) {
                node.added = false;
                        node.currentRadius = node.targetRadius;
                        node.currentHwidth = node.hwidth
                }
                }
                }
                _ref1 = this.scene.links();
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                link = _ref1[_j];
                        if (link.removed) {
                linksToRemove.push(link)
                } else {
                if (link.targetRadius !== link.currentRadius) {
                link.added = false;
                        link.currentRadius = link.targetRadius
                }
                }
                }
                } else {
                fadeProp = instant || !(fadeTime > 0) ? 0 : Math.max(0, Math.pow(0.2, dt / fadeTime));
                        finishProp = 0.01;
                        _ref2 = this.scene.nodes();
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                node = _ref2[_k];
                        if (node.added === true) {
                node.added = time
                }
                if (node.added + fadeTime < time) {
                node.added = false
                }
                if (node.removed === true) {
                node.removed = time
                }
                if (node.removed) {
                animating = true;
                        node.currentRadius = node.currentRadius * fadeProp;
                        node.currentHwidth = node.currentHwidth * fadeProp;
                        if (node.removed + fadeTime < time) {
                nodesToRemove.push(node)
                }
                } else {
                if (node.hwidth !== node.currentHwidth) {
                animating = true;
                        node.currentRadius = node.currentRadius * fadeProp + node.targetRadius * (1 - fadeProp);
                        node.currentHwidth = node.currentHwidth * fadeProp + node.hwidth * (1 - fadeProp);
                        if (Math.abs(node.currentRadius - node.targetRadius) < finishProp * node.targetRadius) {
                node.currentRadius = node.targetRadius;
                        node.currentHwidth = node.hwidth
                }
                }
                }
                }
                _ref3 = this.scene.links();
                        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                link = _ref3[_l];
                        if (link.added === true) {
                link.added = time
                }
                if (link.added + fadeTime < time) {
                link.added = false
                }
                if (link.removed === true) {
                link.removed = time
                }
                if (link.removed) {
                animating = true;
                        link.currentRadius = link.currentRadius * fadeProp;
                        if (link.removed + fadeTime < time) {
                linksToRemove.push(link)
                }
                } else {
                if (link.targetRadius !== link.currentRadius) {
                animating = true;
                        link.currentRadius = link.currentRadius * fadeProp + link.targetRadius * (1 - fadeProp);
                        if (Math.abs(link.currentRadius - link.targetRadius) < finishProp * link.targetRadius) {
                link.currentRadius = link.targetRadius
                }
                }
                }
                }
                }
                for (_m = 0, _len4 = linksToRemove.length; _m < _len4; _m++) {
                l = linksToRemove[_m];
                        this.scene.deleteLink(l)
                }
                for (_n = 0, _len5 = nodesToRemove.length; _n < _len5; _n++) {
                n = nodesToRemove[_n];
                        this.scene.deleteNode(n)
                }
                return animating
                };
                Netchart_Layout.prototype.resetLayout = function() {
                var n, newNodes, _i, _len, _ref;
                        this.random = new Base_Random(1);
                        this.springs.random = this.random;
                        newNodes = {};
                        _ref = this.scene.nodes();
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                n = _ref[_i];
                        newNodes[n.id] = n;
                        n.x = 0;
                        n.y = 0;
                        n.userLock = false
                }
                this.doLayout(new Date().getTime(), 1, true, true, newNodes, 10000, true);
                        return this.idleSince = null
                };
                Netchart_Layout.prototype.placeNewNodes = function() {
                var count, cx, cy, dx, dy, iln, len, link, majorChanges, n, neighbor, neighborCount, newNodes, nn, node, nx, ny, randomness, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
                        newNodes = {};
                        majorChanges = false;
                        _ref = this.scene.nodes();
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                n = _ref[_i];
                        if (n.x === null || n.y === null) {
                newNodes[n.id] = true
                }
                }
                _ref1 = this.scene.nodes();
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                n = _ref1[_j];
                        randomness = 1;
                        if (newNodes.hasOwnProperty(n.id)) {
                neighborCount = 0;
                        cx = 0;
                        cy = 0;
                        randomness = 1;
                        _ref2 = n.links;
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                link = _ref2[_k];
                        nn = link.otherEnd(n);
                        if (!newNodes.hasOwnProperty(nn.id)) {
                neighbor = nn;
                        cx += nn.x;
                        cy += nn.y;
                        neighborCount += 1
                }
                }
                if (neighborCount > 1) {
                nx = cx / neighborCount;
                        ny = cy / neighborCount;
                        randomness = 0.5
                } else {
                if (neighborCount === 1) {
                count = 0;
                        dx = 0;
                        dy = 0;
                        _ref3 = neighbor.links;
                        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                link = _ref3[_l];
                        node = link.otherEnd(neighbor);
                        if (node === n || newNodes.hasOwnProperty(node.id)) {
                continue
                }
                dx += node.x - neighbor.x;
                        dy += node.y - neighbor.y;
                        count += 1
                }
                if (count > 0) {
                len = Math.sqrt(dx * dx + dy * dy);
                        if (len > 0) {
                iln = 1 / (len * count);
                        dx *= iln;
                        dy *= iln;
                        nx = neighbor.x - dx * neighbor.currentRadius * 1.2;
                        ny = neighbor.y - dy * neighbor.currentRadius * 1.2;
                        randomness = 0.2
                } else {
                nx = neighbor.x;
                        ny = neighbor.y
                }
                } else {
                majorChanges = true;
                        nx = neighbor.x;
                        ny = neighbor.y
                }
                } else {
                majorChanges = true;
                        nx = 0;
                        ny = 0
                }
                }
                n.x = nx + (this.random.get() - 0.5) * randomness * (n.currentRadius + 1);
                        n.y = ny + (this.random.get() - 0.5) * randomness * (n.currentRadius + 1)
                }
                }
                return[newNodes, majorChanges]
                };
                Netchart_Layout.prototype.placePies = function() {
                var PI2, angle, link, mul, node, offCenter, offset, pieLinks, sum, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _results;
                        PI2 = Math.PI * 2;
                        pieLinks = [];
                        _ref = this.scene.nodes();
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        sum = 0;
                        _ref1 = node.links;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                link = _ref1[_j];
                        if (link.to === node && link.toPieValue > 0) {
                sum += link.toPieValue;
                        pieLinks.push(link);
                        link._angle = Math.atan2(link.to.y - link.from.y, link.to.x - link.from.x)
                }
                }
                if (sum > 0) {
                pieLinks.sort(function(a, b) {
                return a._angle - b._angle
                });
                        mul = PI2 / sum;
                        angle = 0;
                        offset = 0;
                        for (_k = 0, _len2 = pieLinks.length; _k < _len2; _k++) {
                link = pieLinks[_k];
                        link.toPie0 = angle;
                        angle += link.toPieValue * mul;
                        link.toPie1 = angle;
                        offCenter = link._angle - (link.toPie0 + link.toPie1) / 2;
                        if (offCenter < 0) {
                offCenter += Math.PI * 2
                }
                offset += offCenter
                }
                offset /= pieLinks.length;
                        offset -= Math.PI;
                        for (_l = 0, _len3 = pieLinks.length; _l < _len3; _l++) {
                link = pieLinks[_l];
                        link.toPie0 += offset;
                        link.toPie1 += offset
                }
                _results.push(pieLinks = [])
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                Netchart_Layout.prototype.doLayout = function(time, dt, topologyChanges, styleChanges, newNodes, timeout, reset, incremental) {
                var appearingNodes, aspect, degreeModifier, effectiveAspect, fadeTime, hasOtherConnections, l, length, ml, mlid, multilinks, n, nodeSpacing, nodes, realLinks, s1, strength, visibility, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
                        if (reset == null) {
                reset = false
                }
                if (incremental == null) {
                incremental = true
                }
                fadeTime = this.scene.settings.layout.fadeTime;
                        aspect = (this.scene.width + 1) / (this.scene.height + 1);
                        if (!(aspect > 0)) {
                aspect = null
                }
                effectiveAspect = this.scene.settings.layout.aspectRatio ? aspect : null;
                        nodeSpacing = this.settings.nodeSpacing;
                        degreeModifier = 1;
                        nodes = this.scene.nodes();
                        appearingNodes = false;
                        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
                n = nodes[_i];
                        n.locked = n.userLock || n.locks > 0;
                        appearingNodes || (appearingNodes = n.added || n.removed);
                        if (n.added) {
                n.visibility = 1 - 0.8 * (time - n.added) / fadeTime
                } else {
                if (n.removed) {
                n.visibility = 0.2 + 0.8 * (time - n.removed) / fadeTime
                } else {
                n.visibility = 1
                }
                }
                }
                multilinks = {};
                        realLinks = [];
                        _ref = this.scene.links();
                        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                l = _ref[_j];
                        mlid = l.multiId;
                        strength = l.targetStrength;
                        length = l.targetLength;
                        visibility = 1;
                        if (l.removed || l.added) {
                hasOtherConnections = l.from.links.length > 1 && l.to.links.length > 1;
                        if (hasOtherConnections || l.removed) {
                s1 = 0.2
                } else {
                s1 = strength
                }
                if (l.removed) {
                visibility = 1 - (time - l.removed) / fadeTime
                }
                if (l.added) {
                visibility = (time - l.added) / fadeTime;
                        length = 0.2 + (length - 0.2) * visibility
                }
                strength = strength * visibility + s1 * (1 - visibility)
                }
                if (!multilinks.hasOwnProperty(mlid)) {
                ml = {from: l.from, to: l.to, strength: strength, length: length, visibility: visibility};
                        multilinks[mlid] = ml;
                        realLinks.push(ml)
                } else {
                ml = multilinks[mlid];
                        ml.strength = Math.max(strength, ml.strength);
                        ml.length = Math.max(length, ml.length);
                        ml.visibility = Math.max(visibility, ml.visibility)
                }
                }
                this.springs.updateParams(nodeSpacing, degreeModifier, effectiveAspect);
                        if (reset || Base_Helpers.hasProperties(newNodes)) {
                for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
                n = nodes[_k];
                        n.locked || (n.locked = !newNodes.hasOwnProperty(n.id))
                }
                this.springs.updateGraph(nodes, realLinks, topologyChanges);
                        if (reset || this.scene.settings.layout.globalLayoutOnChanges) {
                this.springs.updateParams(nodeSpacing, degreeModifier, aspect);
                        this.springs.globalLayout(nodes, timeout, reset);
                        this.springs.updateParams(nodeSpacing, degreeModifier, effectiveAspect)
                } else {
                this.springs.timedLayout(nodes, dt * 0.001)
                }
                }
                if (incremental || appearingNodes) {
                if (!incremental) {
                for (_l = 0, _len3 = nodes.length; _l < _len3; _l++) {
                n = nodes[_l];
                        n.locked || (n.locked = !n.removed && !n.added)
                }
                }
                this.springs.updateGraph(nodes, realLinks, topologyChanges);
                        return this.springs.timedLayout(nodes, dt * 0.001)
                }
                };
                return Netchart_Layout
        })();
        var Netchart_Layers;
        Netchart_Layers = (function() {
        Netchart_Layers.prototype.scene = null;
                Netchart_Layers.prototype.container = null;
                Netchart_Layers.prototype.background = null;
                Netchart_Layers.prototype.canvas = null;
                Netchart_Layers.prototype.outerBorder = null;
                Netchart_Layers.prototype.mouseTrackLayer = null;
                function Netchart_Layers(scene) {
                this.scene = scene;
                        this.container = Base_Helpers.createDom("div", "DVSL-container");
                        this.container.style.position = "relative";
                        this.container.style.width = "100%";
                        this.container.style.height = "100%";
                        this.background = Base_Helpers.createDom("div", "DVSL-background", null, this.container);
                        this.setContainerStyle(this.background);
                        this.canvas = Base_Helpers.createDom("canvas", "NetChart-canvas", null, this.container);
                        this.setContainerStyle(this.canvas);
                        this.outerBorder = Base_Helpers.createDom("div", "DVSL-border", null, this.container);
                        this.setContainerStyle(this.outerBorder);
                        this.resizerBar = Base_Helpers.createDom("div", "DVSL-resizer", null, this.container);
                        this.mouseTrackLayer = Base_Helpers.createDom("div", null, null, this.container);
                        this.setContainerStyle(this.mouseTrackLayer);
                        this.updateSettings(this.scene.settings, "init");
                        this.updateSize()
                }
        Netchart_Layers.prototype.updateSize = function() {
        var setHeight, setWidth;
                setWidth = this.scene.settings.width;
                setHeight = this.scene.settings.height;
                if (this.scene.chartWidth > this.scene.settings.container.clientWidth) {
        setWidth = this.scene.chartWidth
        }
        if (this.scene.chartHeight > this.scene.settings.container.clientHeight) {
        setHeight = this.scene.chartHeight
        }
        if (setWidth) {
        this.container.style.width = "" + setWidth + "px"
        }
        if (setHeight) {
        this.container.style.height = "" + setHeight + "px"
        }
        this.resizerBar.style.width = "" + this.scene.width + "px";
                return this.resizerBar.style.left = "" + this.scene.x0 + "px"
        };
                Netchart_Layers.prototype.updateSettings = function(changes) {
                if (Base_Helpers.hasProp(changes, "advanced/themeCSSClass")) {
                if (this.curTheme != null) {
                Base_Helpers.removeClass(this.container, this.curTheme)
                }
                this.curTheme = this.scene.settings.advanced.themeCSSClass;
                        return Base_Helpers.addClass(this.container, this.curTheme)
                }
                };
                Netchart_Layers.prototype.setContainerStyle = function(c) {
                c.style.position = "absolute";
                        c.style.left = "0px";
                        c.style.right = "0px";
                        c.style.top = "0px";
                        return c.style.bottom = "0px"
                };
                return Netchart_Layers
        })();
        var Netchart_Styles;
        Netchart_Styles = (function() {
        Netchart_Styles.prototype.animationPriority = 1003;
                function Netchart_Styles(chart) {
                this.chart = chart;
                        this.scene = chart.scene;
                        this.time = null
                }
        Netchart_Styles.prototype.sortRules = function(rules) {
        var name, names, _;
                names = (function() {
                var _results;
                        _results = [];
                        for (name in rules) {
                _ = rules[name];
                        _results.push(name)
                }
                return _results
                })();
                names.sort();
                return(function() {
                var _i, _len, _results;
                        _results = [];
                        for (_i = 0, _len = names.length; _i < _len; _i++) {
                name = names[_i];
                        _results.push(rules[name])
                }
                return _results
                })()
        };
                Netchart_Styles.prototype.doAnimations = function(event) {
                var fadeout, g, id2, id3, link, link1, links, n, node, node1, nodes, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4;
                        if (!(event.changes.settings || Base_Helpers.hasProperties(this.scene.modifiedNodes) || Base_Helpers.hasProperties(this.scene.modifiedLinks))) {
                return
                }
                this.nodeRules = this.sortRules(this.scene.settings.style.nodeRules);
                        this.linkRules = this.sortRules(this.scene.settings.style.linkRules);
                        this.nodeRadiusChanged = Base_Helpers.hasProperties(this.scene.newNodes) | Base_Helpers.hasProperties(this.scene.deletedNodes);
                        this.linkRadiusChanged = Base_Helpers.hasProperties(this.scene.newLinks) | Base_Helpers.hasProperties(this.scene.deletedLinks);
                        fadeout = this.scene.settings.navigation.mode === "focusnodes" && this.scene.settings.navigation.focusAutoFadeout;
                        g = event.context;
                        this.itemBase = this.scene.settings.style.item;
                        this.nodeLabelBase = this.scene.settings.style.nodeLabel;
                        this.linkLabelBase = this.scene.settings.style.linkLabel;
                        this.itemRenderer = new Base_MarkerRenderer(this.chart);
                        if (event.changes.settings) {
                this.nodeRadiusChanged = true;
                        this.linkRadiusChanged = true;
                        _ref = this.scene.nodes();
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        this.updateNode(node, fadeout)
                }
                _ref1 = this.scene.links();
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                link = _ref1[_j];
                        this.updateLink(link, fadeout);
                        this.postprocessLink(link, g)
                }
                } else {
                _ref2 = this.scene.modifiedNodes;
                        for (id2 in _ref2) {
                node1 = _ref2[id2];
                        this.updateNode(node1, fadeout)
                }
                _ref3 = this.scene.modifiedLinks;
                        for (id3 in _ref3) {
                link1 = _ref3[id3];
                        this.updateLink(link1, fadeout);
                        this.postprocessLink(link1, g)
                }
                }
                if (this.nodeRadiusChanged || (fadeout && event.changes.navigation)) {
                nodes = this.scene.nodes();
                        this.computeRadiuses(nodes, this.scene.settings.style.nodeAutoScaling, this.scene.settings.style.nodeRadiusExtent, fadeout);
                        for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
                n = nodes[_k];
                        this.postprocessNode(n, g)
                }
                } else {
                _ref4 = this.scene.modifiedNodes;
                        for (id2 in _ref4) {
                node1 = _ref4[id2];
                        this.postprocessNode(node1, g)
                }
                }
                if (this.linkRadiusChanged || (fadeout && event.changes.navigation)) {
                links = this.scene.links();
                        this.computeRadiuses(links, this.scene.settings.style.linkAutoScaling, this.scene.settings.style.linkRadiusExtent, fadeout);
                        this.computeStrengths(links, this.scene.settings.style.linkStrengthAutoScaling, this.scene.settings.style.linkStrengthExtent);
                        this.computeLengths(links, this.scene.settings.style.linkLengthAutoScaling, this.scene.settings.style.linkLengthExtent);
                        return links.sort(function(a, b) {
                        if (a.targetRadius === b.targetRadius) {
                        return 0
                        }
                        if (a.targetRadius > b.targetRadius) {
                        return 1
                        } else {
                        return - 1
                        }
                        })
                }
                };
                Netchart_Styles.prototype.updateNode = function(node, fadeout) {
                var active, l, originalRadius, removedColor, _i, _len, _ref;
                        active = node === this.scene.hoverNode;
                        originalRadius = node.radius;
                        Base_Helpers.extend(node, this.scene.settings.style.node);
                        if (!node.radius) {
                node.radius = 10
                }
                node.label = node.id;
                        node.labelStyle = this.nodeLabelBase;
                        if (node.userLock) {
                Base_Helpers.extend(node, this.scene.settings.style.nodeLocked)
                }
                if (node.expanded) {
                Base_Helpers.extend(node, this.scene.settings.style.nodeExpanded)
                }
                if (node.focused) {
                Base_Helpers.extend(node, this.scene.settings.style.nodeFocused)
                }
                if (!node.data.loaded) {
                Base_Helpers.extend(node, this.scene.settings.style.nodeNotLoaded)
                }
                if (node.data) {
                if (node.data.error != null) {
                node.label = node.data.error;
                        node.fillColor = "red"
                }
                if (node.data.style) {
                Base_Helpers.extend(node, node.data.style)
                }
                this.applyStyleRules(node, this.nodeRules);
                        if (!Base_Helpers.isNumber(node.radius)) {
                node.radius = 10
                }
                if (node.labelStyle !== this.nodeLabelBase) {
                l = Base_Helpers.realClone(this.nodeLabelBase);
                        Base_Helpers.extend(l, node.labelStyle);
                        node.labelStyle = l
                }
                }
                if (node.removed) {
                node.fillColor = this.scene.settings.style.removedColor
                }
                if (active) {
                Base_Helpers.extend(node, this.scene.settings.style.nodeHovered)
                }
                _ref = node.links;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                l = _ref[_i];
                        this.updateLink(l, fadeout)
                }
                if (originalRadius !== node.radius) {
                this.nodeRadiusChanged = true
                }
                if (fadeout && node.relevance < 1) {
                removedColor = this.scene.settings.style.removedColor;
                        if (node.fillColor) {
                node.fillColor = Base_Graphics.blendColors(removedColor, node.fillColor, node.relevance)
                }
                if (node.lineColor) {
                node.lineColor = Base_Graphics.blendColors(removedColor, node.lineColor, node.relevance)
                }
                }
                return true
                };
                Netchart_Styles.prototype.updateLink = function(link, fadeout) {
                var active, l, originalRadius, removedColor;
                        originalRadius = link.radius;
                        Base_Helpers.extend(link, this.scene.settings.style.link);
                        link.label = null;
                        link.labelStyle = this.linkLabelBase;
                        link.radius = 1;
                        active = link === this.scene.hoverLink || link.from === this.scene.hoverNode || link.to === this.scene.hoverNode;
                        if (link.data.style) {
                Base_Helpers.extend(link, link.data.style)
                }
                this.applyStyleRules(link, this.linkRules);
                        if (!Base_Helpers.isNumber(link.radius)) {
                link.radius = 1
                }
                if (link.labelStyle !== this.linkLabelBase) {
                l = Base_Helpers.realClone(this.linkLabelBase);
                        Base_Helpers.extend(l, link.labelStyle);
                        link.labelStyle = l
                }
                if (active) {
                Base_Helpers.extend(link, this.scene.settings.style.linkHovered);
                        if (link.from === this.scene.hoverNode) {
                link.toPieColor = link.fillColor
                }
                }
                if (link.removed) {
                link.fillColor = this.scene.settings.style.removedColor
                }
                if (originalRadius !== link.radius) {
                this.linkRadiusChanged = true
                }
                if (fadeout && link.relevance < 1) {
                removedColor = this.scene.settings.style.removedColor;
                        if (link.fillColor) {
                link.fillColor = Base_Graphics.blendColors(removedColor, link.fillColor, link.relevance)
                }
                if (link.lineColor) {
                link.lineColor = Base_Graphics.blendColors(removedColor, link.lineColor, link.relevance)
                }
                return link.length = 0.2 + (link.length - 0.2) * link.relevance
                }
                };
                Netchart_Styles.prototype.applyStyleRules = function(obj, rules) {
                var func, _i, _len, _results;
                        _results = [];
                        for (_i = 0, _len = rules.length; _i < _len; _i++) {
                func = rules[_i];
                        _results.push(func(obj))
                }
                return _results
                };
                Netchart_Styles.prototype.computeRadiuses = function(objects, mode, extents, fadeout) {
                var add, max, maxE, min, minE, mul, obj, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _results;
                        minE = extents[0], maxE = extents[1];
                        if (mode === "linear" || mode === "logarithmic") {
                min = Infinity;
                        max = - Infinity;
                        for (_i = 0, _len = objects.length; _i < _len; _i++) {
                obj = objects[_i];
                        if (!obj.removed) {
                min = Math.min(min, obj.radius);
                        max = Math.max(max, obj.radius)
                }
                }
                if (min >= max) {
                for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
                obj = objects[_j];
                        if (!obj.removed) {
                obj.targetRadius = minE
                }
                }
                } else {
                if (mode === "linear") {
                mul = (maxE - minE) / (max - min);
                        add = maxE - max * mul;
                        for (_k = 0, _len2 = objects.length; _k < _len2; _k++) {
                obj = objects[_k];
                        if (!obj.removed) {
                obj.targetRadius = obj.radius * mul + add
                }
                }
                } else {
                min = Math.max(0.0001, min);
                        max = Math.max(min + 0.0001, max);
                        mul = (maxE - minE) / Math.log(max / min);
                        add = maxE - mul * Math.log(max);
                        for (_l = 0, _len3 = objects.length; _l < _len3; _l++) {
                obj = objects[_l];
                        if (!obj.removed) {
                obj.targetRadius = Math.log(Math.max(0.0001, obj.radius)) * mul + add
                }
                }
                }
                }
                } else {
                for (_m = 0, _len4 = objects.length; _m < _len4; _m++) {
                obj = objects[_m];
                        if (!obj.removed) {
                obj.targetRadius = Math.min(Math.max(minE, obj.radius), maxE)
                }
                }
                }
                if (fadeout) {
                _results = [];
                        for (_n = 0, _len5 = objects.length; _n < _len5; _n++) {
                obj = objects[_n];
                        if (obj.relevance < 1) {
                _results.push(obj.targetRadius = obj.targetRadius * obj.relevance)
                } else {
                _results.push(void 0)
                }
                }
                return _results
                }
                };
                Netchart_Styles.prototype.computeStrengths = function(objects, mode, extents) {
                var add, max, maxE, min, minE, mul, obj, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _results, _results1, _results2, _results3;
                        minE = extents[0], maxE = extents[1];
                        if (mode === "linear" || mode === "logarithmic") {
                min = Infinity;
                        max = - Infinity;
                        for (_i = 0, _len = objects.length; _i < _len; _i++) {
                obj = objects[_i];
                        if (!obj.removed) {
                min = Math.min(min, obj.strength);
                        max = Math.max(max, obj.strength)
                }
                }
                if (min >= max) {
                _results = [];
                        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
                obj = objects[_j];
                        if (!obj.removed) {
                _results.push(obj.targetStrength = minE)
                } else {
                _results.push(void 0)
                }
                }
                return _results
                } else {
                if (mode === "linear") {
                mul = (maxE - minE) / (max - min);
                        add = maxE - max * mul;
                        _results1 = [];
                        for (_k = 0, _len2 = objects.length; _k < _len2; _k++) {
                obj = objects[_k];
                        if (!obj.removed) {
                _results1.push(obj.targetStrength = obj.strength * mul + add)
                } else {
                _results1.push(void 0)
                }
                }
                return _results1
                } else {
                min = Math.max(0.0001, min);
                        max = Math.max(min + 0.0001, max);
                        mul = (maxE - minE) / Math.log(max / min);
                        add = maxE - mul * Math.log(max);
                        _results2 = [];
                        for (_l = 0, _len3 = objects.length; _l < _len3; _l++) {
                obj = objects[_l];
                        if (!obj.removed) {
                _results2.push(obj.targetStrength = Math.log(Math.max(0.0001, obj.strength)) * mul + add)
                } else {
                _results2.push(void 0)
                }
                }
                return _results2
                }
                }
                } else {
                _results3 = [];
                        for (_m = 0, _len4 = objects.length; _m < _len4; _m++) {
                obj = objects[_m];
                        if (!obj.removed) {
                _results3.push(obj.targetStrength = Math.min(Math.max(minE, obj.strength), maxE))
                } else {
                _results3.push(void 0)
                }
                }
                return _results3
                }
                };
                Netchart_Styles.prototype.computeLengths = function(objects, mode, extents) {
                var add, max, maxE, min, minE, mul, obj, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _results, _results1, _results2, _results3;
                        minE = extents[0], maxE = extents[1];
                        if (mode === "linear" || mode === "logarithmic") {
                min = Infinity;
                        max = - Infinity;
                        for (_i = 0, _len = objects.length; _i < _len; _i++) {
                obj = objects[_i];
                        if (!obj.removed) {
                min = Math.min(min, obj.length);
                        max = Math.max(max, obj.length)
                }
                }
                if (min >= max) {
                _results = [];
                        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
                obj = objects[_j];
                        if (!obj.removed) {
                _results.push(obj.targetLength = minE)
                } else {
                _results.push(void 0)
                }
                }
                return _results
                } else {
                if (mode === "linear") {
                mul = (maxE - minE) / (max - min);
                        add = maxE - max * mul;
                        _results1 = [];
                        for (_k = 0, _len2 = objects.length; _k < _len2; _k++) {
                obj = objects[_k];
                        if (!obj.removed) {
                _results1.push(obj.targetLength = obj.length * mul + add)
                } else {
                _results1.push(void 0)
                }
                }
                return _results1
                } else {
                min = Math.max(0.0001, min);
                        max = Math.max(min + 0.0001, max);
                        mul = (maxE - minE) / Math.log(max / min);
                        add = maxE - mul * Math.log(max);
                        _results2 = [];
                        for (_l = 0, _len3 = objects.length; _l < _len3; _l++) {
                obj = objects[_l];
                        if (!obj.removed) {
                _results2.push(obj.targetLength = Math.log(Math.max(0.0001, obj.length)) * mul + add)
                } else {
                _results2.push(void 0)
                }
                }
                return _results2
                }
                }
                } else {
                _results3 = [];
                        for (_m = 0, _len4 = objects.length; _m < _len4; _m++) {
                obj = objects[_m];
                        if (!obj.removed) {
                _results3.push(obj.targetLength = Math.min(Math.max(minE, obj.length), maxE))
                } else {
                _results3.push(void 0)
                }
                }
                return _results3
                }
                };
                Netchart_Styles.prototype.postprocessNode = function(node, g) {
                var display, hh, hwidth, l, r, w, ww;
                        display = this.scene.settings.style.nodeDisplay;
                        r = node.targetRadius;
                        hwidth = r;
                        l = null;
                        if (node.label) {
                if (display === "text") {
                l = Base_Helpers.realClone(node.labelStyle);
                        l.text = node.label.toString();
                        l.backgroundStyle = null;
                        l.image = null;
                        this.itemRenderer.measure(g, l);
                        ww = l.hwidth;
                        hh = l.hheight;
                        w = (ww / hh) * r;
                        if (node.image) {
                w += r
                }
                hwidth = Math.max(w, r)
                } else {
                if (display === "image") {
                hwidth = r;
                        l = Base_Helpers.realClone(node.labelStyle);
                        l.text = node.label.toString()
                } else {
                if (display === "roundtext") {
                l = Base_Helpers.realClone(node.labelStyle);
                        l.text = node.label.toString();
                        l.aspectRatio = 1;
                        l.image = null
                }
                }
                }
                }
                node.hwidth = hwidth;
                        node.currentLabel = l;
                        node.currentItems = [];
                        return this.postprocessItems(node)
                };
                Netchart_Styles.prototype.postprocessLink = function(link, g) {
                var i, items;
                        items = [];
                        if (link.label) {
                i = Base_Helpers.realClone(link.labelStyle);
                        i.text = link.label.toString();
                        i.px = 0.5;
                        i.py = 0;
                        items.push(i)
                }
                link.currentItems = items;
                        return this.postprocessItems(link)
                };
                Netchart_Styles.prototype.postprocessItems = function(obj) {
                var currentItems, i, item, _i, _len, _ref, _results;
                        currentItems = obj.currentItems;
                        _ref = obj.items;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                        i = Base_Helpers.realClone(this.itemBase);
                        Base_Helpers.extendDeep(i, item);
                        i.data = item;
                        if (i.text != null) {
                i.text = i.text.toString()
                }
                _results.push(currentItems.push(i))
                }
                return _results
                };
                return Netchart_Styles
        })();
        var Netchart_ZoomControl, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        };
        Netchart_ZoomControl = (function() {
        function Netchart_ZoomControl(chart) {
        var mouse, nav, zoom;
                this.chart = chart;
                this.freeze = __bind(this.freeze, this);
                this.resetLayout = __bind(this.resetLayout, this);
                this.zoomToFit = __bind(this.zoomToFit, this);
                this.zoomMove = __bind(this.zoomMove, this);
                this.zoomDown = __bind(this.zoomDown, this);
                this.scene = chart.scene;
                this.events = chart.events;
                this.scrolling = this.chart.scrolling;
                this.cont = Base_Helpers.createDom("div", "DVSL-NC-zoom", null, this.chart.layers.container);
                this.cont.style.display = "none";
                zoom = Base_Helpers.createDom("span", null, null, this.cont);
                this.handle = Base_Helpers.createDom("em", null, null, zoom);
                nav = Base_Helpers.createDom("nav", null, null, this.cont);
                this.fit = Base_Helpers.createDom("a", "DVSL-NC-zoom-fit", "", nav);
                //this.fit.title = "Fit to screen";
                this.rearrange = Base_Helpers.createDom("a", "DVSL-NC-zoom-rearrange", "", nav);
                //this.rearrange.title = "Rearrange elements";
                this.lock = Base_Helpers.createDom("a", "DVSL-NC-zoom-lock-all", "", nav);
                //this.lock.title = "Lock all";
                this.lock.onclick = this.freeze;
                this.rearrange.onclick = this.resetLayout;
                this.fit.onclick = this.zoomToFit;
                mouse = new Base_MouseEvents(this.cont, this.scene.settings.advanced.pointer);
                mouse.listen("drag", this.zoomMove);
                mouse.listen("down", this.zoomDown)
        }
        Netchart_ZoomControl.prototype.showDom = function() {
        return this.cont.style.display = "block"
        };
                Netchart_ZoomControl.prototype.zoomDown = function(event) {
                if (event.y < 100) {
                return this.zoomMove(event)
                }
                };
                Netchart_ZoomControl.prototype.zoomMove = function(event) {
                var newZoom, pos;
                        pos = event.y - 10;
                        pos = Math.max(0, Math.min(80, pos));
                        this.handle.style.top = "" + pos + "px";
                        newZoom = this.getZoomValue(pos / 80);
                        this.chart.autoZoom.zoom(newZoom / this.scene.zoom);
                        this.events.notifySceneChanges({position: true});
                        return event.consumed = true
                };
                Netchart_ZoomControl.prototype.getSliderPosition = function() {
                var max, min, zoom, _ref;
                        _ref = this.scene.settings.interaction.zooming.zoomExtent, min = _ref[0], max = _ref[1];
                        zoom = Math.log(Math.max(min, Math.min(max, this.scene.zoom)));
                        min = Math.log(min);
                        max = Math.log(max);
                        return 1 - (zoom - min) / (max - min)
                };
                Netchart_ZoomControl.prototype.getZoomValue = function(pos) {
                var max, min, prop, _ref;
                        _ref = this.scene.settings.interaction.zooming.zoomExtent, min = _ref[0], max = _ref[1];
                        min = Math.log(min);
                        max = Math.log(max);
                        prop = (1 - pos) * (max - min) + min;
                        return Math.exp(prop)
                };
                Netchart_ZoomControl.prototype.zoomToFit = function(event) {
                if (this.scene.autoZoomActive) {
                this.scene.autoZoomActive = false
                } else {
                this.scene.autoZoomActive = true;
                        this.events.notifySceneChanges({position: true})
                }
                return event.preventDefault()
                };
                Netchart_ZoomControl.prototype.resetLayout = function(event) {
                this.chart.layout.resetLayout();
                        this.scene.settings.layout.mode = "dynamic";
                        this.chart.autoZoom.zoomToFit();
                        this.scene.autoZoom = this.scene.settings.interaction.zooming.autoZoom;
                        this.events.notifySceneChanges({position: true, layout: true});
                        return event.preventDefault()
                };
                Netchart_ZoomControl.prototype.freeze = function(event) {
                if (this.scene.settings.layout.mode === "dynamic") {
                this.scene.settings.layout.mode = "static"
                } else {
                this.scene.settings.layout.mode = "dynamic"
                }
                this.events.notifySceneChanges({layout: true});
                        return event.preventDefault()
                };
                Netchart_ZoomControl.prototype.doAnimations = function(event) {
                var value;
                        value = this.getSliderPosition();
                        this.handle.style.top = "" + (80 * value) + "px";
                        if (this.scene.autoZoomActive) {
                Base_Helpers.setClass(this.fit, "DVSL-NC-zoom-fit-active")
                } else {
                Base_Helpers.setClass(this.fit, "DVSL-NC-zoom-fit")
                }
                if (this.scene.settings.layout.mode === "dynamic") {
                return Base_Helpers.setClass(this.lock, "DVSL-NC-zoom-lock-all")
                } else {
                return Base_Helpers.setClass(this.lock, "DVSL-NC-zoom-lock-all-active")
                }
                };
                return Netchart_ZoomControl
        })();
        var Linearchart_Settings, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Linearchart_Settings = (function(_super) {
        __extends(Linearchart_Settings, _super);
                Linearchart_Settings.defaults = {area: {style: {noData: {fillColor: "#888", image: "builtin-no-data-dark"}, zoomHighlight: {fillColor: "rgba(30,160,220,0.15)", fadeIn: 100, fadeOut: 500, fadeCross: 500}, zoomHighlightInactive: {fillColor: "rgba(30,160,220,0.08)"}}}, valueAxis: {"default": {enabled: true, position: "outside", side: "left", title: null, logScale: false, hgrid: true, scaleMinUnit: 0, scaleAdjustmentTolerance: 0.3, scaleAdjustmentAnimationDelay: 200, scaleAdjustmentAnimation: "=", zeroLine: "visible", style: {title: {fillColor: "#000000", font: "13px Arial", reverseDirection: false, alignment: "center", margin: 5}, tick: {lineColor: "#AAAAAA"}, valueLabel: {fillColor: "#000000", font: "11px Arial", margin: 0}, labelSpacing: 25, baseLineStyle: "rgba(127,127,127,0.5)", baseLineFillStyle: "rgba(127,127,127,0.5)", baseLineWidth: 1, baseLineDepth: 1, hgrid1: {lineColor: "rgba(127,127,127,0.1)"}, hgrid2: {lineColor: "rgba(255,255,255,0.2)"}}}}, chartTypes: {columns: {style: {minHeight: 4, gradient: 0.8, lineColor: "", fillColor: "limegreen", lineWidth: 1, padding: [3, 3], shadowOffsetX: 1, shadowOffsetY: - 1, shadowBlur: 3, shadowColor: null, depth: 0, depthBrightness: 0.5}}, line: {style: {lineColor: "#f00", fillColor: "", lineWidth: 1, shadowOffsetX: 1, shadowOffsetY: - 1, shadowBlur: 5, shadowColor: false, smoothing: false, marker: {shape: null, width: 10, fillColor: ""}}}}, stacks: {"default": {name: "", type: "normal", separateNegativeValues: null}}, series: [{enabled: true, type: "columns", valueAxis: "default", stack: null, cluster: null, data: {source: "default", index: 1, field: null, valueFunction: null, aggregation: "sum", noDataPolicy: "join"}, style: {}}], computedSeries: [], colors: [], info: {enabled: true, snap: true, aggregations: [], style: {highlight: {fillColor: "rgba(30,160,220,0.15)", fadeIn: 200, fadeOut: 200}}, contentFunction: null}, toolbars: {enabled: true, logScale: true, backButton: true, zoomOutButton: true, "export": true}, interaction: {swipeSensitivity: 0.6, animationDelay: 500, scrolling: {enabled: true, swipePageFlipping: true, keyboardScrollingFactor: 1, noData: "snapBack", noDataSnapBackProportion: 0.5, kineticFriction: 2}, zooming: {enabled: true, wheel: false, swipe: true, fingers: true, fingersMaxZoom: 10, sensitivity: 1, keyboardFactor: 2, upDownTreshold: 10, zoomHighlightThreshold: 1.5}}, localization: {valueUnits: {K: 1000, M: 1000000, G: 1000000000, T: 1000000000000, E: 1000000000000000}}};
                function Linearchart_Settings(name) {
                Linearchart_Settings.__super__.constructor.call(this, name);
                        this.applyDefaults(Linearchart_Settings.defaults)
                }
        Linearchart_Settings.prototype.apply = function(settings) {
        var availableAxisIds, changes, defV, defaultUsed, id, s, series, ss, type, v, va, value, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
                if (settings.series) {
        series = settings.series;
                delete settings.series
        } else {
        series = null
        }
        changes = Linearchart_Settings.__super__.apply.call(this, settings);
                if (changes.stacks) {
        this.computedStacks = {};
                _ref = this.stacks;
                for (id in _ref) {
        value = _ref[id];
                v = {};
                this.applyRec(v, Linearchart_Settings.defaults.stacks["default"], {});
                this.applyRec(v, value, {});
                this.computedStacks[id] = v
        }
        }
        if (series) {
        settings.series = series;
                if (!this.series) {
        this.series = []
        }
        changes.series = [];
                if (series !== Linearchart_Settings.defaults.series) {
        this.applyById(this.series, series, changes.series)
        }
        }
        if (series || changes.chartTypes) {
        availableAxisIds = {"default": true};
                _ref1 = this.valueAxis;
                for (id in _ref1) {
        va = _ref1[id];
                availableAxisIds[id] = true
        }
        changes.computedSeries = this.computedSeries = [];
                if (this.series.length === 0) {
        ss = [{}]
        } else {
        ss = this.series
        }
        for (_i = 0, _len = ss.length; _i < _len; _i++) {
        series = ss[_i];
                if (!Base_Helpers.isObject(series)) {
        continue
        }
        s = {};
                this.applyRec(s, Linearchart_Settings.defaults.series[0], {});
                type = series.type || s.type;
                if (type === "columns" || type === "line") {
        this.applyRec(s, this.chartTypes[type], {})
        } else {
        throw"Settings: Unrecognized series.type = " + type
        }
        this.applyRec(s, series, {});
                if (!availableAxisIds[s.valueAxis]) {
        throw"Settings: Unrecognized value axis: " + s.valueAxis
        }
        if (s.data.index === 0) {
        throw"Settings: series.data.index = 0, not allowed"
        }
        this.computedSeries.push(s)
        }
        }
        if (changes.valueAxis) {
        defaultUsed = false;
                _ref2 = this.computedSeries;
                for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        s = _ref2[_j];
                if (s.valueAxis === "default") {
        defaultUsed = true
        }
        }
        this.computedValueAxisList = [];
                this.computedValueAxis = {};
                defV = Linearchart_Settings.defaults.valueAxis["default"];
                _ref3 = this.valueAxis;
                for (id in _ref3) {
        value = _ref3[id];
                if (id === "default" && !defaultUsed) {
        continue
        }
        v = {};
                this.applyRec(v, defV, {});
                this.applyRec(v, value, {});
                v.id = id;
                this.computedValueAxis[id] = v;
                this.computedValueAxisList.push(v)
        }
        this.computedValueAxisList.sort(function(a, b) {
        return a.id.localeCompare(b.id)
        })
        }
        return changes
        };
                return Linearchart_Settings
        })(Base_Settings);
        var Timechart_Scene, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Scene = (function(_super) {
        __extends(Timechart_Scene, _super);
                Timechart_Scene.prototype.settings = null;
                Timechart_Scene.prototype.timeStart = 0;
                Timechart_Scene.prototype.timeEnd = 0;
                Timechart_Scene.prototype.anchor = null;
                Timechart_Scene.prototype.period = null;
                Timechart_Scene.prototype.displayUnit = null;
                Timechart_Scene.prototype.data = {};
                Timechart_Scene.prototype.mainData = null;
                Timechart_Scene.prototype.selectionStart = null;
                Timechart_Scene.prototype.selectionEnd = null;
                Timechart_Scene.prototype.minorTimeFormat = null;
                Timechart_Scene.prototype.minorTimeUnit = null;
                Timechart_Scene.prototype.majorTimeFormat = null;
                Timechart_Scene.prototype.majorTimeUnit = null;
                function Timechart_Scene(settings) {
                this.settings = settings;
                        Timechart_Scene.__super__.constructor.call(this)
                }
        Timechart_Scene.prototype.setTimeRange = function(minTime, maxTime, unit) {
        if (!unit) {
        Base_Helpers.error("Scene.setTimeRange: no display unit")
        }
        this.timeStart = minTime;
                this.timeEnd = maxTime;
                return this.displayUnit = unit
        };
                Timechart_Scene.prototype.pixelsPerTime = function() {
                return this.width / (this.timeEnd - this.timeStart)
                };
                Timechart_Scene.prototype.getScale = function() {
                return(this.timeEnd - this.timeStart) / this.width
                };
                Timechart_Scene.prototype.timeToX = function(time) {
                return this.x0 + this.width * (time - this.timeStart) / (this.timeEnd - this.timeStart)
                };
                Timechart_Scene.prototype.timeToXCoefs = function() {
                return[this.x0 - this.timeStart * this.width / (this.timeEnd - this.timeStart), this.width / (this.timeEnd - this.timeStart)]
                };
                Timechart_Scene.prototype.xToTime = function(x) {
                return this.timeStart + (this.timeEnd - this.timeStart) * (x - this.x0) / this.width
                };
                Timechart_Scene.prototype.xToFraction = function(x) {
                return(x - this.x0) / this.width
                };
                Timechart_Scene.prototype.dxToDtime = function(dx) {
                return dx / this.width * (this.timeEnd - this.timeStart)
                };
                Timechart_Scene.prototype.snapTimeDown = function(time) {
                return this.displayUnit.roundTimeDown(time)
                };
                Timechart_Scene.prototype.snapTimeUp = function(time) {
                return this.displayUnit.roundTimeUp(time)
                };
                Timechart_Scene.prototype.snapTimeRound = function(time) {
                return this.displayUnit.roundTimeRound(time)
                };
                Timechart_Scene.prototype.getDataLimits = function() {
                var from, to;
                        from = this.mainData.dataFrom;
                        to = this.mainData.dataTo;
                        if (!((from != null) && (to != null))) {
                return[null, null]
                }
                if (this.displayUnit) {
                from = this.displayUnit.roundTimeDown(from);
                        to = this.displayUnit.roundTimeUp(to)
                }
                return[from, to]
                };
                Timechart_Scene.prototype.getDisplayLimits = function() {
                var from, marker, to, _i, _len, _ref, _ref1;
                        _ref = this.getDataLimits(), from = _ref[0], to = _ref[1];
                        if (from === null) {
                return[null, null]
                }
                _ref1 = this.markers;
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                marker = _ref1[_i];
                        from = Math.min(from, marker.time);
                        to = Math.max(to, marker.time)
                }
                return[from, to]
                };
                Timechart_Scene.prototype.getClickRange = function(time, y) {
                var mt0, mt1, numBars, t0, t1, use1Bar;
                        if ((this.selectionStart != null) && time >= this.selectionStart && time < this.selectionEnd) {
                t0 = this.selectionStart;
                        t1 = this.selectionEnd;
                        numBars = Math.max(2, this.displayUnit.numberOfUnits(t0, t1))
                } else {
                if (this.displayUnit) {
                use1Bar = true;
                        if (this.majorTimeUnit != null) {
                mt0 = this.majorTimeUnit.roundTimeDown(time);
                        mt1 = this.majorTimeUnit.roundTimeUp(time + 1);
                        if ((y != null) && y > this.y0 + this.height && (mt0 > this.timeStart || mt1 < this.timeEnd)) {
                t0 = mt0;
                        t1 = mt1;
                        numBars = this.displayUnit.numberOfUnits(t0, t1);
                        use1Bar = false
                }
                }
                if (use1Bar) {
                t0 = this.displayUnit.roundTimeDown(time);
                        t1 = this.displayUnit.roundTimeUp(time + 1);
                        numBars = 1
                }
                } else {
                t0 = null;
                        t1 = null;
                        numBars = null
                }
                }
                return[t0, t1, numBars]
                };
                Timechart_Scene.prototype.getClickBar = function(time) {
                return[this.displayUnit.roundTimeDown(time), this.displayUnit.roundTimeUp(time + 1)]
                };
                Timechart_Scene.prototype.getCurTime = function() {
                return new Date().getTime() + this.settings.currentTime.computedTimeOffset
                };
                return Timechart_Scene
        })(Linearchart_Scene);
        var Piechart_Icon, Piechart_Pie, Piechart_Scene, Piechart_Slice, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Piechart_Icon = (function() {
        function Piechart_Icon() {
        }
        Piechart_Icon.prototype.hwidth = 0;
                Piechart_Icon.prototype.hheight = 0;
                Piechart_Icon.prototype.x = null;
                Piechart_Icon.prototype.y = null;
                Piechart_Icon.prototype.userPlaced = false;
                Piechart_Icon.prototype.inside = true;
                return Piechart_Icon
        })();
        Piechart_Slice = (function() {
        Piechart_Slice.prototype.id = null;
                Piechart_Slice.prototype.pie = null;
                Piechart_Slice.prototype.data = null;
                Piechart_Slice.prototype.index = 0;
                Piechart_Slice.prototype.value = 0;
                Piechart_Slice.prototype.fraction = 0;
                Piechart_Slice.prototype.cutoutDistance = 0;
                Piechart_Slice.prototype.brightness = 1;
                Piechart_Slice.prototype.expandable = true;
                Piechart_Slice.prototype.selected = false;
                Piechart_Slice.prototype.active = false;
                Piechart_Slice.prototype.icon = null;
                Piechart_Slice.prototype.url = null;
                Piechart_Slice.prototype.userPlaced = false;
                Piechart_Slice.prototype.inside = true;
                Piechart_Slice.prototype.x = 0;
                Piechart_Slice.prototype.y = 0;
                Piechart_Slice.prototype.currentCutoutDistance = null;
                Piechart_Slice.prototype.currentFraction = null;
                Piechart_Slice.prototype.currentInsideLabel = null;
                Piechart_Slice.prototype.currentLabel = null;
                Piechart_Slice.prototype.currentIcon = null;
                Piechart_Slice.prototype.currentLineColor = null;
                Piechart_Slice.prototype.currentFillColor = null;
                Piechart_Slice.prototype.label = null;
                Piechart_Slice.prototype.insideLabel = null;
                Piechart_Slice.prototype.lineColor = null;
                Piechart_Slice.prototype.fillColor = null;
                Piechart_Slice.prototype.lineWidth = 1;
                function Piechart_Slice(pie, index) {
                this.pie = pie;
                        this.index = index
                }
        return Piechart_Slice
        })();
        Piechart_Pie = (function() {
        function Piechart_Pie() {
        }
        Piechart_Pie.prototype.id = null;
                Piechart_Pie.prototype.data = null;
                Piechart_Pie.prototype.total = 1;
                Piechart_Pie.prototype.parentSlice = null;
                Piechart_Pie.prototype.othersSlice = null;
                Piechart_Pie.prototype.previousSlice = null;
                Piechart_Pie.prototype.slices = [];
                Piechart_Pie.prototype.allSlices = [];
                Piechart_Pie.prototype.offset = 0;
                Piechart_Pie.prototype.count = 0;
                Piechart_Pie.prototype.background = false;
                Piechart_Pie.prototype.activeSliceId = null;
                Piechart_Pie.prototype.brightness = 1;
                Piechart_Pie.prototype.loading = false;
                Piechart_Pie.prototype.scrollOffset = 0;
                Piechart_Pie.prototype.getActiveSlice = function() {
                var slice, _i, _len, _ref;
                        if (!this.activeSliceId) {
                return null
                }
                _ref = this.slices;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                slice = _ref[_i];
                        if (slice.id === this.activeSliceId) {
                return slice
                }
                }
                return null
                };
                Piechart_Pie.prototype.fillColor = null;
                Piechart_Pie.prototype.x = 0;
                Piechart_Pie.prototype.y = 0;
                Piechart_Pie.prototype.startAngle = 0;
                Piechart_Pie.prototype.endAngle = 0;
                Piechart_Pie.prototype.currentStartAngle = null;
                Piechart_Pie.prototype.currentEndAngle = null;
                Piechart_Pie.prototype.currentRadius = 0;
                Piechart_Pie.prototype.currentInnerRadius = 0;
                return Piechart_Pie
        })();
        Piechart_Scene = (function(_super) {
        __extends(Piechart_Scene, _super);
                function Piechart_Scene() {
                Piechart_Scene.__super__.constructor.call(this);
                        this.settings = null;
                        this.radius = 100;
                        this.innerRadius = 0;
                        this.pies = [];
                        this.stack = [];
                        this.selection = [];
                        this.selectionIds = [];
                        this.hoverSlice = null;
                        this.hoverPie = null;
                        this.view = null;
                        this.pendingAction = null;
                        this.pendingOffset = null
                }
        Piechart_Scene.prototype.addPie = function(pie) {
        this.pies.push(pie);
                this.stack.push(pie);
                return pie
        };
                Piechart_Scene.prototype.removePie = function(pie) {
                var i, slice, _results;
                        pie.removed = true;
                        Base_Helpers.removeFromArray(this.stack, pie);
                        i = 0;
                        _results = [];
                        while (i < this.selection.length) {
                slice = this.selection[i];
                        if (slice.pie === pie) {
                _results.push(Base_Helpers.removeFromArray(this.selection, slice))
                } else {
                _results.push(i++)
                }
                }
                return _results
                };
                Piechart_Scene.prototype.deletePie = function(pie) {
                Base_Helpers.removeFromArray(this.pies, pie);
                        return Base_Helpers.removeFromArray(this.stack, pie)
                };
                Piechart_Scene.prototype.length = function() {
                return this.stack.length
                };
                Piechart_Scene.prototype.peek = function() {
                if (this.stack.length === 0) {
                return null
                }
                return this.stack[this.stack.length - 1]
                };
                Piechart_Scene.prototype.push = function(pie, originSlice) {
                var a0, a1, originPie, parent, slice, _i, _j, _len, _len1, _ref, _ref1, _ref2;
                        parent = this.peek();
                        if (parent && !originSlice) {
                _ref = parent.slices;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                slice = _ref[_i];
                        if (slice.id === pie.id) {
                originSlice = slice;
                        break
                }
                }
                }
                if (originSlice) {
                pie.parentSlice = originSlice;
                        originPie = originSlice.pie;
                        _ref1 = this.getSliceAngles(originSlice), a0 = _ref1[0], a1 = _ref1[1];
                        pie.currentStartAngle = a0;
                        pie.currentEndAngle = a1;
                        pie.currentRadius = originPie.currentRadius;
                        pie.currentInnerRadius = originPie.currentInnerRadius;
                        parent.activeSliceId = originSlice.id;
                        _ref2 = pie.allSlices;
                        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                slice = _ref2[_j];
                        if (originSlice) {
                slice.currentFillColor = originSlice.currentFillColor;
                        slice.currentLineColor = originSlice.currentLineColor
                }
                }
                } else {
                if (parent) {
                parent.activeSliceId = null
                }
                }
                if (parent) {
                parent.background = true
                }
                return this.addPie(pie)
                };
                Piechart_Scene.prototype.pop = function() {
                var pie;
                        if (!(this.stack.length > 0)) {
                return
                }
                this.removePie(this.peek());
                        pie = this.peek();
                        pie.background = false;
                        return pie.brightness = 1
                };
                Piechart_Scene.prototype.getParent = function(pie) {
                var p, parent, _i, _len, _ref;
                        parent = null;
                        _ref = this.stack;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                p = _ref[_i];
                        if (p === pie) {
                return parent
                }
                parent = p
                }
                return null
                };
                Piechart_Scene.prototype.getChild = function(pie) {
                var p, parent, _i, _len, _ref;
                        parent = null;
                        _ref = this.stack;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                p = _ref[_i];
                        if (parent === pie) {
                return p
                }
                parent = p
                }
                return null
                };
                Piechart_Scene.prototype.updateOnPieChanged = function(pie) {
                var child, parent, slice, _i, _j, _len, _len1, _ref, _ref1, _results;
                        parent = this.getParent(pie);
                        child = this.getChild(pie);
                        if (parent && !pie.parentSlice) {
                _ref = parent.slices;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                slice = _ref[_i];
                        if (slice.id === pie.id) {
                pie.parentSlice = slice;
                        parent.activeSliceId = slice.id;
                        break
                }
                }
                }
                if (child && !child.parentSlice) {
                _ref1 = pie.slices;
                        _results = [];
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                slice = _ref1[_j];
                        if (slice.id === child.id) {
                child.parentSlice = slice;
                        pie.activeSliceId = slice.id;
                        break
                } else {
                _results.push(void 0)
                }
                }
                return _results
                }
                };
                Piechart_Scene.prototype.findPieAt = function(x, y, t) {
                return this.view.findPieAt(x, y, t)
                };
                Piechart_Scene.prototype.findSliceAt = function(x, y, t) {
                return this.view.findSliceAt(x, y, t)
                };
                Piechart_Scene.prototype.findLabelAt = function(x, y, t) {
                return this.view.findLabelAt(x, y, t)
                };
                Piechart_Scene.prototype.getSliceAngles = function(slice) {
                var a0, da, f0, f1, pie, s, _i, _len, _ref;
                        f1 = 0;
                        pie = slice.pie;
                        _ref = pie.allSlices;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                        f0 = f1;
                        f1 = f1 + s.currentFraction;
                        if (s.id === slice.id) {
                break
                }
                }
                da = pie.currentEndAngle - pie.currentStartAngle;
                        a0 = pie.currentStartAngle + da * pie.scrollOffset;
                        return[a0 + da * f0, a0 + da * f1]
                };
                Piechart_Scene.prototype.getSliceTargetAngles = function(slice) {
                var a0, da, f0, f1, pie, s, _i, _len, _ref;
                        f1 = 0;
                        pie = slice.pie;
                        _ref = pie.allSlices;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                        f0 = f1;
                        f1 = f1 + s.currentFraction;
                        if (s.id === slice.id) {
                break
                }
                }
                da = pie.currentEndAngle - pie.currentStartAngle;
                        a0 = pie.currentStartAngle + da * pie.scrollOffset;
                        return[a0 + da * f0, a0 + da * f1]
                };
                return Piechart_Scene
        })(Base_Scene);
        var Piechart_Styles;
        Piechart_Styles = (function() {
        Piechart_Styles.prototype.animationPriority = 1012;
                function Piechart_Styles(chart) {
                this.chart = chart;
                        this.scene = chart.scene
                }
        Piechart_Styles.prototype.doAnimations = function(event) {
        var pie, slice, slice_ind, _i, _len, _ref, _results;
                if (!(event.changes.settings || event.changes.pie || event.changes.selection)) {
        return
        }
        _ref = this.scene.pies;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pie = _ref[_i];
                this.updatePie(pie);
                this.computePieColors(pie);
                _results.push((function() {
                var _j, _len1, _ref1, _results1;
                        _ref1 = pie.allSlices;
                        _results1 = [];
                        for (slice_ind = _j = 0, _len1 = _ref1.length; _j < _len1; slice_ind = ++_j) {
                slice = _ref1[slice_ind];
                        _results1.push(this.updateSlice(slice, slice_ind))
                }
                return _results1
                }).call(this))
        }
        return _results
        };
                Piechart_Styles.prototype.updatePie = function(pie) {
                Base_Helpers.extend(pie, this.scene.settings.pie.style);
                        if (pie.slices.length === 0) {
                Base_Helpers.extend(pie, this.scene.settings.pie.noDataStyle)
                }
                if (pie.background) {
                Base_Helpers.extend(pie, this.scene.settings.pie.backgroundStyle)
                }
                if (this.scene.hoverPie === pie) {
                Base_Helpers.extend(pie, this.scene.settings.pie.backgroundHoveredStyle)
                }
                if (this.scene.settings.pie.styleFunction) {
                return this.scene.settings.pie.styleFunction(pie)
                }
                };
                Piechart_Styles.prototype.computePieColors = function(pie) {
                var c0, c1, col, colorCount, colorMode, colors, cp, i, pos, round, slice, sliceCount, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _results, _results1, _results2;
                        colors = pie.sliceColors;
                        colorMode = pie.colorDistribution;
                        sliceCount = 0;
                        _ref = pie.slices;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                slice = _ref[_i];
                        if (!slice.removed) {
                sliceCount += 1
                }
                }
                if (sliceCount === 1) {
                pie.slices[0].fillColor = colors[0];
                        return
                }
                if (colors.length === 1) {
                col = colors[0];
                        colors = [col, Base_Graphics.blendColors(col, "#fff", 0.8)]
                }
                colorCount = colors.length;
                        if (colorMode === "gradient") {
                pos = 0;
                        _ref1 = pie.slices;
                        _results = [];
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                slice = _ref1[_j];
                        if (slice.removed) {
                continue
                }
                c0 = colors[(pos * (colorCount - 1)) | 0];
                        c1 = colors[(pos * (colorCount - 1) + 1) | 0];
                        cp = pos * (colorCount - 1);
                        cp = cp - Math.floor(cp);
                        col = Base_Graphics.blendColors(c0, c1, cp);
                        slice.fillColor = col;
                        _results.push(pos += 1 / (sliceCount - 0.9))
                }
                return _results
                } else {
                if (colorMode === "gradientProportional") {
                pos = 0;
                        _ref2 = pie.slices;
                        _results1 = [];
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                slice = _ref2[_k];
                        if (slice.removed) {
                continue
                }
                c0 = colors[(pos * (colorCount - 1)) | 0];
                        c1 = colors[(pos * (colorCount - 1) + 1) | 0];
                        cp = pos * (colorCount - 1);
                        cp = cp - Math.floor(cp);
                        col = Base_Graphics.blendColors(c0, c1, cp);
                        slice.fillColor = col;
                        _results1.push(pos += slice.fraction)
                }
                return _results1
                } else {
                _ref3 = pie.slices;
                        _results2 = [];
                        for (i = _l = 0, _len3 = _ref3.length; _l < _len3; i = ++_l) {
                slice = _ref3[i];
                        if (slice.removed) {
                continue
                }
                col = colors[i % colorCount];
                        round = (i / colorCount) | 0;
                        if (round === 1) {
                col = Base_Graphics.deriveColor(col, 1.5, 1)
                } else {
                if (round >= 2) {
                col = Base_Graphics.deriveColor(col, 0.5, 1)
                }
                }
                _results2.push(slice.fillColor = col)
                }
                return _results2
                }
                }
                };
                Piechart_Styles.prototype.updateSlice = function(slice, index) {
                var brightness, pie, styleFunc, targetFillColor, targetLineColor;
                        pie = slice.pie;
                        styleFunc = this.scene.settings.slice.styleFunction;
                        if (slice.removed) {
                return
                }
                slice.expandable = this.scene.data.canExapnd(slice.id);
                        Base_Helpers.extend(slice, this.scene.settings.slice.style);
                        if (slice === pie.othersSlice) {
                Base_Helpers.extend(slice, this.scene.settings.slice.othersStyle)
                }
                if (slice === pie.previousSlice) {
                Base_Helpers.extend(slice, this.scene.settings.slice.previousStyle)
                }
                if (pie.total > 0) {
                slice.percent = slice.value / pie.total * 100
                } else {
                slice.percent = 0
                }
                if (!styleFunc) {
                slice.label = "" + (slice.percent.toFixed(1)) + "%";
                        if (slice.data.name) {
                slice.label = slice.data.name + " " + slice.label
                }
                }
                if (slice.selected) {
                Base_Helpers.extend(slice, this.scene.settings.slice.selectedStyle)
                }
                if (this.scene.hoverSlice === slice) {
                Base_Helpers.extend(slice, this.scene.settings.slice.hoverStyle)
                }
                if (slice.data.style) {
                Base_Helpers.extend(slice, slice.data.style)
                }
                if (styleFunc) {
                styleFunc(slice, slice.data);
                        if (slice.label && !Base_Helpers.isString(slice.label)) {
                slice.label = "" + slice.label
                }
                if (slice.insideLabel && !Base_Helpers.isString(slice.insideLabel)) {
                slice.insideLabel = "" + slice.insideLabel
                }
                }
                if (pie.background) {
                if (pie.activeSliceId !== slice.id) {
                Base_Helpers.extend(slice, this.scene.settings.slice.backgroundStyle);
                        if (index % 2 === 1) {
                slice.fillColor = slice.fillColor2
                }
                } else {
                Base_Helpers.extend(slice, this.scene.settings.slice.backgroundActiveStyle)
                }
                }
                if (slice.fillColor) {
                targetFillColor = slice.fillColor
                } else {
                targetFillColor = "rgba(255,255,255,0)"
                }
                if (slice.lineColor) {
                targetLineColor = slice.lineColor
                } else {
                if (slice.lineBrightness) {
                targetLineColor = Base_Graphics.deriveColor(targetFillColor, slice.lineBrightness, 1)
                } else {
                targetLineColor = "rgba(255,255,255,0)"
                }
                }
                brightness = slice.brightness * pie.brightness;
                        if (brightness !== 1) {
                targetFillColor = Base_Graphics.deriveColor(targetFillColor, brightness, 1);
                        targetLineColor = Base_Graphics.deriveColor(targetLineColor, brightness, 1);
                        if (targetFillColor.indexOf("rgba(255,255,255") !== - 1 && targetLineColor.indexOf("rgba(255,255,255") !== - 1) {
                targetLineColor = "rgba(200,200,200,1.000)"
                }
                }
                if (pie.removed && pie.parentSlice) {
                slice.targetFillColor = pie.parentSlice.targetFillColor;
                        return slice.targetLineColor = pie.parentSlice.targetLineColor
                } else {
                slice.targetFillColor = Base_Graphics.normalizeColor(targetFillColor);
                        return slice.targetLineColor = Base_Graphics.normalizeColor(targetLineColor)
                }
                };
                return Piechart_Styles
        })();
        var Facetchart_Facet, Facetchart_Item, Facetchart_ItemValue, Facetchart_Scene, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Facetchart_Facet = (function() {
        function Facetchart_Facet() {
        this.id = null;
                this.data = null;
                this.items = [];
                this.parentItem = null;
                this.activeItemId = null;
                this.offset = 0;
                this.count = 0;
                this.totalCount = 0;
                this.from = 0;
                this.to = 0;
                this.left = 0;
                this.right = 1;
                this.opacity = 1
        }
        Facetchart_Facet.prototype.getActiveItem = function() {
        var item, _i, _len, _ref;
                if (!this.activeItemId) {
        return null
        }
        _ref = this.items;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
                if (item.id === this.activeItemId) {
        return item
        }
        }
        return null
        };
                return Facetchart_Facet
        })();
        Facetchart_Item = (function() {
        function Facetchart_Item(facet, id, index, data) {
        this.facet = facet;
                this.id = id;
                this.index = index;
                this.data = data;
                this.expandable = true;
                this.selected = false;
                this.active = false;
                this.url = null;
                this.values = [];
                this.innerFacet = null;
                this.label = null;
                this.currentLabel = null
        }
        return Facetchart_Item
        })();
        Facetchart_ItemValue = (function() {
        Facetchart_ItemValue.prototype.value = 0;
                Facetchart_ItemValue.prototype.fillColor = null;
                Facetchart_ItemValue.prototype.lineColor = null;
                Facetchart_ItemValue.prototype.lineWidth = 1;
                Facetchart_ItemValue.prototype.label = null;
                function Facetchart_ItemValue(facet, id, index, data) {
                this.facet = facet;
                        this.id = id;
                        this.index = index;
                        this.data = data
                }
        Facetchart_ItemValue.prototype.currentLabel = null;
                return Facetchart_ItemValue
        })();
        Facetchart_Scene = (function(_super) {
        __extends(Facetchart_Scene, _super);
                function Facetchart_Scene(settings) {
                this.settings = settings;
                        Facetchart_Scene.__super__.constructor.call(this);
                        this.data = null;
                        this.backStack = [];
                        this.stack = [];
                        this.selection = [];
                        this.selectionIds = [];
                        this.activeFacet = null;
                        this.hoverItem = null
                }
        Facetchart_Scene.prototype.xToPosition = function(x) {
        var f, left, pos, right;
                f = this.activeFacet;
                left = this.x0 + f.left * this.width;
                right = this.x0 + f.right * this.width;
                pos = f.from + (x - left) / (right - left) * (f.to - f.from);
                return pos
        };
                Facetchart_Scene.prototype.positionToX = function(t) {
                var f, left, right;
                        f = this.activeFacet;
                        left = this.x0 + f.left * this.width;
                        right = this.x0 + f.right * this.width;
                        return left + (t - f.from) * (right - left) / (f.to - f.from)
                };
                Facetchart_Scene.prototype.timeToX = function(t) {
                return this.positionToX(t)
                };
                Facetchart_Scene.prototype.length = function() {
                return this.stack.length
                };
                Facetchart_Scene.prototype.peek = function() {
                if (this.stack.length === 0) {
                return null
                }
                return this.stack[this.stack.length - 1]
                };
                Facetchart_Scene.prototype.push = function(facet, originItem) {
                var a0, a1, item, originFacet, parent, _i, _len, _ref, _ref1;
                        parent = this.peek();
                        if (parent && !originItem) {
                _ref = parent.items;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                        if (item.data.__id === facet.id) {
                originItem = item;
                        break
                }
                }
                }
                if (originItem) {
                facet.parentItem = originItem;
                        originFacet = originItem.facet;
                        _ref1 = this.getItemPlacement(originItem), a0 = _ref1[0], a1 = _ref1[1];
                        facet.left = a0;
                        facet.right = a1;
                        parent.activeItemId = originItem.id
                } else {
                if (parent) {
                parent.activeItemId = null
                }
                }
                this.stack.push(facet);
                        return this.activeFacet = facet
                };
                Facetchart_Scene.prototype.pop = function() {
                var f;
                        if (this.stack.length > 0) {
                f = this.stack.pop();
                        if (f.parentItem) {
                f.parentItem.facet.activeItemId = null
                }
                }
                if (this.stack.length > 0) {
                this.activeFacet = this.peek()
                } else {
                this.activeFacet = null
                }
                return this.activeFacet
                };
                Facetchart_Scene.prototype.getParent = function(pie) {
                var p, parent, _i, _len, _ref;
                        parent = null;
                        _ref = this.stack;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                p = _ref[_i];
                        if (p === pie) {
                return parent
                }
                parent = p
                }
                return null
                };
                Facetchart_Scene.prototype.getChild = function(pie) {
                var p, parent, _i, _len, _ref;
                        parent = null;
                        _ref = this.stack;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                p = _ref[_i];
                        if (parent === pie) {
                return p
                }
                parent = p
                }
                return null
                };
                Facetchart_Scene.prototype.updateLinks = function(facet) {
                var child, item, parent, _i, _j, _len, _len1, _ref, _ref1, _results;
                        parent = this.getParent(facet);
                        child = this.getChild(facet);
                        if (parent && !facet.parentItem) {
                _ref = parent.items;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                        if (item.id === facet.id) {
                facet.parentItem = item;
                        parent.activeItemId = item.id;
                        break
                }
                }
                }
                if (child && !child.parentItem) {
                _ref1 = facet.items;
                        _results = [];
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                item = _ref1[_j];
                        if (item.id === child.id) {
                child.parentItem = item;
                        facet.activeItemId = item.id;
                        break
                } else {
                _results.push(void 0)
                }
                }
                return _results
                }
                };
                Facetchart_Scene.prototype.getItemPlacement = function(item) {
                var a0, da, facet, i, p0, p1;
                        facet = item.facet;
                        i = item.index;
                        da = facet.to - facet.from;
                        a0 = facet.from;
                        p0 = (i - a0) / da;
                        p1 = (i - a0 + 1) / da;
                        return[facet.left + p0 * (facet.right - facet.left), facet.left + p1 * (facet.right - facet.left)]
                };
                Facetchart_Scene.prototype.getFacetPlacementFromItem = function(item, iLeft, iRight) {
                var A0, A1, facet, i0, i1, left, right;
                        facet = item.facet;
                        i0 = item.index;
                        i1 = i0 + 1;
                        A0 = (i0 - facet.from) / (facet.to - facet.from);
                        A1 = (i1 - facet.from) / (facet.to - facet.from);
                        left = iLeft - A0 * (iLeft - iRight) / (A0 - A1);
                        right = left + (iLeft - iRight) / (A0 - A1);
                        return[left, right]
                };
                Facetchart_Scene.prototype.findFacetAt = function(x, y) {
                return null
                };
                Facetchart_Scene.prototype.findItemAt = function(x, y) {
                var f, pos;
                        f = this.activeFacet;
                        if (!(this.xyInChart(x, y) && f)) {
                return null
                }
                pos = Math.floor(this.xToPosition(x));
                        if (pos >= f.offset && pos < f.offset + f.count) {
                return f.items[pos - f.offset]
                }
                return null
                };
                Facetchart_Scene.prototype.findLabelAt = function(x, y) {
                return[null, null]
                };
                return Facetchart_Scene
        })(Linearchart_Scene);
        var Facetchart_Scrolling, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Facetchart_Scrolling = (function(_super) {
        __extends(Facetchart_Scrolling, _super);
                Facetchart_Scrolling.prototype.animationPriority = 1001;
                function Facetchart_Scrolling(chart) {
                Facetchart_Scrolling.__super__.constructor.call(this, chart);
                        this.facet = null;
                        this.animatingFacet = null;
                        this.leftAnimator = null;
                        this.rightAnimator = null
                }
        Facetchart_Scrolling.prototype.setState = function(id, offset, count, origin) {
        var changes, facet, from, pieId, to;
                if (!Base_Helpers.isArray(id)) {
        id = [id]
        }
        changes = 0;
                while (this.scene.length() > id.length) {
        this.scene.pop();
                changes++
        }
        while (this.scene.length() > 0 && this.scene.peek().id !== id[this.scene.length() - 1]) {
        this.scene.pop();
                changes++
        }
        while (this.scene.length() < id.length) {
        pieId = id[this.scene.length()];
                this.drillDown(pieId, null);
                changes++
        }
        facet = this.scene.peek();
                this.facet = facet;
                if (changes) {
        this.goToPositionDragging(facet.from, facet.to)
        }
        if (facet.offset !== offset || (count && facet.count !== count)) {
        from = offset;
                if (count > 0) {
        to = from + count
        } else {
        to = offset + facet.count
        }
        if (changes) {
        this.goToPositionDragging(from, to);
                this.animateFillChart()
        } else {
        this.goToPosition(from, to, true)
        }
        } else {
        if (changes) {
        this.animateFillChart()
        }
        }
        this.chart.notifyChartUpdate(origin);
                if (changes) {
        return this.events.notifySceneChanges({navigation: true})
        }
        };
                Facetchart_Scrolling.prototype.getState = function() {
                var pie;
                        return[(function() {
                        var _i, _len, _ref, _results;
                                _ref = this.scene.stack;
                                _results = [];
                                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        pie = _ref[_i];
                                _results.push(pie.id)
                        }
                        return _results
                        }).call(this), this.scene.peek().offset, this.scene.peek().count]
                };
                Facetchart_Scrolling.prototype.goUp = function(origin) {
                var f;
                        if (!(this.scene.length() > 1)) {
                return
                }
                this.scene.pop();
                        this.facet = f = this.scene.peek();
                        this.goToPositionDragging(f.from, f.to);
                        this.animateFillChart();
                        this.events.notifySceneChanges({navigation: true});
                        return this.updateAndNotifyCurrent(origin)
                };
                Facetchart_Scrolling.prototype.drillDown = function(pieId, origin) {
                var f;
                        this.stopAnimations();
                        f = new Facetchart_Facet();
                        f.id = pieId;
                        this.scene.push(f);
                        this.chart.builder.updateFacet(f);
                        this.facet = f;
                        this.currentFrom = f.from;
                        this.currentTo = f.to;
                        this.animateFillChart();
                        this.events.notifySceneChanges({navigation: true});
                        return this.updateAndNotifyCurrent(origin)
                };
                Facetchart_Scrolling.prototype.updateAndNotifyCurrent = function(origin) {
                this.chart.builder.updateFacet(this.facet);
                        return this.chart.notifyChartUpdate(origin)
                };
                Facetchart_Scrolling.prototype.onSceneChange = function(event) {
                var activePieReady, f, facet, ids, pie, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
                        f = this.facet;
                        if (event.changes.settings && event.changes.settingsChanges.series) {
                event.changes.items = true;
                        _ref = this.scene.stack;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                facet = _ref[_i];
                        this.chart.builder.rebuildValues(facet)
                }
                }
                activePieReady = false;
                        if (event.changes.dataArrived) {
                ids = event.changes.dataArrivedIds;
                        _ref1 = this.scene.stack;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                pie = _ref1[_j];
                        if (ids.hasOwnProperty(pie.id)) {
                this.chart.builder.updateFacet(pie, event);
                        event.changes.items = true;
                        activePieReady || (activePieReady = pie === f && !pie.loading)
                }
                }
                }
                if (event.changes.data) {
                _ref2 = this.scene.stack;
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                facet = _ref2[_k];
                        if (!facet.data || facet === f || event.changes.dataDeep) {
                facet.rebuild = true;
                        this.chart.builder.updateFacet(facet, event);
                        event.changes.items = true;
                        activePieReady || (activePieReady = facet === f && !facet.loading)
                }
                }
                }
                if (activePieReady) {
                if (this.currentFrom === this.currentTo && f.from < f.to) {
                this.currentFrom = f.from;
                        this.currentTo = f.to;
                        this.animateFillChart()
                }
                return this.chart.notifyChartUpdate(null)
                }
                };
                Facetchart_Scrolling.prototype.doAnimations = function(event) {
                var done, f, opacity, visiblePerc, _i, _len, _ref;
                        f = this.facet;
                        if (this.animatingFacet) {
                f.left = this.leftAnimator.get(event.time);
                        f.right = this.rightAnimator.get(event.time);
                        f.opacity = this.opacityAnimator.get(event.time);
                        done = this.leftAnimator.finished(event.time) || this.rightAnimator.finished(event.time);
                        if (done) {
                this.animatingFacet = null;
                        this.leftAnimator = null;
                        this.rightAnimator = null;
                        this.opacityAnimator = null
                }
                this.events.notifySceneChanges({position: true});
                        event.animating = true
                } else {
                visiblePerc = f.right - f.left;
                        opacity = Math.min(1, Math.abs(visiblePerc));
                        f.opacity = 1
                }
                this.layoutFacets();
                        _ref = this.scene.stack;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                f = _ref[_i];
                        this.chart.builder.updateFacet(f)
                }
                return Facetchart_Scrolling.__super__.doAnimations.call(this, event)
                };
                Facetchart_Scrolling.prototype.xyInArea = function(x, y) {
                return this.scene.xyInChartOrBottom(x, y)
                };
                Facetchart_Scrolling.prototype.xyToPosition = function(x, y) {
                return this.scene.xToPosition(x)
                };
                Facetchart_Scrolling.prototype.onZoomOut = function(from, to, origin, scale) {
                if (scale == null) {
                scale = null
                }
                return Facetchart_Scrolling.__super__.onZoomOut.call(this, from, to, origin, scale)
                };
                Facetchart_Scrolling.prototype.onZoomIn = function(from, to, center, scale) {
                if (scale == null) {
                scale = null
                }
                return Facetchart_Scrolling.__super__.onZoomIn.call(this, from, to, center, scale)
                };
                Facetchart_Scrolling.prototype.onScroll = function(from, to, direction) {
                return Facetchart_Scrolling.__super__.onScroll.call(this, from, to, direction)
                };
                Facetchart_Scrolling.prototype.onGoHome = function(from, to) {
                return[0, to - from, 0]
                };
                Facetchart_Scrolling.prototype.onStartDragging = function(oldFrom, oldTo, pos) {
                return this.stopAnim()
                };
                Facetchart_Scrolling.prototype.onSnapWhileDragging = function(from, to, origin, isScrolling, isScaling) {
                var cnt, diff, diffExt, fr, fromExt, t, toExt;
                        diff = to - from;
                        diffExt = diff / (this.facet.right - this.facet.left);
                        fromExt = from - this.facet.left * diffExt;
                        toExt = to + (1 - this.facet.right) * diffExt;
                        if (fromExt < 0 && this.scene.stack.length > 1) {
                this.facet.left = Math.min(0.75, - fromExt / diffExt);
                        this.facet.right = 1 - this.facet.left / 5;
                        return[0, diff]
                } else {
                if (from < 0) {
                fr = Math.max( - diff, from / 2);
                        return[fr, fr + diff]
                } else {
                if (this.facet.totalCount > 0 && toExt > this.facet.totalCount) {
                cnt = this.facet.totalCount;
                        t = cnt + Math.min(diff, (to - cnt) / 2);
                        return[t - diff, t]
                } else {
                return[from, to]
                }
                }
                }
                };
                Facetchart_Scrolling.prototype.onSnapAfterDragging = function(from, to, origin, isScrolling, isScaling) {
                var _ref;
                        if (this.facet.left > 0.5 && this.scene.stack.length > 1) {
                this.goUp("user");
                        return null
                } else {
                _ref = this.snap(from, to, origin, isScrolling, isScaling), from = _ref[0], to = _ref[1];
                        this.animateFillChart();
                        this.chart.notifyChartUpdate("user");
                        return[from, to]
                }
                };
                Facetchart_Scrolling.prototype.onPositionChanged = function(from, to) {
                var f;
                        f = this.facet;
                        f.from = from;
                        f.to = to;
                        this.chart.builder.updateFacet(f);
                        return this.events.notifySceneChanges({position: true})
                };
                Facetchart_Scrolling.prototype.onAnimationDone = function(from, to) {
                this.chart.notifyChartUpdate(null);
                        return this.chart.notifyAnimationDone()
                };
                Facetchart_Scrolling.prototype.snap = function(from, to, origin, scroll, scale) {
                var curItemSize, itemSize, newFrom;
                        curItemSize = this.scene.width / (to - from);
                        itemSize = Math.max(this.scene.settings.facetAxis.minUnitWidth, Math.min(this.scene.settings.facetAxis.maxUnitWidth, curItemSize));
                        if (this.facet.totalCount > 0) {
                itemSize = Math.max(itemSize, this.scene.width / this.facet.totalCount)
                }
                scale = curItemSize / itemSize;
                        from = origin + (from - origin) * scale;
                        to = origin + (to - origin) * scale;
                        from = Math.round(from);
                        to = Math.round(to);
                        if (from < 0) {
                to -= from;
                        from = 0
                } else {
                if (this.facet.totalCount > 0 && to > this.facet.totalCount) {
                newFrom = Math.max(0, this.facet.totalCount - (to - from));
                        to = to - from + newFrom;
                        from = newFrom
                }
                }
                return[from, to]
                };
                Facetchart_Scrolling.prototype.animateFillChart = function() {
                if (this.facet.left !== 0 || this.facet.right !== 1 || this.animatingFacet !== this.facet) {
                this.animatingFacet = this.facet;
                        this.leftAnimator = new Base_Animator(this.facet.left, 0, this.scene.settings.advanced.animationTime, "<>");
                        this.rightAnimator = new Base_Animator(this.facet.right, 1, this.scene.settings.advanced.animationTime, "<>");
                        this.opacityAnimator = new Base_Animator(this.facet.opacity, 1, this.scene.settings.advanced.animationTime, "<>");
                        return this.events.notifySceneChanges({animating: true})
                }
                };
                Facetchart_Scrolling.prototype.stopAnim = function() {
                this.animatingFacet = null;
                        this.leftAnimator = null;
                        return this.rightAnimator = null
                };
                Facetchart_Scrolling.prototype.layoutFacets = function() {
                var f, i, opacity, parent, _i, _ref, _ref1, _results;
                        f = this.facet;
                        if (f.left > 0 || f.right < 1) {
                opacity = 0.5
                } else {
                opacity = 0
                }
                _results = [];
                        for (i = _i = _ref = this.scene.stack.length - 2; _i >= 0; i = _i += - 1) {
                parent = this.scene.stack[i];
                        if (f.parentItem) {
                _ref1 = this.scene.getFacetPlacementFromItem(f.parentItem, f.left, f.right), parent.left = _ref1[0], parent.right = _ref1[1]
                }
                parent.opacity = opacity;
                        opacity = parent.left > 0 || parent.right < 1 ? 0.2 : 0;
                        _results.push(f = parent)
                }
                return _results
                };
                return Facetchart_Scrolling
        })(Linearchart_Scrolling);
        var Facetchart_Builder;
        Facetchart_Builder = (function() {
        function Facetchart_Builder(chart) {
        this.chart = chart;
                this.scene = chart.scene;
                this.loading = false
        }
        Facetchart_Builder.prototype.updateFacet = function(facet, event) {
        var changes, curToOffset, data, fromData, fromOffset, i, itemsToShow, maxSliceCount, minSliceCount, newItems, pieIds, toData, toOffset, _i, _j, _ref, _ref1;
                data = this.scene.data.getPieData(facet.id);
                facet.data = data;
                if (!data) {
        facet.loading = true;
                this.scene.data.requestPieData(facet.id, Math.floor(facet.from));
                return
        }
        changes = false;
                if (!(facet.from < facet.to) || facet.rebuild) {
        facet.rebuild = false;
                minSliceCount = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.maxUnitWidth));
                maxSliceCount = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.minUnitWidth));
                if (data.totalCount) {
        itemsToShow = Math.min(data.totalCount, maxSliceCount)
        } else {
        itemsToShow = maxSliceCount
        }
        facet.offset = Math.floor(facet.from);
                facet.count = 0;
                facet.to = facet.from + Math.round(itemsToShow);
                facet.items = []
        }
        if (data.totalCount) {
        facet.totalCount = data.totalCount
        }
        fromOffset = Math.max(0, Math.floor(facet.from));
                toOffset = Math.ceil(facet.to);
                toData = data.values.length + data.offset;
                fromData = data.offset;
                facet.loading = false;
                if (fromData > fromOffset) {
        fromOffset = fromData;
                this.scene.data.requestLessPieData(facet.id);
                facet.loading = true
        }
        if (toData < toOffset) {
        toOffset = toData;
                if (!data.done) {
        this.scene.data.requestMorePieData(facet.id);
                facet.loading = true
        }
        }
        curToOffset = facet.offset + facet.items.length;
                if (toOffset < facet.offset || fromOffset > curToOffset) {
        facet.offset = fromOffset;
                facet.items = [];
                curToOffset = fromOffset
        }
        if (fromOffset > facet.offset) {
        facet.items = facet.items.slice(fromOffset - facet.offset);
                facet.offset = fromOffset
        } else {
        if (fromOffset < facet.offset) {
        newItems = [];
                for (i = _i = fromOffset, _ref = facet.offset - 1; _i <= _ref; i = _i += 1) {
        newItems.push(this.buildItem(facet, data, i))
        }
        facet.items = newItems.concat(facet.items);
                facet.offset = fromOffset;
                changes = true
        }
        }
        if (toOffset < curToOffset) {
        facet.items = facet.items.slice(0, toOffset - facet.offset)
        } else {
        if (toOffset > curToOffset) {
        for (i = _j = curToOffset, _ref1 = toOffset - 1; _j <= _ref1; i = _j += 1) {
        facet.items.push(this.buildItem(facet, data, i))
        }
        changes = true
        }
        }
        facet.count = facet.items.length;
                if (changes) {
        if (event) {
        event.changes.items = true;
                if (!event.changes.changedItems) {
        event.changes.changedItems = {}
        }
        event.changes.changedItems[facet.id] = true
        } else {
        pieIds = [];
                pieIds[facet.id] = true;
                this.chart.events.notifySceneChanges({items: true, changedItems: pieIds})
        }
        }
        return this.scene.updateLinks(facet)
        };
                Facetchart_Builder.prototype.rebuildValues = function(facet) {
                var item, _i, _len, _ref, _results;
                        _ref = facet.items;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                        _results.push(this.updateItem(item))
                }
                return _results
                };
                Facetchart_Builder.prototype.buildItem = function(facet, data, index) {
                var item;
                        data = data.values[index - data.offset];
                        item = new Facetchart_Item(facet, data.__id, index, data);
                        this.updateItem(item);
                        return item
                };
                Facetchart_Builder.prototype.updateItem = function(item) {
                var field, func, series, value, values, _i, _len, _ref;
                        values = [];
                        _ref = this.scene.settings.series;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                series = _ref[_i];
                        value = new Facetchart_ItemValue(item.facet, item.id, item.index, item.data);
                        if (item.data) {
                func = series.data.valueFunction;
                        if (func) {
                value.value = parseFloat(func(item.data))
                } else {
                field = series.data.field || "value";
                        value.value = parseFloat(item.data[field])
                }
                } else {
                value.value = null
                }
                values.push(value)
                }
                return item.values = values
                };
                return Facetchart_Builder
        })();
        var Facetchart_Styles;
        Facetchart_Styles = (function() {
        Facetchart_Styles.prototype.animationPriority = 1000;
                function Facetchart_Styles(chart) {
                this.chart = chart;
                        this.scene = chart.scene
                }
        Facetchart_Styles.prototype.doAnimations = function(event) {
        var facet, _results;
                if (!(event.changes.settings || event.changes.items || event.changes.selection || event.changes.navigation)) {
        return
        }
        facet = this.scene.activeFacet;
                if (!facet) {
        return
        }
        this.computeFacetStyleRec(facet);
                _results = [];
                while (facet && facet.parentItem) {
        facet = facet.parentItem.facet;
                _results.push(this.computeFacetStyleRec(facet))
        }
        return _results
        };
                Facetchart_Styles.prototype.computeFacetStyleRec = function(facet) {
                var i, item, _i, _len, _ref, _results;
                        this.computeFacetStyle(facet);
                        _ref = facet.items;
                        _results = [];
                        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                item = _ref[i];
                        this.computeItemStyle(facet, item);
                        if (item.innerFacet) {
                _results.push(this.computeFacetStyleRec(item.innerFacet))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                Facetchart_Styles.prototype.computeFacetStyle = function(facet) {
                return 1
                };
                Facetchart_Styles.prototype.computeItemStyle = function(facet, item, i) {
                var s, series, value, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
                        series = this.scene.settings.computedSeries;
                        Base_Helpers.extend(item, this.scene.settings.items.style);
                        if (item.selected) {
                Base_Helpers.extend(item, this.scene.settings.items.selectedStyle)
                }
                if (this.scene.hoverItem === item) {
                Base_Helpers.extend(item, this.scene.settings.items.hoverStyle)
                }
                if (item.data.style) {
                Base_Helpers.extend(item, item.data.style)
                }
                if (item.id === item.facet.activeItemId) {
                _ref = item.values;
                        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                value = _ref[i];
                        value.fillColor = null;
                        value.lineColor = null
                }
                } else {
                _ref1 = item.values;
                        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                value = _ref1[i];
                        Base_Helpers.extend(value, series[i].style)
                }
                }
                if (this.scene.settings.items.styleFunction) {
                this.scene.settings.items.styleFunction(item, item.data);
                        if (item.label && !Base_Helpers.isString(item.label)) {
                item.label = "" + item.label
                }
                } else {
                if (item.data.name) {
                item.label = item.data.name
                }
                }
                if (item.id !== item.facet.activeItemId) {
                _ref2 = item.values;
                        _results = [];
                        for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
                value = _ref2[i];
                        s = series[i];
                        if (s.styleFunction) {
                _results.push(s.styleFunction(value, item.data))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                }
                };
                return Facetchart_Styles
        })();
        var Base_ChartElement, Base_ChartEvents, Base_SceneEvent, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        };
        Base_SceneEvent = (function() {
        function Base_SceneEvent() {
        }
        Base_SceneEvent.prototype.time = 0;
                Base_SceneEvent.prototype.animating = false;
                Base_SceneEvent.prototype.changes = {};
                return Base_SceneEvent
        })();
        Base_ChartElement = (function() {
        function Base_ChartElement() {
        }
        Base_ChartElement.prototype.animationPriority = 0;
                Base_ChartElement.prototype.remove = function() {
                return false
                };
                Base_ChartElement.prototype.doAnimations = function(sceneEvent) {
                return false
                };
                Base_ChartElement.prototype.paintScene = function(sceneEvent) {
                return false
                };
                Base_ChartElement.prototype.onSceneChange = function(event) {
                return false
                };
                Base_ChartElement.prototype.onClick = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.onRClick = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.onDoubleClick = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.onPointerDown = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.onPointerUp = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.onPointerDrag = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.onPointerMove = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.onPointerOut = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.onPointerCancel = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.onWheel = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.onKeyDown = function(keyEvent) {
                return false
                };
                Base_ChartElement.prototype.previewWheel = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.previewPointerDown = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.previewPointerUp = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.previewPointerDrag = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.previewPointerMove = function(mouseEvent) {
                return false
                };
                Base_ChartElement.prototype.previewPointerOut = function(mouseEvent) {
                return false
                };
                return Base_ChartElement
        })();
        Base_ChartEvents = (function() {
        Base_ChartEvents.prototype.container = null;
                Base_ChartEvents.prototype.paintRequested = null;
                Base_ChartEvents.prototype.mouseEvents = null;
                Base_ChartEvents.prototype.verbose = false;
                function Base_ChartEvents(container, canvas, chart) {
                this.container = container;
                        this.canvas = canvas;
                        this.chart = chart;
                        this._paintScene = __bind(this._paintScene, this);
                        this.kd = __bind(this.kd, this);
                        this.mw = __bind(this.mw, this);
                        this.mdbl = __bind(this.mdbl, this);
                        this.rcl = __bind(this.rcl, this);
                        this.mcl = __bind(this.mcl, this);
                        this.mcc = __bind(this.mcc, this);
                        this.mlve = __bind(this.mlve, this);
                        this.mmve = __bind(this.mmve, this);
                        this.mdrg = __bind(this.mdrg, this);
                        this.mup = __bind(this.mup, this);
                        this.mdwn = __bind(this.mdwn, this);
                        this.scene = this.chart.scene;
                        this.settings = this.chart.settings;
                        this.elements = [];
                        this.elementsReverse = [];
                        this.pointerToElement = {};
                        this.sceneChanges = {};
                        this.animationOrder = [];
                        this.hooks = {};
                        this.mouseEvents = new Base_MouseEvents(this.container, this.settings.advanced.pointer, this.chart, this.whiteList);
                        this.mouseEvents.listen(this.mouseEvents.EVENT_DOWN, this.mdwn);
                        this.mouseEvents.listen(this.mouseEvents.EVENT_UP, this.mup);
                        this.mouseEvents.listen(this.mouseEvents.EVENT_DRAG, this.mdrg);
                        this.mouseEvents.listen(this.mouseEvents.EVENT_MOVE, this.mmve);
                        this.mouseEvents.listen(this.mouseEvents.EVENT_LEAVE, this.mlve);
                        this.mouseEvents.listen(this.mouseEvents.EVENT_CANCEL, this.mcc);
                        this.mouseEvents.listen(this.mouseEvents.EVENT_CLICK, this.mcl);
                        this.mouseEvents.listen(this.mouseEvents.EVENT_RCLICK, this.rcl);
                        this.mouseEvents.listen(this.mouseEvents.EVENT_DBLCLICK, this.mdbl);
                        this.mouseEvents.listen(this.mouseEvents.EVENT_WHEEL, this.mw);
                        Base_Helpers.listen(this.container, "keydown", this.kd)
                }
        Base_ChartEvents.prototype.addWhiteList = function(item) {
        return this.mouseEvents.addWhiteList(item)
        };
                Base_ChartEvents.prototype.remove = function() {
                this.mouseEvents.remove();
                        return Base_Helpers.unlisten(this.container, "keydown", this.kd)
                };
                Base_ChartEvents.prototype.setScaling = function(x, y) {
                this.mouseEvents.scaleX = x;
                        return this.mouseEvents.scaleY = y
                };
                Base_ChartEvents.prototype.addElement = function(element) {
                element.animationPriority = element.animationPriority || 0;
                        this.elements.push(element);
                        this.elementsReverse.splice(0, 0, element);
                        this.animationOrder = this.elements.slice(0);
                        this.animationOrder.sort(function(a, b) {
                        return b.animationPriority - a.animationPriority
                        });
                        return element
                };
                Base_ChartEvents.prototype.removeElement = function(element) {
                Base_Helpers.removeFromArray(this.elements, element);
                        Base_Helpers.removeFromArray(this.animationOrder, element);
                        return Base_Helpers.removeFromArray(this.elementsReverse, element)
                };
                Base_ChartEvents.prototype.notifySceneChanges = function(changes) {
                if (!Base_Helpers.hasProperties(changes)) {
                return
                }
                Base_Helpers.extendDeep(this.sceneChanges, changes);
                        this._requestPaint()
                };
                Base_ChartEvents.prototype.clearSceneChanges = function(changes) {
                var k, v, _results;
                        _results = [];
                        for (k in changes) {
                v = changes[k];
                        _results.push(delete this.sceneChanges[k])
                }
                return _results
                };
                Base_ChartEvents.prototype.addHook = function(obj, hook, callback) {
                if (typeof this.hooks[hook] === "undefined") {
                this.hooks[hook] = []
                }
                return this.hooks[hook].push({obj: obj, callback: callback})
                };
                Base_ChartEvents.prototype.hook = function(hook, arg, caller) {
                var v, _i, _len, _ref, _results;
                        this.chart.log("firing hook", {hook: hook, arg: arg, caller: caller});
                        if (this.hooks[hook]) {
                _ref = this.hooks[hook];
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                v = _ref[_i];
                        _results.push(v.callback.call(v.obj, hook, arg, caller))
                }
                return _results
                }
                };
                Base_ChartEvents.prototype.mdwn = function(event) {
                var element;
                        element = this._notify(event, "PointerDown");
                        this.pointerToElement[event.identifier] = element;
                        this.notifySceneChanges(event.changes);
                        return this.container.focus()
                };
                Base_ChartEvents.prototype.mup = function(event) {
                this._notify(event, "PointerUp");
                        this.pointerToElement[event.identifier] = null;
                        return this.notifySceneChanges(event.changes)
                };
                Base_ChartEvents.prototype.mdrg = function(event) {
                var element;
                        element = this._notify(event, "PointerDrag");
                        this.pointerToElement[event.identifier] = element;
                        return this.notifySceneChanges(event.changes)
                };
                Base_ChartEvents.prototype.mmve = function(event) {
                var element;
                        element = this._notify(event, "PointerMove");
                        this.pointerToElement[event.identifier] = element;
                        return this.notifySceneChanges(event.changes)
                };
                Base_ChartEvents.prototype.mlve = function(event) {
                this._notify(event, "PointerOut");
                        return this.notifySceneChanges(event.changes)
                };
                Base_ChartEvents.prototype.mcc = function(event) {
                this._notify(event, "PointerCancel");
                        return this.notifySceneChanges(event.changes)
                };
                Base_ChartEvents.prototype.mcl = function(event) {
                this._notify(event, "Click");
                        return this.notifySceneChanges(event.changes)
                };
                Base_ChartEvents.prototype.rcl = function(event) {
                this._notify(event, "RightClick");
                        return this.notifySceneChanges(event.changes)
                };
                Base_ChartEvents.prototype.mdbl = function(event) {
                this._notify(event, "DoubleClick");
                        return this.notifySceneChanges(event.changes)
                };
                Base_ChartEvents.prototype.mw = function(event) {
                this._notify(event, "Wheel");
                        return this.notifySceneChanges(event.changes)
                };
                Base_ChartEvents.prototype.kd = function(event) {
                if (!event.keyCode) {
                event.keyCode = event.which
                }
                this._notifyKeyEvent(event, "KeyDown");
                        this.notifySceneChanges(event.changes);
                        if (event.consumed) {
                return event.preventDefault()
                }
                };
                Base_ChartEvents.prototype._notify = function(event, name) {
                var element, firstCursor, funcName, _i, _j, _len, _len1, _ref, _ref1;
                        event.changes = {};
                        event.consumed = false;
                        event.noDefault = false;
                        event.cursor = null;
                        funcName = "preview" + name;
                        _ref = this.elementsReverse;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                element = _ref[_i];
                        if (element[funcName] != null) {
                element[funcName].call(element, event)
                }
                }
                funcName = "on" + name;
                        element = this.pointerToElement[event.identifier];
                        if (element) {
                if (element[funcName] != null) {
                element[funcName].call(element, event);
                        if (event.consumed) {
                if (event.cursor) {
                this.container.style.cursor = event.cursor
                }
                if (this.verbose) {
                console.log("" + name + ": " + event.identifier + ", c=" + event.consumed)
                }
                return element
                }
                }
                }
                firstCursor = null;
                        _ref1 = this.elementsReverse;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                element = _ref1[_j];
                        if (element[funcName] != null) {
                element[funcName].call(element, event);
                        if (event.consumed) {
                if (event.cursor) {
                this.container.style.cursor = event.cursor
                }
                if (this.verbose) {
                console.log("" + name + ": " + event.identifier + ", c=" + event.consumed)
                }
                return element
                } else {
                if ((firstCursor == null) && (event.cursor != null)) {
                firstCursor = event.cursor
                }
                }
                }
                }
                this.container.style.cursor = firstCursor;
                        event.consumed || (event.consumed = event.noDefault);
                        if (this.verbose) {
                console.log("" + name + ": " + event.identifier + ", c=" + event.consumed)
                }
                return null
                };
                Base_ChartEvents.prototype._notifyKeyEvent = function(event, name) {
                var element, funcName, _i, _len, _ref;
                        event.changes = {};
                        event.consumed = false;
                        event.cursor = null;
                        funcName = "on" + name;
                        _ref = this.elementsReverse;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                element = _ref[_i];
                        if (element[funcName] != null) {
                element[funcName].call(element, event);
                        if (event.consumed) {
                break
                }
                }
                }
                return null
                };
                Base_ChartEvents.prototype._requestPaint = function() {
                if (this.paintRequested === null) {
                return this.paintRequested = window.requestAnimationFrame(this._paintScene)
                }
                };
                Base_ChartEvents.prototype.paintNow = function() {
                if (this.paintRequested !== null) {
                if (window.cancelRequestAnimationFrame) {
                cancelAnimationFrame(this.paintRequested)
                }
                return this._paintScene()
                }
                };
                Base_ChartEvents.prototype._paintScene = function() {
                var e, el, event, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
                        if (this.chart.removed) {
                return
                }
                this.paintRequested = null;
                        event = new Base_SceneEvent();
                        event.time = new Date().getTime();
                        event.changes = this.sceneChanges;
                        event["export"] = false;
                        event.context = this.canvas.getContext("2d");
                        this.sceneChanges = {};
                        _ref = this.elementsReverse;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                el = _ref[_i];
                        if (el.onSceneChange != null) {
                el.onSceneChange(event)
                }
                }
                event.context = this.prepareContext(event);
                        _ref1 = this.animationOrder;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                e = _ref1[_j];
                        if (e.doAnimations != null) {
                e.doAnimations(event)
                }
                }
                _ref2 = this.elements;
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                e = _ref2[_k];
                        if (e.paintScene != null) {
                e.paintScene(event)
                }
                }
                //if (event.animating) {
                this._requestPaint()
                        //}
                        return this.finalizeContext(event)
                };
                Base_ChartEvents.prototype.prepareContext = function(event) {
                var context, heightPx, scene, widthPx;
                        if (event.changes.bounds) {
                scene = this.chart.scene;
                        this.scaleX = Math.min(scene.canvasScaleX, scene.settings.advanced.maxCanvasWidth / scene.chartWidth);
                        this.scaleY = Math.min(scene.canvasScaleY, scene.settings.advanced.maxCanvasHeight / scene.chartHeight);
                        widthPx = Math.round(scene.chartWidth * this.scaleX);
                        heightPx = Math.round(scene.chartHeight * this.scaleY);
                        this.canvas.width = widthPx;
                        this.canvas.height = heightPx;
                        this.canvas.style.width = "" + scene.chartWidth + "px";
                        this.canvas.style.height = "" + scene.chartHeight + "px"
                }
                context = this.canvas.getContext("2d");
                        context.setTransform(1, 0, 0, 1, 0, 0);
                        context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        Base_Graphics.rectStyle(context, this.settings.area.style);
                        context.fillRect(0, 0, this.canvas.width, this.canvas.height);
                        context.setTransform(this.scaleX, 0, 0, this.scaleY, 0, 0);
                        return context
                };
                Base_ChartEvents.prototype.finalizeContext = function(event) {
                var context;
                        if (this.settings.area.style.overlayColor) {
                context = event.context;
                        context.fillStyle = this.settings.area.style.overlayColor;
                        context.setTransform(1, 0, 0, 1, 0, 0);
                        return context.fillRect(0, 0, this.canvas.width, this.canvas.height)
                }
                };
                Base_ChartEvents.prototype.exportGetDimensions = function(dimensions) {
                var bounds, chartHeight, chartWidth, height, pixelsPerMM, scale, width;
                        bounds = this.scene.getChartBounds();
                        chartWidth = bounds.right - bounds.left;
                        chartHeight = bounds.bottom - bounds.top;
                        width = parseFloat(dimensions.width);
                        height = parseFloat(dimensions.height);
                        if (width > 0 && height > 0) {
                scale = Math.min(width / chartWidth, height / chartHeight)
                } else {
                if (width > 0) {
                scale = width / chartWidth;
                        height = chartHeight * scale
                } else {
                if (height > 0) {
                scale = height / chartHeight;
                        width = chartWidth * scale
                } else {
                scale = dimensions.scaling > 0 ? parseFloat(dimensions.scaling) : 1;
                        width = chartWidth * scale * this.scene.canvasScaleX;
                        height = chartHeight * scale * this.scene.canvasScaleY
                }
                }
                }
                if (dimensions.unit === "mm") {
                if (dimensions.dpi > 0 && dimensions.width > 0 && dimensions.height > 0) {
                pixelsPerMM = parseFloat(dimensions.dpi) / 25.4;
                        scale *= pixelsPerMM;
                        width *= pixelsPerMM;
                        height *= pixelsPerMM
                } else {
                throw"Invalid export configuration. If unit = mm, dpi, width and height must be supplied"
                }
                }
                return[width, height, scale]
                };
                Base_ChartEvents.prototype.exportToImage = function(type, dimensions, transparent) {
                var bounds, canvas, ch1, ch2, context, cw1, cw2, dh, e, event, h1, h2, height, mime, mime_map, scale, scaleX, scaleY, w1, w2, width, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
                        if (dimensions == null) {
                dimensions = {}
                }
                if (this.chart.title) {
                _ref = this.chart.title.computeSize(this.chart.layers.canvas.getContext("2d"), true), w1 = _ref[0], h1 = _ref[1];
                        _ref1 = this.chart.title.computeSize(this.chart.layers.canvas.getContext("2d")), w2 = _ref1[0], h2 = _ref1[1]
                } else {
                w1 = h1 = w2 = h2 = 0
                }
                if (this.chart.credits) {
                _ref2 = this.chart.credits.computeSize(this.chart.layers.canvas.getContext("2d"), true), cw1 = _ref2[0], ch1 = _ref2[1];
                        _ref3 = this.chart.credits.computeSize(this.chart.layers.canvas.getContext("2d")), cw2 = _ref3[0], ch2 = _ref3[1]
                } else {
                cw1 = ch1 = cw2 = ch2 = 0
                }
                mime_map = {png: "image/png", jpeg: "image/jpeg"};
                        mime = mime_map[type];
                        _ref4 = this.exportGetDimensions(dimensions), width = _ref4[0], height = _ref4[1], scale = _ref4[2];
                        canvas = document.createElement("canvas");
                        canvas.width = width;
                        if (h1 > h2) {
                dh = h1
                } else {
                if (h1 < h2) {
                dh = - h2
                } else {
                dh = 0
                }
                }
                height += dh * scale * this.scene.canvasScaleY;
                        if (ch1 > ch2) {
                height += ch1 * scale * this.scene.canvasScaleY
                } else {
                if (ch1 < ch2) {
                height -= ch2 * scale * this.scene.canvasScaleY
                }
                }
                canvas.height = height;
                        context = canvas.getContext("2d");
                        if (!transparent) {
                context.fillStyle = "#fff";
                        context.fillRect(0, 0, canvas.width, canvas.height)
                }
                bounds = this.scene.getChartBounds();
                        scaleX = scale * this.scene.canvasScaleX;
                        scaleY = scale * this.scene.canvasScaleY;
                        context.setTransform(scaleX, 0, 0, scaleY, - bounds.left * scaleX, ( - bounds.top + dh) * scaleY);
                        event = new Base_SceneEvent();
                        event["export"] = true;
                        event.time = new Date().getTime();
                        event.changes = {};
                        event.context = context;
                        _ref5 = this.elements;
                        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
                e = _ref5[_i];
                        if (e.paintScene != null) {
                e.paintScene(event)
                }
                }
                return canvas.toDataURL(mime)
                };
                return Base_ChartEvents
        })();
        var Base_TouchMarkers, __hasProp = {}.hasOwnProperty;
        Base_TouchMarkers = (function() {
        Base_TouchMarkers.prototype.animationPriority = 0;
                Base_TouchMarkers.prototype.scene = null;
                Base_TouchMarkers.prototype.touches = {};
                Base_TouchMarkers.prototype.text = null;
                Base_TouchMarkers.prototype.fps = 0;
                Base_TouchMarkers.prototype.fpsAveragingPeriod = 1000;
                Base_TouchMarkers.prototype.prevFrame = null;
                function Base_TouchMarkers(scene) {
                this.scene = scene;
                        this.scene.frameCount = 0;
                        this.touches = {}
                }
        Base_TouchMarkers.prototype.paintScene = function(event) {
        var count, dt, fp, g, k, p, prop, t, _i, _len, _ref, _ref1;
                this.scene.frameCount += 1;
                if (this.prevFrame) {
        dt = Math.max(event.time - this.prevFrame, 1) / 1000;
                fp = 1 / dt;
                prop = Math.min(1, dt * 3);
                this.fps = this.fps * (1 - prop) + fp * prop
        }
        this.prevFrame = event.time;
                g = event.context;
                g.strokeStyle = "#000";
                g.fillStyle = "#000";
                g.beginPath();
                count = 0;
                _ref = this.touches;
                for (k in _ref) {
        if (!__hasProp.call(_ref, k)) {
        continue
        }
        t = _ref[k];
                count += 1;
                g.moveTo(t.dx + 10, t.dy);
                g.arc(t.dx, t.dy, 10, 0, Math.PI * 2);
                g.moveTo(t.x + 30, t.y);
                g.arc(t.x, t.y, 30, 0, Math.PI * 2);
                g.moveTo(t.dx, t.dy);
                _ref1 = t.trace;
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        p = _ref1[_i];
                g.lineTo(p.x, p.y);
                g.arc(p.x, p.y, 3, 0, Math.PI * 2)
        }
        }
        g.stroke();
                g.textAlign = "start";
                g.textBaseline = "middle";
                return g.fillText("FPS: " + (Math.round(this.fps)) + ", touches: " + count, this.scene.x0 + this.scene.width / 3, 20)
        };
                Base_TouchMarkers.prototype.previewPointerDown = function(event) {
                var k, t, _ref;
                        _ref = this.touches;
                        for (k in _ref) {
                if (!__hasProp.call(_ref, k)) {
                continue
                }
                t = _ref[k];
                        if (t.up) {
                delete this.touches[k]
                }
                }
                this.touches[event.identifier] = {dx: event.x, dy: event.y, up: false, trace: []};
                        return event.changes.pointers = true
                };
                Base_TouchMarkers.prototype.previewPointerDrag = function(event) {
                var t;
                        t = this.touches[event.identifier];
                        t.x = event.x;
                        t.y = event.y;
                        return t.trace.push({x: t.x, y: t.y})
                };
                Base_TouchMarkers.prototype.previewPointerUp = function(event) {
                this.touches[event.identifier].up = true;
                        return this.previewPointerDrag(event)
                };
                Base_TouchMarkers.prototype.previewPointerCancel = function(event) {
                this.touches[event.identifier].up = true;
                        return this.previewPointerDrag(event)
                };
                return Base_TouchMarkers
        })();
        var Base_InfoPopup;
        Base_InfoPopup = (function() {
        function Base_InfoPopup(chart) {
        this.chart = chart;
                this.container = chart.layers.container;
                this.scene = chart.scene;
                this.events = chart.events;
                this.popup = Base_Helpers.createDom("div", "DVSL-info-center", null, this.container);
                Base_Helpers.createDom("em", null, null, this.popup);
                this.events.addWhiteList(this.popup);
                this.popup.style.position = "absolute";
                this.popup.style.display = "none";
                this.contents = null;
                this.visible = false;
                this.x0 = null;
                this.x1 = null;
                this.y = null;
                this.contentsChanged = false;
                this.chart.events.addWhiteList(this.popup)
        }
        Base_InfoPopup.prototype.hide = function() {
        if (!this.visible) {
        return false
        }
        this.visible = false;
                this.popup.style.display = "none";
                return true
        };
                Base_InfoPopup.prototype.show = function(x0, x1, y, contents) {
                this.visible = true;
                        if (contents) {
                if (contents.indexOf("<") === - 1 && contents.indexOf(">") === - 1) {
                contents = "<b>" + contents + "</b>"
                }
                this.popup.style.display = "block";
                        if (contents !== this.popup.innerHTML) {
                this.popup.innerHTML = contents;
                        this.contentsChanged = true
                }
                return this.updateXY(x0, x1, y)
                } else {
                return this.popup.style.display = "none"
                }
                };
                Base_InfoPopup.prototype.updateContents = function(contents) {
                if (!!this.visible) {
                return
                }
                if (contents === null) {
                return this.hide()
                } else {
                return this.show(this.x0, this.x1, this.y, contents)
                }
                };
                Base_InfoPopup.prototype.updateXY = function(x0, x1, y) {
                var arrowWidth, cl, h, margin, w, x;
                        if (!(this.visible || this.contentsChanged || this.x0 !== x0 || this.x1 !== x1 || this.y !== y)) {
                return
                }
                if (this.contentsChanged) {
                this.contentsChanged = false;
                        this.width = this.popup.offsetWidth;
                        this.height = this.popup.offsetHeight
                }
                this.x0 = x0;
                        this.x1 = x1;
                        this.y = y;
                        margin = 12;
                        arrowWidth = 10;
                        w = this.width;
                        h = this.height;
                        if (this.scene.x0 <= x0 - w - arrowWidth) {
                x = x0 - w - arrowWidth;
                        cl = "DVSL-info-left"
                } else {
                if (this.scene.x0 + this.scene.width >= x1 + w + arrowWidth) {
                x = x1 + arrowWidth;
                        cl = "DVSL-info-right"
                } else {
                x = (x0 + x1 - w) / 2;
                        cl = "DVSL-info-center"
                }
                }
                y = Math.min(Math.max(this.scene.y0 + margin, y - h / 2), this.scene.y0 + this.scene.height - h);
                        this.popupX = x;
                        this.popupY = y;
                        this.popup.style.left = x + "px";
                        this.popup.style.top = y + "px";
                        return Base_Helpers.setClass(this.popup, cl)
                };
                return Base_InfoPopup
        })();
        var Linearchart_Markers;
        Linearchart_Markers = (function() {
        Linearchart_Markers.prototype.scene = null;
                function Linearchart_Markers(chart) {
                this.chart = chart;
                        this.scene = this.chart.scene
                }
        Linearchart_Markers.prototype.paintScene = function(event) {
        var format, g, height, marker, text, w, x, x0, x1, y0, y1, yLabel, _i, _len, _ref;
                if (!(this.scene.markers.length > 0 && (this.scene.displayUnit != null))) {
        return
        }
        x0 = this.scene.x0;
                x1 = x0 + this.scene.width;
                y0 = Math.round(this.scene.y0);
                height = this.scene.height;
                yLabel = Math.round(y0 + height + this.scene.bottomAxisSize * 0.5);
                y1 = Math.round(y0 + height + this.scene.bottomAxisSize);
                g = event.context;
                Base_Graphics.pushClip(g, x0, y0, this.scene.width, this.scene.height + this.scene.bottomAxisSize);
                g.textBaseline = "middle";
                format = this.scene.settings.localization.markerDates.timeFormats[this.scene.displayUnit.unit];
                Base_Graphics.textStyle(g, this.scene.settings.area.style.markerText);
                _ref = this.scene.markers;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        marker = _ref[_i];
                x = this.scene.timeToX(marker.time);
                if (!(x >= x0 - 1 && x <= x1 + 1)) {
        continue
        }
        g.beginPath();
                g.moveTo(x, y0);
                g.lineTo(x, y1);
                Base_Graphics.stroke(g, marker.style);
                Base_Graphics.textStyle(g, marker.style);
                text = moment(marker.time).utc().format(format);
                w = g.measureText(text).width;
                if (x + w >= x1) {
        g.textAlign = "end";
                x -= 2
        } else {
        g.textAlign = "start";
                x += 2
        }
        g.fillText(text, x, yLabel)
        }
        return Base_Graphics.popClip(g)
        };
                return Linearchart_Markers
        })();
        var Linearchart_Highlights;
        Linearchart_Highlights = (function() {
        Linearchart_Highlights.prototype.animationPriority = 9;
                Linearchart_Highlights.prototype.scene = null;
                Linearchart_Highlights.prototype.customId = 0;
                Linearchart_Highlights.prototype.animating = false;
                Linearchart_Highlights.prototype.highlights = {};
                function Linearchart_Highlights(chart) {
                this.chart = chart;
                        this.scene = chart.scene;
                        this.highlights = {}
                }
        Linearchart_Highlights.prototype.doAnimations = function(event) {
        var existingHighlights, k, m, mm, newAnimating, time, _i, _len, _ref, _ref1, _ref2, _ref3;
                if (event.changes.highlight) {
        existingHighlights = [];
                _ref = this.highlights;
                for (k in _ref) {
        m = _ref[k];
                m.mode = "exiting";
                if (m.origin.keepTrack === false) {
        delete this.highlights[k];
                existingHighlights.push(m)
        }
        }
        for (_i = 0, _len = existingHighlights.length; _i < _len; _i++) {
        m = existingHighlights[_i];
                this.highlights["__" + this.customId] = m;
                this.customId += 1
        }
        _ref1 = this.scene.highlights;
                for (k in _ref1) {
        mm = _ref1[k];
                if (this.highlights[k] != null) {
        m = this.highlights[k];
                m.mode = null;
                m.from = mm.from;
                m.to = mm.to;
                if (m.style.fillColor !== mm.style.fillColor && mm.style.fadeCross > 0) {
        this.animating = true;
                m.animator = new Base_Animator(m.style.fillColor, mm.style.fillColor, mm.style.fadeCross, "=", event.time)
        } else {
        m.style = Base_Helpers.clone(mm.style)
        }
        } else {
        m = {from: mm.from, to: mm.to, style: Base_Helpers.clone(mm.style), origin: mm};
                this.highlights[k] = m;
                if (mm.style.fadeIn > 0) {
        this.animating = true;
                m.animator = new Base_Animator(Base_Graphics.deriveColor(m.style.fillColor, 1, 0), m.style.fillColor, m.style.fadeIn, "=", event.time)
        }
        }
        }
        _ref2 = this.highlights;
                for (k in _ref2) {
        m = _ref2[k];
                if (m.mode === "exiting" && !m.animator) {
        mm = m.origin;
                if (mm.style.fadeOut > 0) {
        this.animating = true;
                m.animator = new Base_Animator(m.style.fillColor, Base_Graphics.deriveColor(m.style.fillColor, 1, 0), m.style.fadeOut, "=", event.time)
        } else {
        delete this.highlights[k]
        }
        }
        }
        }
        if (this.animating) {
        newAnimating = false;
                time = event.time;
                _ref3 = this.highlights;
                for (k in _ref3) {
        m = _ref3[k];
                if (m.animator != null) {
        m.style.fillColor = m.animator.getColor(time);
                if (m.animator.finished(time)) {
        m.animator = null;
                if (m.mode === "exiting") {
        delete this.highlights[k]
        }
        } else {
        newAnimating = true
        }
        }
        }
        this.animating = newAnimating;
                return event.animating |= newAnimating
        }
        };
                Linearchart_Highlights.prototype.paintScene = function(event) {
                var g, height, highlight, hx0, hx1, k, x0, x1, y0, _ref, _results;
                        x0 = this.scene.x0;
                        x1 = x0 + this.scene.width;
                        y0 = Math.round(this.scene.y0);
                        height = this.scene.height;
                        g = event.context;
                        _ref = this.highlights;
                        _results = [];
                        for (k in _ref) {
                highlight = _ref[k];
                        hx0 = Math.max(this.scene.timeToX(highlight.from), x0);
                        hx1 = Math.min(this.scene.timeToX(highlight.to), x1);
                        if (!(hx1 >= x0 && hx0 <= x1)) {
                continue
                }
                Base_Graphics.rectStyle(g, highlight.style);
                        _results.push(g.fillRect(hx0, y0, hx1 - hx0, height))
                }
                return _results
                };
                return Linearchart_Highlights
        })();
        var Linearchart_InfoPopup;
        Linearchart_InfoPopup = (function() {
        Linearchart_InfoPopup.prototype.animationPriority = 10;
                Linearchart_InfoPopup.prototype.t0 = 0;
                Linearchart_InfoPopup.prototype.t1 = 0;
                Linearchart_InfoPopup.prototype.popup = null;
                Linearchart_InfoPopup.prototype.visible = false;
                Linearchart_InfoPopup.prototype.activePointer = null;
                Linearchart_InfoPopup.prototype.pointerX = 0;
                Linearchart_InfoPopup.prototype.pointerY = 0;
                Linearchart_InfoPopup.prototype.getPopupMouseMoved = function(x, y, prevT0, prevT1, prevContents) {
                return null
                };
                Linearchart_InfoPopup.prototype.popupHidden = function(event) {
                return null
                };
                function Linearchart_InfoPopup(chart) {
                this.chart = chart;
                        this.container = chart.layers.container;
                        this.scene = chart.scene;
                        this.events = chart.events;
                        this.popup = new Base_InfoPopup(this.chart)
                }
        Linearchart_InfoPopup.prototype.show = function(event) {
        if (!this.scene.settings.info.enabled) {
        return
        }
        this.pointerX = event.x;
                this.pointerY = event.y;
                return this.updatePopup(event)
        };
                Linearchart_InfoPopup.prototype.previewPointerMove = function(event) {
                if (!(this.scene.settings.info.enabled && (this.activePointer === null || (this.activePointer = event.identifier)))) {
                return
                }
                this.pointerX = event.x;
                        this.pointerY = event.y;
                        return this.updatePopup(event)
                };
                Linearchart_InfoPopup.prototype.previewPointerDrag = function(event) {
                if (!(this.scene.settings.info.enabled && (this.activePointer === null || this.activePointer === event.identifier))) {
                return
                }
                this.activePointer = event.identifier;
                        this.pointerX = event.x;
                        return this.pointerY = event.y
                };
                Linearchart_InfoPopup.prototype.previewPointerCancel = function(event) {
                if (this.activePointer !== null && this.activePointer === event.identifier) {
                return this.activePointer = null
                }
                };
                Linearchart_InfoPopup.prototype.previewPointerUp = function(event) {
                if (this.activePointer !== null && this.activePointer === event.identifier) {
                return this.activePointer = null
                }
                };
                Linearchart_InfoPopup.prototype.previewPointerOut = function(event) {
                if (this.activePointer !== null && this.activePointer !== event.identifier) {
                return
                }
                this.activePointer = null;
                        this.pointerX = null;
                        this.pointerY = null;
                        if (!Base_Helpers.isParentOf(this.popup, event.target)) {
                return this.hideInfoPopup(event)
                }
                };
                Linearchart_InfoPopup.prototype.previewPointerDown = function(event) {
                if (this.activePointer !== null) {
                return
                }
                this.activePointer = event.identifier;
                        return this.hideInfoPopup(event)
                };
                Linearchart_InfoPopup.prototype.updatePopup = function(event) {
                var contents, g, t0, t1;
                        if (!this.pointerX && !this.pointerY) {
                this.hideInfoPopup(event);
                        return
                }
                g = this.getPopupMouseMoved(this.pointerX, this.pointerY, this.t0, this.t1, this.contents);
                        if (g) {
                t0 = g[0], t1 = g[1], contents = g[2];
                        return this.showInfoPopup(t0, t1, contents, event)
                } else {
                return this.hideInfoPopup(event)
                }
                };
                Linearchart_InfoPopup.prototype.showInfoPopup = function(t0, t1, contents, event) {
                var y;
                        if (this.popup.visible && t0 === this.t0 && t1 === this.t1) {
                return
                }
                this.t0 = t0;
                        this.t1 = t1;
                        this.contents = contents;
                        this.scene.setHighlight("infoRange", t0, t1, this.scene.settings.info.style.highlight);
                        y = this.scene.y0;
                        this.popup.show(this.scene.timeToX(this.t0), this.scene.timeToX(this.t1), y, contents);
                        event.changes.infoLabel = true;
                        return event.changes.highlight = true
                };
                Linearchart_InfoPopup.prototype.hideInfoPopup = function(event) {
                if (!this.popup.visible) {
                return
                }
                this.popupHidden(event);
                        this.popup.hide();
                        this.t0 = 0;
                        this.t1 = 0;
                        this.scene.removeHighlight("infoRange");
                        event.changes.infoLabel = true;
                        return event.changes.highlight = true
                };
                Linearchart_InfoPopup.prototype.paintScene = function(event) {
                if (this.popup.visible) {
                return this.updateXY()
                }
                };
                Linearchart_InfoPopup.prototype.updateXY = function() {
                var y;
                        y = this.scene.y0;
                        return this.popup.updateXY(this.scene.timeToX(this.t0), this.scene.timeToX(this.t1), y)
                };
                return Linearchart_InfoPopup
        })();
        var Timechart_TimeSlicer;
        Timechart_TimeSlicer = (function() {
        Timechart_TimeSlicer.prototype.scene = null;
                Timechart_TimeSlicer.prototype.step = null;
                Timechart_TimeSlicer.prototype.uniform = false;
                Timechart_TimeSlicer.prototype.currentFrom = 0;
                Timechart_TimeSlicer.prototype.currentTo = 0;
                Timechart_TimeSlicer.prototype.fromBar = null;
                Timechart_TimeSlicer.prototype.toBar = null;
                Timechart_TimeSlicer.prototype.fromIndex = 0;
                Timechart_TimeSlicer.prototype.toIndex = 0;
                Timechart_TimeSlicer.prototype.times = [];
                Timechart_TimeSlicer.prototype.xes = [];
                Timechart_TimeSlicer.prototype.oldMul = 0;
                Timechart_TimeSlicer.prototype.oldAdd = 0;
                Timechart_TimeSlicer.prototype.arrays = [];
                Timechart_TimeSlicer.prototype.extraArrays = [];
                Timechart_TimeSlicer.prototype.bufExpandSize = 100;
                Timechart_TimeSlicer.prototype.extraSteps = 2;
                Timechart_TimeSlicer.prototype.uniformTolerance = 0;
                Timechart_TimeSlicer.prototype.approxExtraTime = 0;
                function Timechart_TimeSlicer(scene, step, arrays, from, to, uniform) {
                this.scene = scene;
                        this.step = step;
                        if (arrays == null) {
                arrays = []
                }
                this.uniform = uniform != null ? uniform : true;
                        from = from | this.scene.timeStart;
                        to = to | this.scene.timeEnd;
                        this.extraArrays = arrays.slice(0);
                        this.arrays = arrays.slice(0);
                        this.arrays.push("xes");
                        this.arrays.push("times");
                        this.uniformTolerance = Math.min(1, this.step.count - 2);
                        this.approxExtraTime = this.extraSteps * step.approxTime();
                        this.init(from - this.approxExtraTime, to + this.approxExtraTime)
                }
        Timechart_TimeSlicer.prototype._getOrigin = function(from) {
        var t0, unitsToAdd;
                if (this.step.count === 1 || this.uniform) {
        return this.step.roundTimeDown(from)
        }
        t0 = this.step.getBigger().roundTimeDown(from);
                unitsToAdd = this.step.numberOfUnits(t0, from);
                return this.step.add(t0, unitsToAdd)
        };
                Timechart_TimeSlicer.prototype._add = function(m) {
                var date, dim;
                        if (this.uniform || this.step.count === 1 || this.step.unit !== "d") {
                return m.add(this.step.unit, this.step.count)
                } else {
                dim = m.daysInMonth();
                        date = m.date();
                        if (date + this.step.count * 2 > dim + 1 + this.uniformTolerance) {
                return m.add("d", dim - date + 1)
                } else {
                return m.add(this.step.unit, this.step.count)
                }
                }
                };
                Timechart_TimeSlicer.prototype._sub = function(m) {
                var date, dim, targetDay;
                        if (this.uniform || this.step.count === 1 || this.step.unit !== "d") {
                return m.subtract(this.step.unit, this.step.count)
                } else {
                date = m.date();
                        if (date <= this.step.count) {
                m.subtract("M", 1);
                        dim = m.daysInMonth() - 1;
                        targetDay = dim + 1 - this.step.count + this.uniformTolerance;
                        return m.date(1 + targetDay - ((targetDay % this.step.count) | 0))
                } else {
                return m.subtract(this.step.unit, this.step.count)
                }
                }
                };
                Timechart_TimeSlicer.prototype.init = function(from, to) {
                var a, arr, t, x, _i, _j, _len, _len1, _ref, _ref1, _results;
                        _ref = this.arrays;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                a = _ref[_i];
                        this[a] = []
                }
                if (from >= to) {
                this.fromIndex = 0;
                        this.toIndex = 0;
                        this.fromBar = null;
                        this.toBar = null;
                        return
                }
                this.fromBar = moment(this._getOrigin(from)).utc();
                        this.fromIndex = 0;
                        t = moment(this.fromBar).utc();
                        this.times.push(t.valueOf());
                        while (t.valueOf() < to) {
                this._add(t);
                        this.times.push(t.valueOf())
                }
                this.toIndex = this.times.length;
                        this.toBar = t;
                        this.currentFrom = from;
                        this.currentTo = to;
                        this.xes = (function() {
                        var _j, _len1, _ref1, _results;
                                _ref1 = this.times;
                                _results = [];
                                for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        t = _ref1[_j];
                                _results.push(this.scene.timeToX(t))
                        }
                        return _results
                        }).call(this);
                        _ref1 = this.extraArrays;
                        _results = [];
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                arr = _ref1[_j];
                        x = [];
                        x.length = this.times.length;
                        _results.push(this[arr] = x)
                }
                return _results
                };
                Timechart_TimeSlicer.prototype.makeMiniSlice = function(time) {
                var m, t0, t1, tadd, tmul, x0, x1, _ref;
                        _ref = this.scene.timeToXCoefs(), tadd = _ref[0], tmul = _ref[1];
                        m = moment(this._getOrigin(time)).utc();
                        t0 = m.valueOf();
                        x0 = tadd + t0 * tmul;
                        this._add(m);
                        t1 = m.valueOf();
                        x1 = tadd + t1 * tmul;
                        return[t0, x0, t1, x1]
                };
                Timechart_TimeSlicer.prototype.update = function(from, to) {
                var a, arr, count, dfrom, ds, dto, l, newAfter, newBefore, offset, remove, t, tadd, tmul, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;
                        if (from == null) {
                from = this.scene.timeStart
                }
                if (to == null) {
                to = this.scene.timeEnd
                }
                from -= this.approxExtraTime;
                        to += this.approxExtraTime;
                        if (from === this.currentFrom && to === this.currentTo) {
                this.updateXes(this.fromIndex, this.toIndex);
                        return[0, this.fromIndex, this.toIndex]
                }
                if (this.fromBar === null || from > this.toBar.valueOf() || to < this.fromBar.valueOf()) {
                this.init(from, to);
                        return[0, this.toIndex, this.toIndex]
                }
                offset = 0;
                        newBefore = this.fromIndex;
                        newAfter = this.toIndex;
                        _ref = this.scene.timeToXCoefs(), tadd = _ref[0], tmul = _ref[1];
                        dfrom = this.fromBar.valueOf() - from;
                        if (dfrom > 0) {
                count = ((dfrom / this.step.approxTime()) | 0) + 2;
                        if (this.fromIndex < count) {
                a = [];
                        a.length = count + this.bufExpandSize;
                        _ref1 = this.arrays;
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                arr = _ref1[_i];
                        this[arr] = a.concat(this[arr])
                }
                offset + a.length;
                        newBefore += a.length;
                        newAfter += a.length;
                        this.fromIndex += a.length;
                        this.toIndex += a.length
                }
                t = this.fromBar.valueOf();
                        while (t > from) {
                this._sub(this.fromBar);
                        this.fromIndex -= 1;
                        t = this.fromBar.valueOf();
                        this.times[this.fromIndex] = t;
                        this.xes[this.fromIndex] = tadd + t * tmul
                }
                }
                dto = to - this.toBar.valueOf();
                        if (dto > 0) {
                count = ((dto / this.step.approxTime()) | 0) + 2;
                        if (this.times.length < this.toIndex + count) {
                l = this.toIndex + count + this.bufExpandSize;
                        _ref2 = this.arrays;
                        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                arr = _ref2[_j];
                        this[arr].length = l
                }
                }
                t = this.toBar.valueOf();
                        while (t < to) {
                this._add(this.toBar);
                        t = this.toBar.valueOf();
                        this.times[this.toIndex] = t;
                        this.xes[this.toIndex] = tadd + t * tmul;
                        this.toIndex += 1
                }
                }
                this._add(this.fromBar);
                        while (this.fromBar.valueOf() < from) {
                this.fromIndex += 1;
                        this._add(this.fromBar)
                }
                this._sub(this.fromBar);
                        this._sub(this.toBar);
                        while (this.toBar.valueOf() >= to) {
                this.toIndex -= 1;
                        this._sub(this.toBar)
                }
                this._add(this.toBar);
                        ds = this.toIndex - this.fromIndex + this.bufExpandSize;
                        if (this.fromIndex > ds) {
                remove = this.fromIndex - this.bufExpandSize;
                        _ref3 = this.arrays;
                        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
                arr = _ref3[_k];
                        this[arr].splice(0, remove)
                }
                offset -= remove;
                        newBefore -= remove;
                        newAfter -= remove;
                        this.fromIndex -= remove;
                        this.toIndex -= remove
                }
                if (this.toIndex < this.times.length - ds) {
                _ref4 = this.arrays;
                        for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
                arr = _ref4[_l];
                        this[arr].length = this.toIndex + this.bufExpandSize
                }
                }
                this.updateXes(newBefore, newAfter);
                        this.currentFrom = from;
                        this.currentTo = to;
                        return[offset, newBefore, newAfter]
                };
                Timechart_TimeSlicer.prototype.updateXes = function(newBefore, newAfter) {
                var i, tadd, tmul, _i, _ref, _ref1, _results;
                        _ref = this.scene.timeToXCoefs(), tadd = _ref[0], tmul = _ref[1];
                        if (this.oldAdd !== tadd || this.oldMul !== tmul) {
                this.oldAdd = tadd;
                        this.oldMul = tmul;
                        _results = [];
                        for (i = _i = newBefore, _ref1 = newAfter - 1; _i <= _ref1; i = _i += 1) {
                _results.push(this.xes[i] = tadd + this.times[i] * tmul)
                }
                return _results
                }
                };
                return Timechart_TimeSlicer
        })();
        var Linearchart_Renderer;
        Linearchart_Renderer = (function() {
        function Linearchart_Renderer(chart, valueAxis) {
        this.chart = chart;
                this.valueAxis = valueAxis;
                this.scene = this.chart.scene;
                this.clusters = [];
                this.buildSeries()
        }
        Linearchart_Renderer.prototype.buildSeries = function() {
        var cluster, defaultCluster, defaultStackConfig, id, idToCluster, lineStackClusters, s, series, stack, _i, _j, _len, _len1, _ref, _ref1, _results;
                this.clusters = [];
                idToCluster = {};
                defaultCluster = null;
                lineStackClusters = {};
                defaultStackConfig = Linearchart_Settings.defaults.stacks["default"];
                _ref = this.scene.settings.computedSeries;
                for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
        series = _ref[id];
                if (!series.enabled) {
        continue
        }
        if (series.cluster) {
        cluster = idToCluster[series.cluster];
                if (!cluster) {
        cluster = idToCluster[series.cluster] = new Linearchart_Series_Cluster(this.scene);
                this.clusters.push(cluster)
        }
        } else {
        if (series.type === "line") {
        if (series.stack) {
        if (lineStackClusters.hasOwnProperty(series.stack)) {
        cluster = lineStackClusters[series.stack]
        } else {
        cluster = lineStackClusters[series.stack] = new Linearchart_Series_Cluster(this.scene);
                this.clusters.push(cluster)
        }
        } else {
        cluster = new Linearchart_Series_Cluster(this.scene);
                this.clusters.push(cluster)
        }
        } else {
        if (!defaultCluster) {
        defaultCluster = new Linearchart_Series_Cluster(this.scene);
                this.clusters.push(defaultCluster)
        }
        cluster = defaultCluster
        }
        }
        stack = this.scene.settings.computedStacks[series.stack] || defaultStackConfig;
                cluster.addSeries(id, series, stack, this.valueAxis[series.valueAxis])
        }
        _ref1 = this.clusters;
                _results = [];
                for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        s = _ref1[_j];
                _results.push(s.afterInit())
        }
        return _results
        };
                Linearchart_Renderer.prototype.process = function(newData) {
                var x, _i, _len, _ref, _results;
                        _ref = this.clusters;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                x = _ref[_i];
                        _results.push(x.process(newData))
                }
                return _results
                };
                Linearchart_Renderer.prototype.afterProcess = function() {
                var x, _i, _len, _ref, _results;
                        _ref = this.clusters;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                x = _ref[_i];
                        _results.push(x.afterProcess())
                }
                return _results
                };
                Linearchart_Renderer.prototype.paint = function(event) {
                var context, o, _i, _len, _ref, _results;
                        context = event.context;
                        _ref = this.clusters;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                o = _ref[_i];
                        _results.push(o.paint(context))
                }
                return _results
                };
                Linearchart_Renderer.prototype.exportData = function(from, to) {
                var cluster, result, _i, _len, _ref;
                        result = [];
                        _ref = this.clusters;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                cluster = _ref[_i];
                        cluster.exportData(from, to, result)
                }
                return result
                };
                return Linearchart_Renderer
        })();
        var Base_LabelLayout, Piechart_PieLayout, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Piechart_PieLayout = (function() {
        function Piechart_PieLayout(chart, view) {
        this.chart = chart;
                this.view = view;
                this.scene = chart.scene;
                this.events = chart.events
        }
        Piechart_PieLayout.prototype.placeStack = function(pie, context) {
        var add, chartR, depth, endAngle, height, i, innerRadius, maxR, mul, pieChanges, pieIndex, pies, radius, radiusStep, remainingSlices, settings, startAngle, x, y, _i, _j, _len, _ref, _ref1, _ref2;
                settings = this.scene.settings;
                depth = settings.pie.depth;
                pieChanges = false;
                height = this.scene.height - depth * 2;
                height = Math.max(2, height);
                x = settings.pie.x;
                y = settings.pie.y;
                if (x === null) {
        x = this.scene.x0 + this.scene.width / 2
        } else {
        if (x >= 0 && x <= 1) {
        x = this.scene.x0 + this.scene.width * x
        }
        }
        if (y === null) {
        y = this.scene.y0 + height / 2
        } else {
        if (y >= 0 && y <= 1) {
        y = this.scene.y0 + this.scene.height * y
        }
        }
        maxR = Math.min(height / 2, this.scene.width / 2);
                maxR -= settings.pie.outerMargin;
                radius = settings.pie.radius;
                if (!radius) {
        if (settings.labels.enabled && settings.pie.adaptiveRadius) {
        chartR = this.computeDesiredRadiusFromLabels(pie, context);
                chartR = Math.min(maxR, chartR);
                chartR -= settings.labels.connectorLength;
                chartR = Math.max(chartR, maxR / 3);
                radius = chartR
        } else {
        radius = maxR
        }
        } else {
        if (radius <= 1) {
        radius = maxR * radius
        }
        }
        innerRadius = settings.pie.innerRadius;
                if (innerRadius < 1) {
        innerRadius = radius * innerRadius
        }
        startAngle = settings.pie.startAngle;
                endAngle = settings.pie.endAngle;
                mul = 1 / (radius - innerRadius);
                add = - innerRadius * mul;
                if (pie.x !== x || pie.y !== y || this.scene.radius !== radius || this.scene.innerRadius !== innerRadius || startAngle !== pie.startAngle || endAngle !== pie.endAngle) {
        pieChanges = true
        }
        this.scene.radius = radius;
                this.scene.innerRadius = innerRadius;
                pie.x = x;
                pie.y = y;
                pie.radius = 1;
                pie.innerRadius = innerRadius * mul + add;
                pie.startAngle = startAngle;
                pie.endAngle = endAngle;
                pies = this.scene.stack;
                pieIndex = pies.length - 1;
                if (pieIndex > 0) {
        innerRadius = innerRadius - settings.pie.margin;
                remainingSlices = pieIndex;
                radiusStep = Math.max(0, Math.min(radius - innerRadius, (innerRadius - settings.pie.centerMargin) / remainingSlices));
                for (i = _i = _ref = pieIndex - 1; _i >= 0; i = _i += - 1) {
        radius = innerRadius;
                innerRadius -= radiusStep;
                pie = pies[i];
                y += depth;
                pie.x = x;
                pie.y = y;
                pie.radius = radius * mul + add;
                pie.innerRadius = (innerRadius + settings.pie.margin) * mul + add;
                pie.brightness = 0.8 - 0.8 * (remainingSlices - i - 1) / remainingSlices;
                pie.startAngle = settings.pie.startAngle;
                pie.endAngle = settings.pie.endAngle
        }
        }
        _ref1 = this.scene.pies;
                for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        pie = _ref1[_j];
                if (pie.removed && pie.parentSlice) {
        _ref2 = this.scene.getSliceTargetAngles(pie.parentSlice), pie.startAngle = _ref2[0], pie.endAngle = _ref2[1]
        }
        }
        return pieChanges
        };
                Piechart_PieLayout.prototype.computeDesiredRadiusFromLabels = function(pie, g) {
                var a, a0, a1, am, astart, availableArea, chartArea, da, effectiveHeight, endAngle, fsum, l, labelHeight, labelLayout, leftLabelArea, leftLongestWord, longestWord, lw, radiusByArea, radiusByLongestWord, rightLabelArea, rightLongestWord, slice, sliceAngle0, sliceAngle1, startAngle, w, x, _i, _j, _len, _len1, _ref, _ref1;
                        labelLayout = new Base_LabelLayout(g, 1, 0, 100, 0, 100, this.scene.settings.labels);
                        labelHeight = labelLayout.lineHeightC + labelLayout.lineHeightM;
                        leftLongestWord = 0;
                        rightLongestWord = 0;
                        leftLabelArea = 0;
                        rightLabelArea = 0;
                        fsum = 0;
                        startAngle = pie.currentStartAngle;
                        endAngle = pie.currentEndAngle;
                        da = endAngle - startAngle;
                        astart = pie.currentStartAngle + pie.scrollOffset * da;
                        sliceAngle1 = astart;
                        _ref = pie.slices;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                slice = _ref[_i];
                        sliceAngle0 = sliceAngle1;
                        fsum = Math.min(1, fsum + slice.currentFraction);
                        sliceAngle1 = astart + fsum * da;
                        a0 = Math.max(sliceAngle0, startAngle);
                        a1 = Math.min(sliceAngle1, endAngle);
                        if (a0 >= endAngle || a1 <= startAngle) {
                continue
                }
                am = (a0 + a1) / 2;
                        if (slice.label) {
                longestWord = "";
                        _ref1 = slice.label.split(" ");
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                w = _ref1[_j];
                        if (w.length > longestWord.length) {
                longestWord = w
                }
                }
                l = g.measureText(longestWord).width;
                        w = g.measureText(slice.label).width;
                        a = labelHeight * w * 1.2;
                        x = Math.cos(am);
                        if (x > 0) {
                rightLabelArea += a;
                        rightLongestWord = Math.max(rightLongestWord, l)
                } else {
                leftLabelArea += a;
                        leftLongestWord = Math.max(leftLongestWord, l)
                }
                }
                }
                effectiveHeight = Math.min(this.scene.width, this.scene.height);
                        availableArea = this.scene.width * effectiveHeight;
                        chartArea = Math.max(1, availableArea - 2 * Math.max(leftLabelArea, rightLabelArea) * 1.2);
                        radiusByArea = Math.sqrt(chartArea / Math.PI);
                        lw = Math.max(leftLongestWord, rightLongestWord);
                        radiusByLongestWord = this.scene.width / 2 - lw * 1.1;
                        return Math.min(radiusByArea, radiusByLongestWord)
                };
                Piechart_PieLayout.prototype.placeLabels = function(pie, g) {
                var a0, a1, add, am, astart, bottom, config, da, endAngle, fsum, icon, iconMinSize, iconSize, insideLablelProp, label, labelLayout, labelsEnabled, left, leftOutsideLabels, margin, mul, pr0, pr1, r0, r1, right, rightOutsideLabels, slice, sliceAngle0, sliceAngle1, startAngle, text, top, x, y, _i, _len, _ref, _ref1;
                        config = this.scene.settings.labels;
                        labelsEnabled = config.enabled;
                        iconMinSize = this.scene.settings.advanced.iconMinSize;
                        margin = this.scene.settings.slice.margin;
                        x = pie.x;
                        y = pie.y;
                        add = this.scene.currentInnerRadius;
                        mul = this.scene.currentRadius - add;
                        pr0 = pie.currentInnerRadius * mul + add;
                        pr1 = pie.currentRadius * mul + add;
                        fsum = 0;
                        startAngle = pie.currentStartAngle;
                        endAngle = pie.currentEndAngle;
                        da = endAngle - startAngle;
                        astart = pie.currentStartAngle + pie.scrollOffset * da;
                        left = this.scene.x0 - x;
                        right = left + this.scene.width;
                        top = this.scene.y0 - y;
                        bottom = top + this.scene.height;
                        labelLayout = new Base_LabelLayout(g, pr1, left, right, top, bottom, config);
                        leftOutsideLabels = [];
                        rightOutsideLabels = [];
                        sliceAngle1 = astart;
                        _ref = pie.allSlices;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                slice = _ref[_i];
                        sliceAngle0 = sliceAngle1;
                        fsum = Math.min(1, fsum + slice.currentFraction);
                        sliceAngle1 = astart + fsum * da;
                        a0 = Math.max(sliceAngle0, startAngle);
                        a1 = Math.min(sliceAngle1, endAngle);
                        r0 = pr0 + slice.currentCutoutDistance;
                        r1 = pr1 + slice.currentCutoutDistance;
                        if (a0 >= endAngle || a1 <= startAngle) {
                slice.currentLabel = null;
                        slice.currentInsideLabel = null;
                        slice.currentIcon = null;
                        continue
                }
                am = (a0 + a1) / 2;
                        if (!slice.removed && !pie.background) {
                if (slice.insideLabel && labelsEnabled) {
                text = slice.insideLabel;
                        if (!slice.currentInsideLabel) {
                label = slice.currentInsideLabel = new Base_Label()
                } else {
                label = slice.currentInsideLabel
                }
                if (slice.currentInsideLabel.text !== text) {
                label.text = text;
                        label.words = text.split(" ");
                        label.align = "center"
                }
                insideLablelProp = labelLayout.fitLabelInSlice(label, r0, r1, a0, a1);
                        label.shouldBeVisible = config.insideLabel === "always" || insideLablelProp >= config.insideLabelVisibilityFraction;
                        if (!label.shouldBeVisible && slice !== this.scene.hoverSlice && !label.userPlaced) {
                label.visible = false
                }
                }
                text = slice.label && labelsEnabled ? slice.label : "";
                        if (config.insideLabel === "append" && slice.insideLabel && labelsEnabled && !slice.currentInsideLabel.userPlaced && !slice.currentInsideLabel.shouldBeVisible) {
                if (text) {
                x = Math.cos(am);
                        if (x > 0) {
                text = slice.insideLabel + ", " + text
                } else {
                text = text + ", " + slice.insideLabel
                }
                } else {
                text = slice.insideLabel
                }
                }
                if (text) {
                label = null;
                        if (!slice.currentLabel) {
                label = slice.currentLabel = new Base_Label()
                } else {
                label = slice.currentLabel
                }
                if (slice.currentLabel.text !== text) {
                label.text = text;
                        label.words = text.split(" ")
                }
                if (!label.userPlaced) {
                labelLayout.placeOutsideLabelInitial(label, am)
                }
                if (label.x > 0) {
                label.align = "left";
                        rightOutsideLabels.push(label)
                } else {
                label.align = "right";
                        leftOutsideLabels.push(label)
                }
                } else {
                slice.currentLabel = null
                }
                } else {
                slice.currentLabel = null;
                        slice.currentInsideLabel = null
                }
                icon = null;
                        if (slice.icon && (!pie.background || slice.id === pie.activeSliceId)) {
                _ref1 = labelLayout.fitBoxInSlice(1, 1, r0, r1, a0, a1), x = _ref1[0], y = _ref1[1], iconSize = _ref1[2];
                        iconSize -= margin;
                        if (iconSize * 2 >= iconMinSize) {
                icon = new Piechart_Icon();
                        icon.x = x;
                        icon.y = y;
                        icon.hwidth = iconSize;
                        icon.hheight = iconSize;
                        icon.inside = true
                } else {
                }
                }
                slice.currentIcon = icon
                }
                return labelLayout.computeOutsideLabelLocations(leftOutsideLabels, rightOutsideLabels)
                };
                return Piechart_PieLayout
        })();
        Base_LabelLayout = (function(_super) {
        __extends(Base_LabelLayout, _super);
                function Base_LabelLayout(g, r1, left, right, top, bottom, config) {
                this.left = left;
                        this.right = right;
                        this.top = top;
                        this.bottom = bottom;
                        Base_LabelLayout.__super__.constructor.call(this, g, config);
                        this.rr = r1 + this.connectorLength
                }
        Base_LabelLayout.prototype.placeOutsideLabelInitial = function(label, angle) {
        var shortenProp, x, y;
                x = this.rr * Math.cos(angle);
                y = this.rr * Math.sin(angle);
                shortenProp = 1;
                if (y < this.top) {
        shortenProp = Math.min(shortenProp, this.top / y)
        }
        if (y > this.bottom) {
        shortenProp = Math.min(shortenProp, this.bottom / y)
        }
        if (x < this.left) {
        shortenProp = Math.min(shortenProp, this.left / x)
        }
        if (x > this.right) {
        shortenProp = Math.min(shortenProp, this.right / x)
        }
        label.x = x * shortenProp;
                return label.y = y * shortenProp
        };
                Base_LabelLayout.prototype.computeOutsideLabelLocations = function(leftLabels, rightLabels) {
                var alignVariants, aligned, bottom, h, hasMultiline, height, label, labelBottom, labelSpacing, labelTop, labels, maxHeight, prop, top, visibleLabels, worstProp, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _results;
                        bottom = this.bottom - this.margin;
                        top = this.top + this.margin;
                        labelSpacing = this.interLabelSpacing;
                        leftLabels.sort(function(a, b) {
                        return b.y - a.y
                        });
                        rightLabels.sort(function(a, b) {
                        return a.y - b.y
                        });
                        for (_i = 0, _len = leftLabels.length; _i < _len; _i++) {
                label = leftLabels[_i];
                        label.originX = label.x
                }
                for (_j = 0, _len1 = rightLabels.length; _j < _len1; _j++) {
                label = rightLabels[_j];
                        label.originX = label.x
                }
                alignVariants = this.config.placement === "wrap" ? [false] : [true, false];
                        _results = [];
                        for (_k = 0, _len2 = alignVariants.length; _k < _len2; _k++) {
                aligned = alignVariants[_k];
                        worstProp = 100;
                        hasMultiline = false;
                        _ref = [leftLabels, rightLabels];
                        for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
                labels = _ref[_l];
                        for (_m = 0, _len4 = labels.length; _m < _len4; _m++) {
                label = labels[_m];
                        label.prop = this.fitLabelOutside(label, aligned)
                }
                maxHeight = bottom - top;
                        visibleLabels = [];
                        height = 0;
                        for (_n = 0, _len5 = labels.length; _n < _len5; _n++) {
                label = labels[_n];
                        if (label.visible) {
                h = label.hheight * 2 + labelSpacing;
                        if (height + h < maxHeight) {
                visibleLabels.push(label);
                        height += h
                } else {
                label.visible = label.userPlaced
                }
                }
                }
                labelBottom = bottom;
                        labelTop = top;
                        if (labels === leftLabels) {
                labelTop += height
                } else {
                labelBottom -= height
                }
                for (_o = 0, _len6 = visibleLabels.length; _o < _len6; _o++) {
                label = visibleLabels[_o];
                        if (labels === leftLabels) {
                labelTop -= label.hheight * 2 + labelSpacing
                } else {
                labelBottom += label.hheight * 2 + labelSpacing
                }
                if (!label.userPlaced && (label.y + label.hheight > labelBottom || label.y - label.hheight < labelTop)) {
                label.y = Math.min(Math.max(label.y, labelTop + label.hheight), labelBottom - label.hheight);
                        prop = this.fitLabelOutside(label, aligned);
                        worstProp = Math.min(prop, worstProp);
                        hasMultiline || (hasMultiline = label.lines && label.lines.length > 1)
                } else {
                worstProp = Math.min(worstProp, label.prop)
                }
                if (labels === leftLabels) {
                labelBottom = label.y - label.hheight - labelSpacing
                } else {
                labelTop = label.y + label.hheight + labelSpacing
                }
                }
                }
                if (worstProp >= 1 || !hasMultiline) {
                break
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                Base_LabelLayout.prototype.fitLabelOutside = function(label, aligned) {
                var locationFunc;
                        if (aligned == null) {
                aligned = false
                }
                locationFunc = (function(_this) {
                return function(hheight) {
                if (label.userPlaced) {
                return _this.getOutsideMaxWidth(label.x, label.y, hheight, false)
                } else {
                return _this.placeOutsideMaxWidth(label.originX, label.y, hheight, aligned)
                }
                }
                })(this);
                        return this.fitLabelInRect(label, label.align, locationFunc)
                };
                Base_LabelLayout.prototype.fitLabelInSlice = function(label, r0, r1, a0, a1) {
                var sliceLocationFunc;
                        sliceLocationFunc = (function(_this) {
                        return function(hheight) {
                        var width, xx, yy, _ref, _ref1;
                                if (label.userPlaced) {
                        _ref = _this.getInsideMaxWidth(label.x, label.y, hheight, r0, r1, a0, a1, true), xx = _ref[0], yy = _ref[1], width = _ref[2];
                                return[label.x, label.y, 1, 0, width]
                        } else {
                        _ref1 = _this.placeInsideMaxWidth(hheight, r0, r1, a0, a1), xx = _ref1[0], yy = _ref1[1], width = _ref1[2];
                                return[xx, yy, 1, 0, width]
                        }
                        }
                        })(this);
                        return this.fitLabelInRect(label, "center", sliceLocationFunc)
                };
                Base_LabelLayout.prototype.placeOutsideMaxWidth = function(x, y, hheight, aligned) {
                var diff, distanceFromCenter, lbottom, lleft, lright, ltop, radius;
                        radius = this.rr;
                        ltop = y - hheight / 2;
                        lbottom = ltop + hheight;
                        if (ltop < this.top) {
                diff = this.top - ltop;
                        ltop += diff;
                        lbottom += diff
                }
                if (lbottom > this.bottom) {
                diff = this.bottom - lbottom;
                        ltop += diff;
                        lbottom += diff
                }
                lleft = this.left;
                        lright = this.right;
                        if (aligned) {
                distanceFromCenter = radius
                } else {
                if (ltop > radius || lbottom < - radius) {
                distanceFromCenter = 0
                } else {
                if (ltop > 0) {
                distanceFromCenter = Math.sqrt(radius * radius - ltop * ltop)
                } else {
                if (lbottom < 0) {
                distanceFromCenter = Math.sqrt(radius * radius - lbottom * lbottom)
                } else {
                distanceFromCenter = radius
                }
                }
                }
                }
                if (x > 0) {
                lleft = Math.max(distanceFromCenter, x)
                } else {
                lright = Math.min(x, - distanceFromCenter)
                }
                return[(lleft + lright) / 2, (ltop + lbottom) / 2, 1, 0, lright - lleft]
                };
                Base_LabelLayout.prototype.getOutsideMaxWidth = function(x, y, hheight, aligned) {
                var dist, distanceFromCenter, lbottom, lleft, lright, ltop, radius;
                        ltop = y - hheight / 2;
                        lbottom = ltop + hheight;
                        lleft = this.left;
                        lright = this.right;
                        radius = this.rr;
                        if (aligned) {
                distanceFromCenter = radius
                } else {
                if (ltop > radius || lbottom < - radius) {
                distanceFromCenter = 0
                } else {
                if (ltop > 0) {
                distanceFromCenter = Math.sqrt(radius * radius - ltop * ltop)
                } else {
                if (lbottom < 0) {
                distanceFromCenter = Math.sqrt(radius * radius - lbottom * lbottom)
                } else {
                distanceFromCenter = radius
                }
                }
                }
                }
                if (x > 0) {
                lleft = distanceFromCenter
                } else {
                lright = - distanceFromCenter
                }
                dist = Math.min(Math.abs(x - lleft), Math.abs(x - lright));
                        return[x, y, 1, 0, dist * 2]
                };
                Base_LabelLayout.prototype.placeInsideMaxWidth = function(hheight, r0, r1, a0, a1) {
                var am, cosa, rm, rprop, sina, x, y;
                        rprop = 0.5 + (r1 - r0) / r1 / 4;
                        rm = r0 + (r1 - r0) * rprop;
                        am = (a0 + a1) / 2;
                        cosa = Math.cos(am);
                        sina = Math.sin(am);
                        x = rm * cosa;
                        y = rm * sina;
                        return this.getInsideMaxWidth(x, y, hheight, r0, r1, a0, a1, false)
                };
                Base_LabelLayout.prototype.getInsideMaxWidth = function(x, y, hheight, r0, r1, a0, a1, userPlaced) {
                var down, l, l0, l1, r, up, width;
                        down = this.rayIntersectsSlice(x, y, 0, 1, r0, r1, a0, a1);
                        up = this.rayIntersectsSlice(x, y, 0, - 1, r0, r1, a0, a1);
                        if (down < hheight || up < hheight) {
                return[x, y, 1, 0, 0.00001]
                }
                l0 = this.rayIntersectsSlice(x, y - hheight, - 1, 0, r0, r1, a0, a1);
                        l1 = this.rayIntersectsSlice(x, y + hheight, - 1, 0, r0, r1, a0, a1);
                        r0 = this.rayIntersectsSlice(x, y - hheight, 1, 0, r0, r1, a0, a1);
                        r1 = this.rayIntersectsSlice(x, y + hheight, 1, 0, r0, r1, a0, a1);
                        l = Math.min(l0, l1);
                        r = Math.min(r0, r1);
                        if (userPlaced) {
                width = Math.min(l, r) * 2
                } else {
                width = l + r;
                        x = x - l + width / 2
                }
                return[x, y, width]
                };
                Base_LabelLayout.prototype.fitBoxInSlice = function(hwidth, hheight, r0, r1, a0, a1) {
                var am, cosa, d0, d1, d2, d3, dx, dy, prop, rm, rprop, sina, x, y;
                        rprop = 0.5 + (r1 - r0) / r1 / 4;
                        rm = r0 + (r1 - r0) * rprop;
                        am = (a0 + a1) / 2;
                        cosa = Math.cos(am);
                        sina = Math.sin(am);
                        x = rm * cosa;
                        y = rm * sina;
                        dx = hwidth;
                        dy = hheight;
                        d0 = this.rayIntersectsSlice(x, y, dx, dy, r0, r1, a0, a1);
                        d1 = this.rayIntersectsSlice(x, y, - dx, dy, r0, r1, a0, a1);
                        d2 = this.rayIntersectsSlice(x, y, - dx, - dy, r0, r1, a0, a1);
                        d3 = this.rayIntersectsSlice(x, y, dx, - dy, r0, r1, a0, a1);
                        prop = Math.min(d0, d1, d2, d3);
                        return[x, y, prop]
                };
                Base_LabelLayout.prototype.rayIntersectsSlice = function(x0, y0, dx, dy, r0, r1, a0, a1) {
                var cosa, d, sina;
                        d = Base_Geometry.rayIntersectsCircle(x0, y0, dx, dy, r0);
                        d = Math.min(d, Base_Geometry.rayIntersectsCircle(x0, y0, dx, dy, r1));
                        cosa = Math.cos(a0);
                        sina = Math.sin(a0);
                        d = Math.min(d, Base_Geometry.rayIntersectsLine(x0, y0, dx, dy, r0 * cosa, r0 * sina, r1 * cosa, r1 * sina));
                        cosa = Math.cos(a1);
                        sina = Math.sin(a1);
                        d = Math.min(d, Base_Geometry.rayIntersectsLine(x0, y0, dx, dy, r0 * cosa, r0 * sina, r1 * cosa, r1 * sina));
                        return d
                };
                return Base_LabelLayout
        })(Base_LabelLayoutBase);
        var Piechart_PieRenderer;
        Piechart_PieRenderer = (function() {
        function Piechart_PieRenderer(chart) {
        this.chart = chart;
                this.settings = chart.settings;
                this.scene = chart.scene;
                this.events = chart.events
        }
        Piechart_PieRenderer.prototype.onSceneChange = function(event) {
        if (event.changes.settings) {
        return this.buildSeries()
        }
        };
                Piechart_PieRenderer.prototype.buildSeries = function() {
                var c, e, theme;
                        theme = this.settings.pie.theme;
                        c = "PieChart_Renderer_" + theme.charAt(0).toUpperCase() + theme.slice(1);
                        try {
                        return eval("this.renderer = new " + c + "(this);")
                        } catch (_error) {
                e = _error;
                        throw"Renderer " + theme + " is not available: " + e
                }
                };
                Piechart_PieRenderer.prototype.paintScene = function(event) {
                var g, innerPies, pie, pieindex, _i, _len, _ref;
                        g = event.context;
                        innerPies = event["export"] ? this.settings.pie.showInnerPiesExport : this.settings.pie.showInnerPies;
                        _ref = this.scene.pies;
                        for (pieindex = _i = 0, _len = _ref.length; _i < _len; pieindex = ++_i) {
                pie = _ref[pieindex];
                        if (innerPies || !pie.background) {
                this.paintPie(g, pie)
                }
                }
                if (Base_Helpers.arrayContains(this.scene.pies, this.scene.hoverPie)) {
                this.paintBackArrow(event)
                }
                };
                Piechart_PieRenderer.prototype.paintBackArrow = function(event) {
                var depth, g, heightProportion, ihh, ihw, img, invsq2, phs, topPie, widthProportion, x, y, zoom;
                        if (!(!event["export"] && this.scene.pies.length > 1)) {
                return
                }
                img = this.scene.settings.getAssetImage(this.scene.settings.advanced.backImage);
                        if (!(img && img.width)) {
                return
                }
                topPie = this.scene.pies[this.scene.pies.length - 1];
                        invsq2 = 0.707106781186547;
                        x = topPie.x;
                        y = topPie.y;
                        depth = this.settings.pie.depth;
                        y += (this.scene.pies.length - 1) * depth;
                        ihw = img.width / 2;
                        ihh = img.height / 2;
                        phs = topPie.innerRadius * invsq2;
                        widthProportion = Math.min(ihw, Math.max(phs, ihw / 2)) / ihw;
                        heightProportion = Math.min(ihh, Math.max(phs, ihh / 2)) / ihh;
                        zoom = Math.min(widthProportion, heightProportion);
                        g = event.context;
                        g.globalAlpha = 0.5;
                        g.drawImage(img, x - ihw * zoom, y - ihh * zoom, ihw * 2 * zoom, ihh * 2 * zoom);
                        return g.globalAlpha = 1
                };
                Piechart_PieRenderer.prototype.paintPie = function(g, pie) {
                var a0, a1, aR1, add, am, angle, angle1, angleDiff, end, h, icon, img, innerAngleLeft, innerAngleRight, isActive, m, mul, outerAngleLeft, outerAngleRight, pxToAngleR0, pxToAngleR1, r0, r1, rl, slice, sliceAngle, slicesToPaint, spacing, spacingAngleR0, spacingAngleR1, sr0, sr1, start, w, x, xx, y, yy, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _results;
                        spacing = this.settings.slice.margin;
                        x = pie.x;
                        y = pie.y;
                        add = this.scene.currentInnerRadius;
                        mul = this.scene.currentRadius - add;
                        r0 = Math.max(pie.currentInnerRadius * mul + add, spacing / 2);
                        r1 = pie.currentRadius * mul + add;
                        start = pie.currentStartAngle;
                        end = pie.currentEndAngle;
                        angleDiff = end - start;
                        angle1 = start + pie.scrollOffset * angleDiff;
                        if (!(r1 > 0 && angleDiff > 0)) {
                return
                }
                pxToAngleR0 = r0 > 0 ? 1 / r0 : 0;
                        pxToAngleR1 = 1 / r1;
                        spacingAngleR0 = spacing / 2 * pxToAngleR0;
                        spacingAngleR1 = spacing / 2 * pxToAngleR1;
                        slicesToPaint = [];
                        _ref = pie.allSlices;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                slice = _ref[_i];
                        sliceAngle = slice.currentFraction * angleDiff;
                        if (!(sliceAngle > 0)) {
                continue
                }
                angle = angle1;
                        angle1 += sliceAngle;
                        sr0 = r0 + slice.currentCutoutDistance;
                        sr1 = r1 + slice.currentCutoutDistance;
                        if (sliceAngle <= spacingAngleR1 * 4) {
                m = (angle + angle1) / 2;
                        aR1 = sliceAngle / 4;
                        outerAngleLeft = m - aR1;
                        outerAngleRight = m + aR1
                } else {
                outerAngleLeft = angle + spacingAngleR1;
                        outerAngleRight = angle1 - spacingAngleR1
                }
                innerAngleLeft = angle + spacingAngleR0;
                        innerAngleRight = angle1 - spacingAngleR0;
                        if (innerAngleLeft > innerAngleRight) {
                innerAngleLeft = innerAngleRight = (innerAngleLeft + innerAngleRight) / 2
                }
                if (outerAngleRight < start || outerAngleLeft > end) {
                continue
                }
                outerAngleLeft = Math.max(outerAngleLeft, start);
                        outerAngleRight = Math.min(outerAngleRight, end);
                        innerAngleLeft = Math.max(innerAngleLeft, start);
                        innerAngleRight = Math.min(innerAngleRight, end);
                        if (innerAngleLeft > innerAngleRight) {
                innerAngleLeft = innerAngleRight = (innerAngleLeft + innerAngleRight) / 2
                }
                slice.renderParams = [sr0, sr1, outerAngleLeft, outerAngleRight, innerAngleLeft, innerAngleRight];
                        slice.fillColor_b = slice.fillColor;
                        slice.lineColor_b = slice.lineColor;
                        slice.fillColor = slice.currentFillColor;
                        slice.lineColor = slice.currentLineColor;
                        slicesToPaint.push(slice)
                }
                x = pie.x;
                        y = pie.y;
                        this.renderer.paintPie(g, x, y, r0, r1, pie.currentStartAngle, pie.currentEndAngle, pie);
                        this.renderer.paintSlices(g, x, y, slicesToPaint);
                        if (pie === this.scene.peek()) {
                this.renderer.paintExpandableHilights(g, x, y, slicesToPaint)
                }
                for (_j = 0, _len1 = slicesToPaint.length; _j < _len1; _j++) {
                slice = slicesToPaint[_j];
                        slice.fillColor = slice.fillColor_b;
                        slice.lineColor = slice.lineColor_b
                }
                if (!pie.removed) {
                Base_Graphics.clearShadow(g);
                        _ref1 = pie.allSlices;
                        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                slice = _ref1[_k];
                        if (slice.currentIcon) {
                img = this.scene.settings.getAssetImage(slice.icon);
                        if (img) {
                icon = slice.currentIcon;
                        xx = x + icon.x;
                        yy = y + icon.y;
                        w = Math.min(img.width / 2, icon.hwidth);
                        h = Math.min(img.height / 2, icon.hheight);
                        g.drawImage(img, xx - w, yy - h, w * 2, h * 2)
                }
                }
                }
                angle1 = start + pie.scrollOffset * angleDiff;
                        _ref2 = pie.allSlices;
                        _results = [];
                        for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
                slice = _ref2[_l];
                        sliceAngle = slice.currentFraction * angleDiff;
                        angle = angle1;
                        angle1 = angle + sliceAngle;
                        a0 = Math.max(angle, start);
                        a1 = Math.min(angle1, end);
                        am = (a0 + a1) / 2;
                        isActive = slice === this.scene.hoverSlice;
                        rl = r1 + slice.currentCutoutDistance;
                        if (slice.currentInsideLabel && slice.currentInsideLabel.visible) {
                this.paintLabel(g, x, y, rl, am, slice.currentInsideLabel, this.settings.labels.insideTextStyle, null, isActive)
                }
                if (slice.currentLabel && slice.currentLabel.visible) {
                _results.push(this.paintLabel(g, x, y, rl, am, slice.currentLabel, this.settings.labels.textStyle, this.settings.labels.backgroundStyle, isActive))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                }
                };
                Piechart_PieRenderer.prototype.paintLabel = function(g, x, y, r1, angleM, label, style, bgStyle, active) {
                var a, bottom, cosa, da, hh, labelConfig, r15, r2, sina, t, top, touchAngle, width, ww, x0, x1, x1a, x2, xc, xx, y0, y1, y1a, y2, yc, yy;
                        top = this.scene.y0;
                        bottom = top + this.scene.height;
                        labelConfig = this.settings.labels;
                        xx = label.x;
                        yy = label.y;
                        ww = label.hwidth;
                        hh = label.hheight;
                        r2 = r1 + labelConfig.connectorLength;
                        if (labelConfig.connectors && xx * xx + yy * yy > r1 * r1) {
                sina = Math.sin(angleM);
                        cosa = Math.cos(angleM);
                        g.beginPath();
                        x0 = x + r1 * cosa;
                        y0 = y + r1 * sina;
                        g.moveTo(x0, y0);
                        x1 = x + r2 * cosa;
                        y1 = y + r2 * sina;
                        y1 = Math.min(Math.max(y1, top), bottom);
                        if (xx + ww < 0) {
                x2 = x + xx + ww;
                        y2 = y + yy
                } else {
                if (xx + ww >= 0) {
                x2 = x + xx - ww;
                        y2 = y + yy
                } else {
                x2 = x + xx;
                        if (yy > 0) {
                y2 = y + yy - hh
                } else {
                y2 = y + yy + hh
                }
                }
                }
                r15 = (r1 + r2) / 2;
                        t = Base_Geometry.rayIntersectsCircle(x2 - x, y2 - y, x0 - x2, y0 - y2, r1);
                        a = Base_Geometry.lineTouchingCircle(x2 - x, y2 - y, x1 - x, y1 - y, r2);
                        if (t < 0.9 && a) {
                xc = a[0], yc = a[1];
                        touchAngle = Math.atan2(yc, xc);
                        while (touchAngle - angleM > Math.PI) {
                touchAngle -= Math.PI * 2
                }
                while (touchAngle - angleM < - Math.PI) {
                touchAngle += Math.PI * 2
                }
                da = touchAngle - angleM;
                        xc += x;
                        yc += y;
                        x1 = x + r15 * cosa;
                        y1 = y + r15 * sina;
                        y1 = Math.min(Math.max(y1, top), bottom);
                        x1a = x + r15 * Math.cos(angleM + da * 0.2);
                        y1a = y + r15 * Math.sin(angleM + da * 0.2);
                        y1a = Math.min(Math.max(y1a, top), bottom);
                        g.quadraticCurveTo(x1, y1, x1a, y1a);
                        Base_Graphics.arcBetweenTwoPoints(g, x, y, r15, x1a, y1a, x + r2 * Math.cos(touchAngle), y + r2 * Math.sin(touchAngle));
                        g.lineTo(x2, y2)
                } else {
                g.quadraticCurveTo(x1, y1, x2, y2)
                }
                width = labelConfig.connectorStyle.lineWidth;
                        if (active) {
                labelConfig.connectorStyle.lineWidth += 2
                }
                Base_Graphics.stroke(g, labelConfig.connectorStyle);
                        labelConfig.connectorStyle.lineWidth = width
                }
                label.paint(g, x, y, style, bgStyle);
                        return Base_Graphics.clearShadow(g)
                };
                return Piechart_PieRenderer
        })();
        var Piechart_PieBuilder;
        Piechart_PieBuilder = (function() {
        function Piechart_PieBuilder(chart) {
        this.chart = chart;
                this.scene = chart.scene;
                this.loading = false
        }
        Piechart_PieBuilder.prototype.updatePie = function(pie) {
        var data, newSlices, numberOfSlices, others, previous, ready, _ref, _ref1;
                data = this.getPieData(pie);
                _ref = this.getForwardCount(pie.id, data, pie.offset), numberOfSlices = _ref[0], ready = _ref[1];
                pie.data = data;
                pie.loading = !ready;
                if (ready) {
        _ref1 = this.buildSlices(pie, pie.offset, numberOfSlices), newSlices = _ref1[0], others = _ref1[1], previous = _ref1[2];
                this.applyNewSlices(pie, newSlices, others, previous)
        }
        return ready
        };
                Piechart_PieBuilder.prototype.scrollForward = function(pie, newOffset) {
                var data, newOthers, newPrevious, newSlices, numberOfSlices, ready, _ref, _ref1, _ref2;
                        data = this.getPieData(pie);
                        pie.data = data;
                        ready = true;
                        if (newOffset == null) {
                _ref = this.getForwardCount(pie.id, data, pie.offset), numberOfSlices = _ref[0], ready = _ref[1];
                        newOffset = pie.offset + numberOfSlices
                }
                if (ready) {
                _ref1 = this.getForwardCount(pie.id, data, newOffset), numberOfSlices = _ref1[0], ready = _ref1[1]
                }
                if (!ready) {
                pie.loading = true;
                        return false
                } else {
                _ref2 = this.buildSlices(pie, newOffset, numberOfSlices), newSlices = _ref2[0], newOthers = _ref2[1], newPrevious = _ref2[2];
                        if (pie.othersSlice) {
                this.fitSlicesInOrigin(pie.othersSlice, newSlices, newOthers);
                        if (!newOthers) {
                newOthers = pie.othersSlice;
                        newOthers.fraction = 0;
                        newOthers.currentFraction = 0;
                        newOthers.removed = true
                }
                }
                pie.offset = newOffset;
                        this.applyNewSlices(pie, newSlices, newOthers, newPrevious);
                        pie.loading = false;
                        return true
                }
                };
                Piechart_PieBuilder.prototype.scrollBackward = function(pie, newOffset) {
                var data, newOthers, newPrevious, newSlices, numberOfSlices, ready, _ref, _ref1, _ref2;
                        data = this.getPieData(pie);
                        pie.data = data;
                        ready = true;
                        if (newOffset == null) {
                _ref = this.getBackOffset(pie.id, data, pie.offset), newOffset = _ref[0], ready = _ref[1]
                }
                if (ready) {
                _ref1 = this.getForwardCount(pie.id, data, newOffset), numberOfSlices = _ref1[0], ready = _ref1[1]
                }
                if (!ready) {
                pie.loading = true;
                        return false
                } else {
                _ref2 = this.buildSlices(pie, newOffset, numberOfSlices), newSlices = _ref2[0], newOthers = _ref2[1], newPrevious = _ref2[2];
                        if (pie.previousSlice) {
                this.fitSlicesInOrigin(pie.previousSlice, newSlices, newPrevious);
                        if (!newPrevious) {
                newPrevious = pie.previousSlice;
                        newPrevious.fraction = 0;
                        newPrevious.currentFraction = 0;
                        newPrevious.removed = true
                }
                }
                pie.offset = newOffset;
                        this.applyNewSlices(pie, newSlices, newOthers, newPrevious);
                        pie.loading = false;
                        return true
                }
                };
                Piechart_PieBuilder.prototype.fitSlicesInOrigin = function(origin, slices, extraSlice) {
                var compression, originFraction, slice, targetFraction, _i, _j, _len, _len1;
                        originFraction = Math.max(0.000001, origin.currentFraction);
                        targetFraction = 0;
                        for (_i = 0, _len = slices.length; _i < _len; _i++) {
                slice = slices[_i];
                        targetFraction += slice.fraction
                }
                if (extraSlice) {
                targetFraction += extraSlice.fraction
                }
                compression = originFraction / targetFraction;
                        for (_j = 0, _len1 = slices.length; _j < _len1; _j++) {
                slice = slices[_j];
                        slice.currentFraction = slice.fraction * compression;
                        slice.currentFillColor = origin.currentFillColor;
                        slice.currentLineColor = origin.currentLineColor
                }
                if (extraSlice) {
                extraSlice.currentFraction = extraSlice.fraction * compression;
                        extraSlice.currentFillColor = origin.currentFillColor;
                        extraSlice.currentLineColor = origin.currentLineColor
                }
                };
                Piechart_PieBuilder.prototype.getForwardCount = function(id, data, offset) {
                var count, dataEnd, dataStart, full, i, maxOthers, maxSlices, minSlice, othersRealFraction, othersS, othersSum, othersVisibleFraction, sliceFraction, slicesSum, val, _i, _ref;
                        if (!data || (data.offset > offset) || (data.offset + data.values.length <= offset)) {
                if (!data || !data.done || data.offset > offset) {
                this.scene.data.requestPieData(id, offset);
                        return[0, false]
                } else {
                return[0, true]
                }
                }
                dataStart = data.offset;
                        dataEnd = dataStart + data.values.length;
                        othersS = this.scene.settings.interaction.others;
                        if (!othersS.enabled) {
                if (!data.done) {
                this.scene.data.requestMorePieData(id)
                }
                return[Math.max(dataEnd - offset, 0), data.done]
                }
                othersSum = data.afterFraction;
                        for (i = _i = offset, _ref = dataEnd - 1; _i <= _ref; i = _i += 1) {
                othersSum += data.values[i - dataStart].fraction
                }
                minSlice = othersS.minSliceFraction;
                        maxOthers = othersS.maxOthersFraction;
                        maxSlices = othersS.maxSlicesVisible;
                        count = 0;
                        slicesSum = 0;
                        full = data.done;
                        while (count + offset < dataEnd) {
                count++;
                        val = data.values[offset + count - dataStart - 1].fraction;
                        slicesSum += val;
                        othersSum -= val;
                        othersRealFraction = othersSum / (othersSum + slicesSum);
                        othersVisibleFraction = Math.min(othersRealFraction, maxOthers);
                        sliceFraction = val / slicesSum * (1 - othersVisibleFraction);
                        if (count > maxSlices || sliceFraction < minSlice) {
                if (data.done && count + offset !== dataEnd) {
                count--
                }
                full = true;
                        break
                }
                }
                if (!full) {
                this.scene.data.requestMorePieData(id)
                }
                return[count, full]
                };
                Piechart_PieBuilder.prototype.getBackOffset = function(id, data, othersOffset) {
                var count, dataEnd, dataStart, full, i, maxOthers, maxSlices, minSlice, othersFraction, othersS, othersSum, pos, slicesSum, smallestSliceFraction, smallestValue, val, _i, _ref;
                        if (!data || (data.offset >= othersOffset) || (!data.done && data.offset + data.values.length < othersOffset)) {
                this.scene.data.requestPieData(id, Math.max(0, othersOffset - this.scene.settings.data.itemsToLoad), this.scene.settings.data.itemsToLoad);
                        return[0, false]
                }
                if (data.done && othersOffset > data.offset + data.values.length) {
                othersOffset = data.offset + data.values.length
                }
                if (othersOffset === 0) {
                return[0, true]
                }
                othersS = this.scene.settings.interaction.others;
                        dataStart = data.offset;
                        dataEnd = dataStart + data.values.length;
                        othersSum = data.afterFraction;
                        for (i = _i = othersOffset, _ref = dataEnd - 1; _i <= _ref; i = _i += 1) {
                othersSum += data.values[i - dataStart].fraction
                }
                minSlice = othersS.minSliceFraction;
                        maxOthers = othersS.maxOthersFraction;
                        maxSlices = othersS.maxSlicesVisible;
                        pos = othersOffset;
                        smallestValue = data.values[othersOffset - dataStart - 1].fraction;
                        slicesSum = 0;
                        full = data.offset === 0;
                        while (pos > data.offset) {
                pos--;
                        count = othersOffset - pos;
                        val = data.values[pos - dataStart].fraction;
                        slicesSum += val;
                        othersFraction = Math.min(othersSum / (othersSum + slicesSum), maxOthers);
                        smallestSliceFraction = smallestValue / slicesSum * (1 - othersFraction);
                        if (pos === 0 || count > maxSlices || smallestSliceFraction < minSlice) {
                if (pos === 1) {
                pos = 0
                }
                full = true;
                        break
                }
                }
                if (!full) {
                this.scene.data.requestLessPieData(id)
                }
                return[pos, full]
                };
                Piechart_PieBuilder.prototype.buildSlices = function(pie, offset, count) {
                var data, fractionCompress, i, othersFraction, othersSettings, othersSlice, othersVal, prevValue, previousFraction, previousSlice, s, slice, slices, slicesFraction, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3, _ref4;
                        data = pie.data;
                        if (!data) {
                throw"Internal error"
                }
                slicesFraction = 0;
                        slices = [];
                        for (i = _i = offset, _ref = offset + count - 1; _i <= _ref; i = _i += 1) {
                s = new Piechart_Slice(pie, i);
                        s.data = data.values[i - data.offset];
                        s.id = s.data.__id;
                        slicesFraction += s.data.fraction;
                        slices.push(s)
                }
                othersSettings = this.scene.settings.interaction.others;
                        othersFraction = data.afterFraction;
                        othersVal = data.afterSum;
                        for (i = _j = _ref1 = offset + count, _ref2 = data.offset + data.values.length - 1; _j <= _ref2; i = _j += 1) {
                othersVal += data.values[i - data.offset].value;
                        othersFraction += data.values[i - data.offset].fraction
                }
                if (othersFraction > 0) {
                othersSlice = new Piechart_Slice(pie, Infinity);
                        othersSlice.data = {value: othersVal, fraction: othersFraction, name: this.scene.settings.localization.othersLabel}
                } else {
                othersSlice = null
                }
                previousSlice = null;
                        previousFraction = 0;
                        if (offset > 0) {
                prevValue = data.beforeSum;
                        for (i = _k = _ref3 = data.offset, _ref4 = Math.min(offset, data.offset + data.values.length) - 1; _k <= _ref4; i = _k += 1) {
                prevValue += Math.abs(data.values[i - data.offset].value)
                }
                previousSlice = new Piechart_Slice(pie, - 1);
                        previousFraction = othersSettings.navigationFraction;
                        previousSlice.data = {value: prevValue, name: this.scene.settings.localization.previousLabel};
                        previousSlice.fraction = previousFraction
                }
                fractionCompress = (1 - previousFraction) / (slicesFraction + othersFraction);
                        othersFraction = othersFraction * fractionCompress;
                        if (offset > 0 || othersFraction > othersSettings.maxOthersFraction) {
                othersFraction = Math.min(othersFraction, othersSettings.navigationFraction)
                }
                if (othersSlice) {
                othersSlice.fraction = othersFraction
                }
                fractionCompress = (1 - previousFraction - othersFraction) / slicesFraction;
                        for (_l = 0, _len = slices.length; _l < _len; _l++) {
                slice = slices[_l];
                        slice.fraction = slice.data.fraction * fractionCompress
                }
                return[slices, othersSlice, previousSlice]
                };
                Piechart_PieBuilder.prototype.applyNewSlices = function(pie, newSlices, others, previous) {
                var allSlices, i1, i2, oldSlices, s1, s2, slice, slices, wasEmpty, _i, _len, _ref;
                        oldSlices = pie.slices;
                        wasEmpty = oldSlices.length === 0;
                        slices = [];
                        allSlices = [];
                        i1 = 0;
                        i2 = 0;
                        while (i1 < oldSlices.length || i2 < newSlices.length) {
                s1 = oldSlices[i1];
                        s2 = newSlices[i2];
                        if ((s1 != null) && (s2 != null) && s1.id === s2.id) {
                s1.removed = false;
                        s1.fraction = s2.fraction;
                        s1.data = s2.data;
                        if (s2.currentFraction) {
                s1.currentFraction = s2.currentFraction;
                        s1.animatorF = null
                }
                slices.push(s1);
                        allSlices.push(s1);
                        i1++;
                        i2++
                } else {
                if (!s2 || (s1 && s1.index < s2.index)) {
                s1.removed = true;
                        s1.fraction = 0;
                        allSlices.push(s1);
                        slices.push(s1);
                        i1++
                } else {
                if (!s2.currentFraction && !wasEmpty) {
                s2.currentFraction = 0
                }
                slices.push(s2);
                        allSlices.push(s2);
                        i2++
                }
                }
                }
                pie.total = pie.data ? pie.data.total : 0;
                        pie.count = newSlices.length;
                        pie.slices = slices;
                        pie.allSlices = allSlices;
                        if (others) {
                if (!pie.othersSlice) {
                if (!wasEmpty) {
                others.currentFraction = 0
                }
                pie.othersSlice = others
                } else {
                pie.othersSlice.removed = others.removed;
                        pie.othersSlice.data = others.data;
                        pie.othersSlice.fraction = others.fraction;
                        pie.othersSlice.value = others.value;
                        if (others.currentFraction != null) {
                pie.othersSlice.currentFraction = others.currentFraction;
                        pie.othersSlice.animatorF = null
                }
                }
                pie.allSlices.push(pie.othersSlice)
                } else {
                if (pie.othersSlice) {
                pie.allSlices.push(pie.othersSlice);
                        pie.othersSlice.removed = true;
                        pie.othersSlice.fraction = 0
                }
                }
                if (previous) {
                if (!pie.previousSlice) {
                if (!wasEmpty) {
                previous.currentFraction = 0
                }
                pie.previousSlice = previous
                } else {
                pie.previousSlice.removed = previous.removed;
                        pie.previousSlice.data = previous.data;
                        pie.previousSlice.fraction = previous.fraction;
                        pie.previousSlice.value = previous.value;
                        if (previous.currentFraction != null) {
                pie.previousSlice.currentFraction = previous.currentFraction;
                        pie.previousSlice.animatorF = null
                }
                }
                pie.allSlices.unshift(pie.previousSlice)
                } else {
                if (pie.previousSlice) {
                pie.previousSlice.removed = true;
                        pie.previousSlice.fraction = 0;
                        pie.allSlices.unshift(pie.previousSlice)
                }
                }
                _ref = pie.allSlices;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                slice = _ref[_i];
                        slice.value = slice.data.value
                }
                return this.scene.updateOnPieChanged(pie)
                };
                Piechart_PieBuilder.prototype.getPieData = function(pie) {
                var data, sum, v, _i, _j, _len, _len1, _ref, _ref1;
                        data = this.scene.data.getPieData(pie.id);
                        if (!data) {
                return null
                }
                sum = data.total;
                        if (sum > 0) {
                _ref = data.values;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                v = _ref[_i];
                        v.fraction = v.value / sum
                }
                } else {
                sum = data.values.length;
                        _ref1 = data.values;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                v = _ref1[_j];
                        v.fraction = 1 / sum
                }
                }
                if (data.afterSum > 0) {
                data.afterFraction = data.afterSum / sum
                } else {
                data.afterFraction = 0
                }
                if (data.beforeSum > 0) {
                data.beforeFraction = data.beforeSum / sum
                } else {
                data.beforeFraction = 0
                }
                return data
                };
                return Piechart_PieBuilder
        })();
        var Base_Bar_Button, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Base_Bar_Button = (function(_super) {
        __extends(Base_Bar_Button, _super);
                function Base_Bar_Button() {
                return Base_Bar_Button.__super__.constructor.apply(this, arguments)
                }
        Base_Bar_Button.prototype.defaultButtonOptions = {type: "default", activeClass: "btn-active", hasIcon: true};
                Base_Bar_Button.prototype.active = false;
                Base_Bar_Button.prototype.init = function() {
                Base_Bar_Button.__super__.init.call(this);
                        Base_Helpers.configure(this.options, this.defaultButtonOptions);
                        if (this.options.activeClass) {
                this.activeClass = Base_Helpers.wrapClass(this.parent, this.options.activeClass)
                } else {
                this.activeClass = false
                }
                this.ui.a = Base_Helpers.createDom("a", null, null, this.ui.container);
                        if (this.options.title) {
                this.ui.a.setAttribute("title", this.options.title)
                }
                Base_Helpers.addClass(this.ui.a, Base_Helpers.wrapClass(this.parent, "btn-" + (this.options.css ? this.options.css : this.options.type) + ",btn"));
                        if (this.options.label || this.options.hasIcon) {
                this.ui.p = Base_Helpers.createDom("p", null, this.options.label, this.ui.a)
                }
                if (!this.options.onClick) {
                this.options.onClick = this.defaultOnClick
                }
                return Base_Helpers.listen(this.ui.a, "click", (function(_this) {
                return function(ev) {
                if (_this.parent.toggleState) {
                _this.parent.toggleState(_this)
                } else {
                _this.toggleState()
                }
                _this.options.onClick(_this, ev);
                        ev.stopPropagation();
                        return ev.preventDefault()
                }
                })(this))
                };
                Base_Bar_Button.prototype.defaultOnClick = function(obj, ev) {
                return console.error("No event handler for this item", obj, ev)
                };
                Base_Bar_Button.prototype.toggleState = function(hide) {
                if (!this.activeClass) {
                return
                }
                if (typeof hide !== "undefined") {
                if (!hide) {
                this.active = true;
                        return Base_Helpers.addClass(this.ui.a, this.activeClass)
                } else {
                if (hide) {
                this.active = false;
                        return Base_Helpers.removeClass(this.ui.a, this.activeClass)
                }
                }
                } else {
                if (this.active) {
                this.active = false;
                        return Base_Helpers.removeClass(this.ui.a, this.activeClass)
                } else {
                this.active = true;
                        return Base_Helpers.addClass(this.ui.a, this.activeClass)
                }
                }
                };
                return Base_Bar_Button
        })(Base_Bar_Item);
        var Base_Bar_ButtonSet, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Base_Bar_ButtonSet = (function(_super) {
        __extends(Base_Bar_ButtonSet, _super);
                Base_Bar_ButtonSet.prototype.buttonMode = null;
                function Base_Bar_ButtonSet(options) {
                var d;
                        d = {buttonMode: "one"};
                        Base_Helpers.extend(d, options);
                        Base_Bar_ButtonSet.__super__.constructor.call(this, d)
                }
        Base_Bar_ButtonSet.prototype.addItem = function(obj, options) {
        obj.options.bare = true;
                obj.ui.container = this.ui.container;
                Base_Bar_ButtonSet.__super__.addItem.call(this, obj, options);
                return obj
        };
                Base_Bar_ButtonSet.prototype.render = function() {
                return this.ui.container
                };
                Base_Bar_ButtonSet.prototype.toggleState = function(obj) {
                var mode, v, _i, _len, _ref;
                        if (this.options.buttonMode === "one") {
                mode = obj.active ? true : false;
                        _ref = this.items;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                v = _ref[_i];
                        v.obj.toggleState(true)
                }
                return obj.toggleState(mode)
                } else {
                if (this.options.buttonMode === "none") {
                } else {
                if (this.options.buttonMode === "multi") {
                return obj.toggleState()
                }
                }
                }
                };
                return Base_Bar_ButtonSet
        })(Base_Bar_Item);
        var Linearchart_Bar_BackButton, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Linearchart_Bar_BackButton = (function(_super) {
        __extends(Linearchart_Bar_BackButton, _super);
                function Linearchart_Bar_BackButton(options) {
                this.options = {label: "Back", type: "back", title: "Move one step back in time scale selection history", onClick: (function(_this) {
                return function() {
                return _this.chart().back(true, "user")
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Linearchart_Bar_BackButton.__super__.constructor.call(this, this.options)
                }
        return Linearchart_Bar_BackButton
        })(Base_Bar_Button);
        var Linearchart_Bar_ZoomOutButton, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Linearchart_Bar_ZoomOutButton = (function(_super) {
        __extends(Linearchart_Bar_ZoomOutButton, _super);
                function Linearchart_Bar_ZoomOutButton(options) {
                this.options = {label: "Zoom-out", type: "zoomout", title: "Zoom-out to wider time period", onClick: (function(_this) {
                return function() {
                return _this.chart().zoomOut(null, true, "user")
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Linearchart_Bar_ZoomOutButton.__super__.constructor.call(this, this.options)
                }
        return Linearchart_Bar_ZoomOutButton
        })(Base_Bar_Button);
        var Linearchart_Bar_LinLogButton, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Linearchart_Bar_LinLogButton = (function(_super) {
        __extends(Linearchart_Bar_LinLogButton, _super);
                function Linearchart_Bar_LinLogButton(options) {
                this.options = {type: "lin", activeClass: null, label: "Lin", title: "Switch lin/log scale", onClick: (function(_this) {
                return function() {
                return _this.chart().setLogScale(!_this.chart().scene.settings.valueAxis["default"].logScale, "user")
                }
                })(this), onSceneChange: (function(_this) {
                return function(ev) {
                return _this.update(ev)
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Linearchart_Bar_LinLogButton.__super__.constructor.call(this, this.options)
                }
        Linearchart_Bar_LinLogButton.prototype.init = function() {
        Linearchart_Bar_LinLogButton.__super__.init.call(this);
                return this.update(null, true)
        };
                Linearchart_Bar_LinLogButton.prototype.update = function(ev, fts) {
                var scene;
                        if (fts || Base_Helpers.hasProp(ev, "changes/settingsChanges/valueAxis/default/logScale")) {
                scene = this.chart().scene;
                        if (scene.settings.valueAxis["default"].logScale) {
                Base_Helpers.removeClass(this.ui.a, Base_Helpers.wrapClass(this.parent, "btn-lin"));
                        return Base_Helpers.addClass(this.ui.a, Base_Helpers.wrapClass(this.parent, "btn-log"))
                } else {
                Base_Helpers.removeClass(this.ui.a, Base_Helpers.wrapClass(this.parent, "btn-log"));
                        return Base_Helpers.addClass(this.ui.a, Base_Helpers.wrapClass(this.parent, "btn-lin"))
                }
                }
                };
                return Linearchart_Bar_LinLogButton
        })(Base_Bar_Button);
        var Base_Bar_Label, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Base_Bar_Label = (function(_super) {
        __extends(Base_Bar_Label, _super);
                function Base_Bar_Label() {
                return Base_Bar_Label.__super__.constructor.apply(this, arguments)
                }
        Base_Bar_Label.prototype.defaultLabelOptions = {type: "default", label: null};
                Base_Bar_Label.prototype.active = false;
                Base_Bar_Label.prototype.init = function() {
                Base_Bar_Label.__super__.init.call(this);
                        Base_Helpers.configure(this.options, this.defaultLabelOptions);
                        this.ui.em = Base_Helpers.createDom("em", null, this.options.label, this.ui.container);
                        Base_Helpers.addClass(this.ui.em, Base_Helpers.wrapClass(this.parent, "label-" + (this.options.css ? this.options.css : this.options.type) + ",label"));
                        if (!this.options.onClick) {
                this.options.onClick = this.defaultOnClick
                }
                return Base_Helpers.listen(this.ui.em, "click", (function(_this) {
                return function(ev) {
                return _this.options.onClick(_this, ev)
                }
                })(this))
                };
                Base_Bar_Label.prototype.defaultOnClick = function(obj, ev) {
                };
                return Base_Bar_Label
        })(Base_Bar_Item);
        var Linearchart_Bar_LinLogLabel, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Linearchart_Bar_LinLogLabel = (function(_super) {
        __extends(Linearchart_Bar_LinLogLabel, _super);
                function Linearchart_Bar_LinLogLabel(options) {
                this.options = {type: "scale", enclosureClass: "enc-bare", onSceneChange: (function(_this) {
                return function(ev) {
                var p;
                        if ((p = Base_Helpers.getProp(ev, "changes/settingsChanges/valueAxis/default/logScale")) !== void 0) {
                if (p) {
                _this.ui.em.innerHTML = "Log";
                        Base_Helpers.removeClass(_this.ui.em, Base_Helpers.wrapClass(_this.parent, "label-lin"));
                        return Base_Helpers.addClass(_this.ui.em, Base_Helpers.wrapClass(_this.parent, "label-log"))
                } else {
                _this.ui.em.innerHTML = "Lin";
                        Base_Helpers.removeClass(_this.ui.em, Base_Helpers.wrapClass(_this.parent, "label-log"));
                        return Base_Helpers.addClass(_this.ui.em, Base_Helpers.wrapClass(_this.parent, "label-lin"))
                }
                }
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Linearchart_Bar_LinLogLabel.__super__.constructor.call(this, this.options)
                }
        Linearchart_Bar_LinLogLabel.prototype.init = function() {
        var s;
                s = this.chart().scene.settings.valueAxis["default"].logScale;
                this.options.label = s ? "Log" : "Lin";
                this.options.css = s ? "log" : "lin";
                return Linearchart_Bar_LinLogLabel.__super__.init.call(this)
        };
                return Linearchart_Bar_LinLogLabel
        })(Base_Bar_Label);
        var Timechart_Bar_PeriodLabel, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Bar_PeriodLabel = (function(_super) {
        __extends(Timechart_Bar_PeriodLabel, _super);
                function Timechart_Bar_PeriodLabel(options) {
                this.options = {label: "", type: "period", css: "bars", enclosureClass: "enc-bare"};
                        Base_Helpers.extend(this.options, options);
                        Timechart_Bar_PeriodLabel.__super__.constructor.call(this, this.options)
                }
        Timechart_Bar_PeriodLabel.prototype.init = function() {
        this.chart().on("timeChange", (function(_this) {
        return function(ev) {
        return _this.updateOption(ev, 1)
        }
        })(this));
                return Timechart_Bar_PeriodLabel.__super__.init.call(this)
        };
                Timechart_Bar_PeriodLabel.prototype.updateOption = function(ev, fts) {
                var chart, found, k, n, name, v, _i, _len, _ref;
                        chart = this.chart();
                        if (!(Base_Helpers.getProp(ev, "changes/time") || fts)) {
                return
                }
                found = false;
                        _ref = chart.settings.toolbars.advanced.periodsParsed;
                        for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
                v = _ref[k];
                        if (chart.isThisDisplayPeriod(v.displayPeriod, v.displayAnchor)) {
                n = k;
                        found = true;
                        break
                }
                }
                if (!found) {
                name = chart.settings.localization.custom
                } else {
                name = chart.settings.toolbars.advanced.periodsParsed[n].name
                }
                return this.ui.em.innerHTML = name
                };
                return Timechart_Bar_PeriodLabel
        })(Base_Bar_Label);
        var Timechart_Bar_DisplayUnitLabel, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Bar_DisplayUnitLabel = (function(_super) {
        __extends(Timechart_Bar_DisplayUnitLabel, _super);
                function Timechart_Bar_DisplayUnitLabel(options) {
                this.options = {label: "", type: "displayunit", css: "bars", enclosureClass: "enc-bare", onSceneChange: (function(_this) {
                return function(ev) {
                return _this.updateOption(ev)
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Timechart_Bar_DisplayUnitLabel.__super__.constructor.call(this, this.options)
                }
        Timechart_Bar_DisplayUnitLabel.prototype.init = function() {
        return Timechart_Bar_DisplayUnitLabel.__super__.init.call(this)
        };
                Timechart_Bar_DisplayUnitLabel.prototype.paintScene = function() {
                return this.updateOption(null, 1)
                };
                Timechart_Bar_DisplayUnitLabel.prototype.updateOption = function(ev, fts) {
                var chart, du;
                        chart = this.chart();
                        if ((ev && ev.changes && ev.changes.time) || fts) {
                du = chart.scene.displayUnit;
                        if (du === null || du === this.displayUnitValue) {
                return
                }
                this.displayUnitValue = du;
                        if (du) {
                return this.ui.em.innerHTML = du.toString()
                }
                }
                };
                return Timechart_Bar_DisplayUnitLabel
        })(Base_Bar_Label);
        var Linearchart_Bar_LinButton, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Linearchart_Bar_LinButton = (function(_super) {
        __extends(Linearchart_Bar_LinButton, _super);
                function Linearchart_Bar_LinButton(options) {
                this.options = {type: "lin", label: "Lin", title: "Use Linear Scale", onClick: (function(_this) {
                return function() {
                return _this.chart().setLogScale(false, "user")
                }
                })(this), onSceneChange: (function(_this) {
                return function(ev) {
                var prop;
                        if ((prop = Base_Helpers.getProp(ev, "changes/settingsChanges/valueAxis/default/logScale")) !== void 0) {
                return _this.toggleState(prop)
                }
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Linearchart_Bar_LinButton.__super__.constructor.call(this, this.options)
                }
        Linearchart_Bar_LinButton.prototype.init = function() {
        Linearchart_Bar_LinButton.__super__.init.call(this);
                if (!this.chart().settings.valueAxis["default"].logScale) {
        return this.toggleState(false)
        }
        };
                return Linearchart_Bar_LinButton
        })(Base_Bar_Button);
        var Linearchart_Bar_LogButton, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Linearchart_Bar_LogButton = (function(_super) {
        __extends(Linearchart_Bar_LogButton, _super);
                function Linearchart_Bar_LogButton(options) {
                this.options = {type: "log", label: "Log", title: "Use Logaritmic Scale", onClick: (function(_this) {
                return function() {
                return _this.chart().setLogScale(true, "user")
                }
                })(this), onSceneChange: (function(_this) {
                return function(ev) {
                var p;
                        if ((p = Base_Helpers.getProp(ev, "changes/settingsChanges/valueAxis/default/logScale")) !== void 0) {
                if (p) {
                return _this.toggleState(false)
                } else {
                return _this.toggleState(true)
                }
                }
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Linearchart_Bar_LogButton.__super__.constructor.call(this, this.options)
                }
        Linearchart_Bar_LogButton.prototype.init = function() {
        Linearchart_Bar_LogButton.__super__.init.call(this);
                if (this.chart().settings.valueAxis["default"].logScale) {
        return this.toggleState(false)
        }
        };
                return Linearchart_Bar_LogButton
        })(Base_Bar_Button);
        var Base_Bar_Dropdown, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Base_Bar_Dropdown = (function(_super) {
        __extends(Base_Bar_Dropdown, _super);
                Base_Bar_Dropdown.prototype.selected = false;
                Base_Bar_Dropdown.prototype.dropdownDefaultOptions = {listActiveClass: "dropdown-active", onClick: function() {
                }, getOptionName: function(o) {
                return o
                }, getOptionIdentifier: function(o) {
                return o
                }, showTitle: true};
                function Base_Bar_Dropdown(options) {
                var defaultOptions;
                        this.revData = {};
                        defaultOptions = {setInitialValue: true, data: [], hasIcon: null, label: null, previewPointerDown: this.previewPointerDown};
                        Base_Helpers.configure(options, defaultOptions);
                        Base_Bar_Dropdown.__super__.constructor.call(this, options)
                }
        Base_Bar_Dropdown.prototype.init = function() {
        var first, index, v, _i, _len, _ref;
                Base_Helpers.configure(this.options, this.dropdownDefaultOptions);
                Base_Bar_Dropdown.__super__.init.call(this);
                this.listActiveClass = Base_Helpers.wrapClass(this.parent, this.options.listActiveClass);
                this.options.activeClass = "whitebg";
                this.activeClass = Base_Helpers.wrapClass(this.parent, this.options.activeClass);
                Base_Helpers.addClass(this.ui.a, Base_Helpers.wrapClass(this.parent, "show-more"));
                this.ui.s = Base_Helpers.createDom("span", null, null, this.ui.a);
                this.ui.list = Base_Helpers.createDom("div", Base_Helpers.wrapClass(this.parent, "dropdown"), null, this.ui.container);
                this.ui.list_ul = Base_Helpers.createDom("ul", null, null, this.ui.list);
                this.ui.list_items = {};
                first = false;
                _ref = this.options.data;
                for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        v = _ref[index];
                if (first === false) {
        first = index
        }
        this.addOption(this.ui.list_ul, v, index)
        }
        if (this.options.setInitialValue) {
        this.setOption(first)
        }
        this.chart().events.addHook(this, "dropdown-opened", (function(_this) {
        return function(hook, args, caller) {
        if (caller.id !== _this.id) {
        return _this.toggleState(true)
        }
        }
        })(this));
                return this.chart().events.addHook(this, "bar-closed", (function(_this) {
        return function() {
        return _this.toggleState(true)
        }
        })(this))
        };
                Base_Bar_Dropdown.prototype.toggleState = function(hide) {
                if (!this.active && !hide) {
                this.active = true;
                        this.chart().events.hook("dropdown-opened", null, this);
                        if (this.activeClass) {
                Base_Helpers.addClass(this.ui.a, this.activeClass)
                }
                return Base_Helpers.fadeIn(this.ui.list)
                } else {
                if (hide || this.active) {
                if (this.active) {
                this.active = false;
                        if (this.activeClass) {
                Base_Helpers.removeClass(this.ui.a, this.activeClass)
                }
                return Base_Helpers.fadeOut(this.ui.list)
                }
                }
                }
                };
                Base_Bar_Dropdown.prototype.addOption = function(container, v, index) {
                var c, li, name;
                        if (this.selected === index) {
                c = this.listActiveClass
                } else {
                c = null
                }
                li = Base_Helpers.createDom("li", null, null, container);
                        name = this.options.getOptionName(v);
                        this.ui.list_items[index] = Base_Helpers.createDom("a", c, name, li);
                        this.revData[this.options.getOptionIdentifier(v)] = index;
                        return Base_Helpers.listen(this.ui.list_items[index], "click", (function(_this) {
                        return function() {
                        return _this.setOption(index)
                        }
                        })(this))
                };
                Base_Bar_Dropdown.prototype.setOption = function(option, silent) {
                var id, index;
                        if (this.options.data[option] != null) {
                index = option
                } else {
                id = this.options.getOptionIdentifier(option);
                        if (!this.revData.hasOwnProperty(id)) {
                console.error("Key not found in data set", id, index, this.id);
                        return
                }
                index = this.revData[id]
                }
                if (this.selected !== false) {
                Base_Helpers.removeClass(this.ui.list_items[this.selected], this.listActiveClass)
                }
                this.selected = index;
                        Base_Helpers.addClass(this.ui.list_items[this.selected], this.listActiveClass);
                        if (this.options.showTitle) {
                this.ui.p.innerHTML = this.options.getOptionName(this.options.data[this.selected])
                }
                if (!silent) {
                if (this.options.onChange) {
                this.options.onChange(this)
                }
                return this.toggleState(true)
                }
                };
                Base_Bar_Dropdown.prototype.previewPointerDown = function(ev) {
                var box, l, lh, lw;
                        if (this.active) {
                l = Base_Helpers.elementPos(this.ui.list);
                        lw = this.ui.list.offsetWidth;
                        lh = this.ui.list.offsetHeight;
                        box = [l[0], l[1], l[0] + lw, l[1] + lh];
                        if (Base_Helpers.isWithIn([ev.x, ev.y], box)) {
                return this.toggleState(true)
                }
                }
                };
                Base_Bar_Dropdown.prototype.onSceneChange = function(ev) {
                };
                return Base_Bar_Dropdown
        })(Base_Bar_Button);
        var Timechart_Bar_PeriodButton, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Bar_PeriodButton = (function(_super) {
        __extends(Timechart_Bar_PeriodButton, _super);
                function Timechart_Bar_PeriodButton() {
                return Timechart_Bar_PeriodButton.__super__.constructor.apply(this, arguments)
                }
        Timechart_Bar_PeriodButton.prototype.setOption = function() {
        return this.chart().setDisplayPeriod(this.options.period, "now", null, true, "user")
        };
                return Timechart_Bar_PeriodButton
        })(Base_Bar_Button);
        var Netchart_Settings, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Netchart_Settings = (function(_super) {
        __extends(Netchart_Settings, _super);
                Netchart_Settings.FlatTheme = {advanced: {themeCSSClass: "DVSL-flat", assets: ["netchart.css"]}};
                Netchart_Settings.defaults = {theme: Netchart_Settings.FlatTheme, area: {centerX: 0.5, centerY: 0.5, paddingTop: 0, paddingLeft: 0, paddingRight: 0, paddingBottom: 0}, data: {format: "JSON", preloaded: null, dataFunction: null, url: null, requestTimeout: 40000, cacheSize: 10000, random: null, randomGridLinkProbability: 0.6, randomNodes: 0, randomLinks: 0, requestMaxUnits: 2, numberOfParralelRequests: 3, preloadNodeLinks: false}, filters: {nodeFilter: null, linkFilter: null, nodeLinksProcessor: null, multilinkProcessor: null}, style: {nodeLabelMinSize: 40, nodeDetailMinZoom: 0.2, linkLabelMinZoom: 3, itemsMinZoom: 0.7, linkDecorationScale: 4, nodeDisplay: "image", makeImagesCircular: false, nodeRadiusExtent: [10, 50], linkRadiusExtent: [0.2, 10], linkStrengthExtent: [0.1, 1], linkLengthExtent: [0.1, 50], nodeAutoScaling: null, linkAutoScaling: null, linkStrengthAutoScaling: null, linkLengthAutoScaling: null, nodeRules: {}, linkRules: {}, node: {fillColor: "#4f4", lineColor: null, lineWidth: null, radius: 10, shadowColor: null}, link: {fillColor: "#6D6", shadowColor: null, fromDecoration: null, toDecoration: null, label: null, radius: 1, length: 1, strength: 1, dashed: false, toPieValue: 0, toPieColor: null}, item: {align: "left", aspectRatio: 4, textStyle: {fillColor: "black", font: "12px Arial"}, backgroundStyle: {fillColor: "rgba(255,255,255,0.7)"}}, linkLabel: {align: "left", aspectRatio: 4, textStyle: {fillColor: "black", font: "12px Arial"}, backgroundStyle: {fillColor: "#FFF", lineColor: "gray"}}, nodeLabel: {align: "left", aspectRatio: 4, textStyle: {fillColor: "black", font: "12px Arial"}, backgroundStyle: {fillColor: "rgba(255,255,255,0.7)"}}, selection: {fillColor: "lightblue", sizeConstant: 5, sizeProportional: 0.2}, nodeLocked: {}, nodeExpanded: {}, nodeFocused: {fillColor: "orange"}, nodeNotLoaded: {fillColor: "#7c7"}, hiddenLinks: {fillColor: "#BBB", lineColor: "rgba(100,100,100,0.3)", lineWidth: 1, size: 2}, nodeHovered: {shadowOffsetX: 0, shadowOffsetY: 0, shadowBlur: 12, shadowColor: "blue"}, linkHovered: {shadowOffsetX: 0, shadowOffsetY: 0, shadowBlur: 12, shadowColor: "blue"}, itemHovered: {backgroundStyle: {shadowOffsetX: 0, shadowOffsetY: 0, shadowBlur: 12, shadowColor: "blue"}}, removedColor: "#EEE"}, layout: {nodeSpacing: 16, multilinkSpacing: 10, mode: "dynamic", incrementalLayoutMaxTime: 300, initialLayoutMaxTime: 2000, aspectRatio: false, layoutFreezeTimeout: 1500, fadeTime: 600, globalLayoutOnChanges: true}, info: {enabled: false, nodeContentsFunction: null, linkContentsFunction: null}, interaction: {zooming: {autoZoom: true, doubleClickZoom: 1.5, zoomExtent: [0.1, 8], sensitivity: 1, wheel: true, fingers: true, autoZoomDuration: 500, autoZoomSize: 0.9}, panning: {enabled: true}, selection: {enabled: true, nodesSelectable: true, linksSelectable: true, lockNodesOnMove: true, tolerance: 10, allowMoveNodesOffscreen: true}}, navigation: {mode: "showall", initialNodes: null, focusNodeExpansionRadius: 2, focusHistoryRelevanceCooldown: 0.6, focusAutoFadeout: true, numberOfFocusNodes: 3, expandDelay: 400, expandOnClick: true, autoZoomOnFocus: false, nodeAutoExpandFilter: null, keren_speed_of_messages : 1820}, nodeMenu: {enabled: true, buttons: ["hide", "expand", "focus", "lock"], showData: false, contentsFunction: null}, linkMenu: {enabled: true, showData: false, contentsFunction: null}, toolbar: {enabled: true, location: "bottom-left", zoomControl: true, freeze: true, rearrange: true, fullscreen: true, "export": true}, advanced: {perNodeLoadingIndicator: true, style: {loadingArcStyle: {r: 35, lineColor: "red", lineWidth: 5, location: "corner"}}}, localization: {loadingLabel: "Loading...", closeButton: "Close", menu: {dynaminc: "Dynamic", fixed: "Fixed", focus: "Focus", unfocus: "Unfocus", collapse: "Collapse", expand: "Expand", hide: "Hide"}}};
                function Netchart_Settings(settings) {
                Netchart_Settings.__super__.constructor.call(this, "netchart");
                        this.applyDefaults(Netchart_Settings.defaults);
                        this.apply(settings)
                }
        Netchart_Settings.prototype.apply = function(settings) {
        var changes, p, r, _ref, _ref1;
                changes = Netchart_Settings.__super__.apply.call(this, settings);
                if (settings.style) {
        if (settings.style.nodeRules) {
        _ref = settings.style.nodeRules;
                for (p in _ref) {
        r = _ref[p];
                this.style.nodeRules[p] = r
        }
        }
        if (settings.style.linkRules) {
        _ref1 = settings.style.linkRules;
                for (p in _ref1) {
        r = _ref1[p];
                this.style.linkRules[p] = r
        }
        }
        }
        return changes
        };
                return Netchart_Settings
        })(Base_Settings);
        var Timechart_Settings, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Settings = (function(_super) {
        __extends(Timechart_Settings, _super);
                Timechart_Settings.StaticChart = {interaction: {zooming: {enabled: false}, selection: {enabled: false}, scrolling: {enabled: false}}};
                Timechart_Settings.FlatTheme = {advanced: {themeCSSClass: "DVSL-flat", assets: []}, area: {style: {noData: {fillColor: "#DDD", image: "builtin-no-data-light"}, loadingData: {fillColor: "#EEE"}}}, chartTypes: {columns: {style: {gradient: 1, depth: 0}}}, timeAxis: {style: {showMajorTimeBalloons: false, showMinorTimeBalloons: false, majorTimeLabel: {fillColor: "#000", shadowColor: null}, minorTimeLabel: {fillColor: "#000", shadowColor: null}, dateLighten: {fillColor: "rgba(0,0,0,0.05)"}}}};
                Timechart_Settings.RoundTheme = {advanced: {themeCSSClass: "DVSL-round", assets: []}, valueAxis: {"default": {style: {valueLabel: {fillColor: "#000000", font: "11px Arial", shadowOffsetX: 0, shadowOffsetY: 1, shadowBlur: 0, shadowColor: "rgba(255,255,255,0.5)"}}}}, timeAxis: {style: {showMinorTimeBalloons: false, showMajorTimeBalloons: true, minorTimeBalloonStyle: {fillColor: "#FFF", shadowOffsetX: 0, shadowOffsetY: 2, shadowBlur: 2, shadowColor: "#888"}, majorTimeBalloonStyle: {fillColor: "AAA", shadowOffsetX: 0, shadowOffsetY: - 1, shadowBlur: 0, shadowColor: "rgba(0,0,0,0.3)"}, minorTimeLabel: {fillColor: "#000000", font: "12px Arial", shadowOffsetX: 0, shadowOffsetY: 1, shadowBlur: 0, shadowColor: "rgba(255,255,255,0.5)"}, majorTimeLabel: {fillColor: "#FFF", font: "11px Arial", shadowOffsetX: 0, shadowOffsetY: 1, shadowBlur: 1, shadowColor: "#7c7c7c"}, dateLighten: {fillColor: "rgba(0,0,0,0.05)"}, dateHolidays: {fillColor: "rgba(255,127,127,0.2)"}, minorTimeRuler1: {lineColor: "rgba(0,0,0,0.2)"}, minorTimeRuler2: {lineColor: "rgba(255,255,255,0.1)"}}}, chartTypes: {columns: {style: {gradient: 0.8, depth: 3}}}, area: {style: {noData: {image: "builtin-no-data-dark"}}}};
                Timechart_Settings.GradientTheme = {advanced: {themeCSSClass: "DVSL-gradient", assets: []}, valueAxis: {"default": {style: {valueLabel: {fillColor: "#000000", font: "11px Arial", shadowOffsetX: 0, shadowOffsetY: 1, shadowBlur: 0, shadowColor: "rgba(255,255,255,0.5)"}}}}, timeAxis: {style: {showMinorTimeBalloons: false, showMajorTimeBalloons: true, minorTimeBalloonStyle: {fillColor: "#FFF", shadowOffsetX: 0, shadowOffsetY: 2, shadowBlur: 2, shadowColor: "#888"}, majorTimeBalloonStyle: {fillColor: "AAA", shadowOffsetX: 0, shadowOffsetY: - 1, shadowBlur: 0, shadowColor: "rgba(0,0,0,0.3)"}, minorTimeLabel: {fillColor: "#000000", font: "12px Arial", shadowOffsetX: 0, shadowOffsetY: 1, shadowBlur: 0, shadowColor: "rgba(255,255,255,0.5)"}, majorTimeLabel: {fillColor: "#FFF", font: "11px Arial", shadowOffsetX: 0, shadowOffsetY: 1, shadowBlur: 1, shadowColor: "#7c7c7c"}, dateLighten: {fillColor: "rgba(255,255,255,0.2)"}, dateHolidays: {fillColor: "rgba(255,127,127,0.2)"}, minorTimeRuler1: {lineColor: "rgba(0,0,0,0.2)"}, minorTimeRuler2: {lineColor: "rgba(255,255,255,0.1)"}}}, chartTypes: {columns: {style: {gradient: 0.8, depth: 3}}}, area: {style: {noData: {image: "builtin-no-data-dark"}}}};
                Timechart_Settings.defaults = {theme: Timechart_Settings.FlatTheme, area: {initialDisplayPeriod: "max", initialDisplayAnchor: "newestData", initialDisplayUnit: "auto", followAnchor: false, displayUnits: [{unit: "1 s", name: "second"}, {unit: "5 s", name: "5 seconds"}, {unit: "1 m", name: "minute"}, {unit: "5 m", name: "5 minutes"}, {unit: "1 h", name: "hour"}, {unit: "6 h", name: "6 hours"}, {unit: "1 d", name: "day"}, {unit: "1 M", name: "month"}, {unit: "1 y", name: "year"}], displayPeriods: [{displayPeriod: "10 ms"}, {displayPeriod: "100 ms"}, {displayPeriod: "s"}, {displayPeriod: "m"}, {displayPeriod: "h"}, {displayPeriod: "d"}, {displayPeriod: "M"}, {displayPeriod: "y"}, {displayPeriod: "10 y"}, {displayPeriod: "100 y"}], noData: true, style: {loadingData: {fillColor: "#BBB"}, markerText: {font: "12px Arial"}, selection: {lineColor: "#000000", fillColor: "rgba(30,160,220,0.15)"}, selectionLabel: {fillColor: "#000000", font: "12px Arial"}}}, currentTime: {enabled: true, label: "", style: {lineColor: "red", fillColor: "red"}, serverTime: null, computedTimeOffset: 0}, timeAxis: {enabled: true, size: 44, vgrid: true, minUnitWidth: 12, maxUnitWidth: 200, style: {miniTimeRuler: true, showMinorTimeBalloons: false, showMajorTimeBalloons: true, minorTimeBalloonStyle: {fillColor: "#FFF"}, majorTimeBalloonStyle: {fillColor: "AAA"}, minorTimeLabel: {fillColor: "#000000", font: "12px Arial"}, majorTimeLabel: {fillColor: "#FFF", font: "11px Arial"}, dateLighten: {fillColor: "rgba(255,255,255,0.2)"}, dateHolidays: {fillColor: "rgba(255,127,127,0.2)"}, minorTimeRuler1: {lineColor: "rgba(0,0,0,0.2)"}, minorTimeRuler2: {lineColor: "rgba(255,255,255,0.1)"}, vgrid: {lineColor: "rgba(0,0,0,0.1)"}}}, data: {name: "default", units: ["s", "m", "h", "d", "M", "y"], format: "JSON", preloaded: null, url: null, urlByUnit: {}, dataFunction: null, limitStart: null, limitEnd: null, requestMaxUnits: 10000, requestTimeout: 10000, prefetchRatio: 1, minimizeRequests: false, cacheSize: 1000000, timestampInSeconds: false}, toolbars: {"default": "toolbarBare", enabled: ["toolbar", "toolbarBare"], logScale: true, displayUnit: true, periodSelection: true, backButton: true, zoomOutButton: true, "export": true, advanced: {periods: [{name: "Last second", displayAnchor: "now", displayPeriod: "1 s", displayUnit: "25 ms"}, {name: "Last minute", displayAnchor: "now", displayPeriod: "1 m", displayUnit: "1 s"}, {name: "Last hour", displayAnchor: "now", displayPeriod: "1 h", displayUnit: "1 m"}, {name: "Last day", displayAnchor: "now", displayPeriod: "1 d", displayUnit: "1 h"}, {name: "Last week", displayAnchor: "now", displayPeriod: "1 w", displayUnit: "6 h"}, {name: "Last month", displayAnchor: "now", displayPeriod: "1 M", displayUnit: "1 d"}, {name: "Last year", displayAnchor: "now", displayPeriod: "1 y", displayUnit: "1 M"}, {name: "All data", displayAnchor: "now", displayPeriod: "max", displayUnit: "auto"}], displayUnit: {dynamic: false}}}, localization: {timeUnitsNames: {ms: "millisecond", s: "second", m: "minute", h: "hour", d: "day", w: "week", M: "month", y: "year"}, timeUnitsNamesPlural: {ms: "milliseconds", s: "seconds", m: "minutes", h: "hours", d: "days", w: "weeks", M: "months", y: "years"}, weekdays: ["Su", "Mon", "Tue", "Wed", "Thu", "Fri", "Sa"], months: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], custom: "Custom", firstDayOfWeek: 0, holidays: [], markerDates: {timeFormats: {ms: "", s: "ss.SSS", m: "HH:mm:ss", h: "HH:mm", d: "D, HH:mm", w: "MMM D", M: "MMM D", y: "YYYY, MMM D"}}, infoDates: {majorTimeFormats: {y: null, M: "YYYY", w: "YYYY", d: "YYYY", h: "MMM D, YYYY", m: "MMM D, YYYY", s: "MMM D, YYYY", ms: "MMM D, YYYY"}, minorTimeFormats: {y: "YYYY", M: "MMM", w: "[Week] W", d: "MMM D", h: "HH:mm", m: "HH:mm", s: "HH:mm:ss", ms: "ss.SSS"}, fullTimeFormats: {ms: "MMM D, YYYY HH:mm:ss", s: "MMM D, YYYY HH:mm:ss", m: "MMM D, YYYY", h: "MMM D, YYYY HH:00", d: "MMM D, YYYY", w: "[Week] W, YYYY", M: "MMM YYYY", y: "YYYY"}}, timeAxisDates: {minorLabelTimeFormats: {ms: "ss.SSS", s: "HH:mm:ss", m: "HH:mm", h: "HH:00", d: "MMM D", w: "MMM D", M: "MMM", y: "YYYY"}, majorLabelTimeFormats: {ms: "MMM D, YYYY HH:mm:ss", s: "MMM D, YYYY HH:mm:ss", m: "MMM D, YYYY", h: "MMM D, YYYY HH:00", d: "MMM D, YYYY", w: "[Week] W, YYYY", M: "MMM YYYY", y: "YYYY"}}, noDataLabel: "No data", loadingLabel: "Loading"}, events: {onTimeChange: null, chartUpdateDelay: 400}, interaction: {snapMode: "displayUnit", selection: {enabled: true, grabThreshold: 5}}, advanced: {timeUpdateInterval: 1000, dataUpdateInterval: null, maxUnitsToDisplay: 20000, maxZoomOutFactor: 1.5, builtinAssets: {"builtin-column": builtinImages["column.png"], "builtin-no-data-light": builtinImages["no-data-light.png"], "builtin-no-data-dark": builtinImages["no-data-dark.png"]}, assets: ["timechart.css", "jspdf/jspdf.min.js", "jspdf/jspdf.plugin.addimage.min.js"]}};
                function Timechart_Settings(settings) {
                Timechart_Settings.__super__.constructor.call(this, "timechart");
                        this.applyDefaults(Timechart_Settings.defaults);
                        this.currentTime.computedTimeOffset = - new Date().getTimezoneOffset() * 1000 * 60;
                        this.apply(settings)
                }
        Timechart_Settings.prototype.apply = function(settings) {
        var changes, d, dataArray, dataChanges, t, _i, _len;
                if (settings.data) {
        dataChanges = true;
                if (Base_Helpers.isArray(settings.data)) {
        dataArray = settings.data;
                settings.data = null
        } else {
        dataArray = null
        }
        }
        changes = Timechart_Settings.__super__.apply.call(this, settings);
                if (dataChanges) {
        changes.data = true;
                this.computedData = [];
                if (dataArray) {
        for (_i = 0, _len = dataArray.length; _i < _len; _i++) {
        d = dataArray[_i];
                t = {};
                this.applyRec(t, Timechart_Settings.defaults.data, {});
                this.applyRec(t, d, {});
                this.computedData.push(t)
        }
        } else {
        this.computedData.push(this.data)
        }
        }
        this._calcMinUnit();
                if (Base_Helpers.hasProp(this, "area/displayUnits")) {
        this.area.displayUnitsParsed = this._parseUnits(this.area.displayUnits)
        }
        if (Base_Helpers.hasProp(this, "area/displayPeriods")) {
        this.area.displayPeriodsParsed = this._parsePeriods(this.area.displayPeriods)
        }
        if (Base_Helpers.hasProp(this, "toolbars/advanced/periods")) {
        this.toolbars.advanced.periodsParsed = this._filterPeriods(this.toolbars.advanced.periods)
        }
        if (Base_Helpers.isNumber(Base_Helpers.getProp(settings, "currentTime/serverTime"))) {
        this.currentTime.computedTimeOffset = settings.currentTime.serverTime - new Date().getTime() - new Date().getTimezoneOffset() * 1000 * 60
        }
        if (this.area) {
        if (this.area.minUnit) {
        this.area.minDisplayRange = this.area.minUnit.approxTime() * 10
        } else {
        this.area.minDisplayRange = 10
        }
        }
        return changes
        };
                Timechart_Settings.prototype._parseUnits = function(unitList) {
                var r, s, t, _i, _len;
                        r = [];
                        for (_i = 0, _len = unitList.length; _i < _len; _i++) {
                s = unitList[_i];
                        t = Base_TimeStep.parse(s);
                        if (t === null) {
                Base_Helpers.error("Settings: unknown time unit '" + s + "'")
                } else {
                if (this.area.minUnit.isSmallerOrEqual(t)) {
                r.push(t)
                }
                }
                }
                return r
                };
                Timechart_Settings.prototype._parsePeriods = function(unitList) {
                var p, r, s, u, x, _i, _len;
                        r = [];
                        for (_i = 0, _len = unitList.length; _i < _len; _i++) {
                s = unitList[_i];
                        x = Base_Helpers.clone(s);
                        x.displayUnit = u = Base_TimeStep.parse(s.displayUnit);
                        x.displayPeriod = p = Base_TimeStep.parse(s.displayPeriod);
                        if ((p === null || this.area.minUnit.isSmallerOrEqual(p)) && (u === null || this.area.minUnit.isSmallerOrEqual(u))) {
                r.push(x)
                }
                }
                return r
                };
                Timechart_Settings.prototype._filterPeriods = function(list) {
                var p, r, s, u, _i, _len;
                        r = [];
                        for (_i = 0, _len = list.length; _i < _len; _i++) {
                s = list[_i];
                        u = Base_TimeStep.parse(s.displayUnit);
                        p = Base_TimeStep.parse(s.displayPeriod);
                        if ((p === null || this.area.minUnit.isSmallerOrEqual(p)) && (u === null || this.area.minUnit.isSmallerOrEqual(u))) {
                r.push(s)
                }
                }
                return r
                };
                Timechart_Settings.prototype._calcMinUnit = function() {
                var minUnit, minUnit2, s, ss, _i, _j, _len, _len1, _ref, _ref1;
                        if (!((this.area != null) && (this.data != null) && (this.area.displayUnits != null) && (this.data.units != null))) {
                return
                }
                minUnit = new Base_TimeStep("y", 1000000);
                        _ref = this.area.displayUnits;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                        ss = Base_TimeStep.parse(s);
                        if (ss.isSmaller(minUnit)) {
                minUnit = ss
                }
                }
                minUnit2 = new Base_TimeStep("y", 1000000);
                        _ref1 = this.data.units;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                s = _ref1[_j];
                        ss = new Base_TimeStep(s, 1);
                        if (ss.isSmaller(minUnit2)) {
                minUnit2 = ss
                }
                }
                if (minUnit2.isBigger(minUnit)) {
                minUnit = minUnit2
                }
                return this.area.minUnit = minUnit
                };
                return Timechart_Settings
        })(Linearchart_Settings);
        var Piechart_Settings, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Piechart_Settings = (function(_super) {
        __extends(Piechart_Settings, _super);
                Piechart_Settings.FlatTheme = {advanced: {themeCSSClass: "DVSL-flat", assets: []}, pie: {theme: "flat"}};
                Piechart_Settings.BevelTheme = {advanced: {themeCSSClass: "DVSL-flat", assets: []}, pie: {theme: "bevel"}};
                Piechart_Settings.GradientTheme = {advanced: {themeCSSClass: "DVSL-flat", assets: []}, pie: {theme: "smoothy"}};
                Piechart_Settings.CanTheme = {advanced: {themeCSSClass: "DVSL-flat", assets: []}, pie: {theme: "can", depth: 8}};
                Piechart_Settings.defaults = {theme: Piechart_Settings.FlatTheme, data: {format: "JSON", preloaded: null, dataFunction: null, url: null, itemsToLoad: 50, requestTimeout: 40000, numberOfParralelRequests: 3, partialLoad: true, sortSlices: false}, area: {initialPieId: "", initialPieOffset: 0, initialSelectionIds: [], initialAnimation: true}, pie: {radius: null, adaptiveRadius: true, animateRadius: true, outerMargin: 1, margin: 2, centerMargin: 5, showInnerPies: true, showInnerPiesExport: true, innerRadius: 0.3, x: null, y: null, startAngle: - Math.PI / 2, endAngle: Math.PI * 1.5, theme: "flat", depth: 0, style: {fillColor: "transparent", sliceColors: ["#2fc32f", "#b0dc0b", "#eab404", "#de672c", "#ec2e2e", "#d5429b", "#6f52b8", "#1c7cd5", "#56b9f7", "#0ae8eb"], colorDistribution: "list", brightness: 1}, noDataStyle: {fillColor: "#ddd"}, backgroundStyle: {}, backgroundHoveredStyle: {brightness: 0.7}, styleFunction: null}, slice: {margin: 2, style: {lineBrightness: 0, brightness: 1, cutoutDistance: 0, lineColor: null, lineWidth: 1, label: null, insideLabel: null, url: null, icon: null}, hoverStyle: {brightness: 1.2, lineBrightness: 2, lineWidth: 0.7}, selectedStyle: {cutoutDistance: 15}, backgroundStyle: {fillColor: "#e2e2e2", fillColor2: "#e0e0e0"}, backgroundActiveStyle: {brightness: 1.3}, othersStyle: {fillColor: "#ccc", lineDecoration: "zigzag"}, previousStyle: {fillColor: "#ccc", lineDecoration: "zigzag"}, expandableMarkStyle: {lineWidth: 1, lineColor: "rgba(255,255,255,0.8)", distance: 4}, styleFunction: null}, filters: {sliceFilter: null}, labels: {enabled: true, connectors: true, connectorLength: 20, angle: 0, insideLabel: "append", insideLabelVisibilityFraction: 0.8, lineSpacing: 0.2, interLabelSpacing: 0.6, connectorStyle: {lineColor: "#333", lineWidth: 1}, textStyle: {fillColor: "#000", font: "12px Arial"}, backgroundStyle: null, insideTextStyle: {fillColor: "#fff", font: "12px Arial"}, placement: "aligned", margin: 4}, advanced: {renderQuality: 1, backImage: "builtin-back", assets: ["piechart.css", "jspdf/jspdf.min.js", "jspdf/jspdf.plugin.addimage.min.js"], iconMinSize: 16, animationTime: 500, interactionTime: 200, labelInsideTreshold: 1, pointer: {noClickOnDoubleClick: false}, builtinAssets: {"builtin-back": Piechart_images_back}}, events: {onPieChange: null, onPieReadyStateChanged: null}, interaction: {selection: {enabled: true, tolerance: 2}, others: {enabled: true, centerGoesToPrevious: false, navigationFraction: 0.15, maxSlicesVisible: 15, maxOthersFraction: 0.6, minSliceFraction: 0.01}, scrolling: {enabled: false}, dragging: {enabled: false}, drilldown: {enabled: true}}, info: {enabled: true, contentsFunction: null}, localization: {othersLabel: "Others", previousLabel: "Previous", loadingLabel: "Loading...", closeButton: "Close"}};
                function Piechart_Settings(settings) {
                Piechart_Settings.__super__.constructor.call(this, "piechart");
                        this.applyDefaults(Piechart_Settings.defaults);
                        this.apply(settings)
                }
        Piechart_Settings.prototype.apply = function(settings) {
        var changes;
                changes = Piechart_Settings.__super__.apply.call(this, settings);
                return changes
        };
                return Piechart_Settings
        })(Base_Settings);
        var Facetchart_Settings, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Facetchart_Settings = (function(_super) {
        __extends(Facetchart_Settings, _super);
                Facetchart_Settings.defaults = {theme: null, data: Piechart_Settings.defaults.data, filters: {sliceFilter: null}, area: {initialPieId: "", initialPieOffset: 0, initialSelectionIds: [], initialAnimation: true}, items: {style: {brightness: 1, cutoutDistance: 0, label: null, insideLabel: null, expandable: true, url: null, icon: null}, hoverStyle: {brightness: 1.2}, selectedStyle: {cutoutDistance: 15}, backgroundStyle: {fillColor: "#e2e2e2", fillColor2: "#e0e0e0"}, backgroundActiveStyle: {brightness: 1.3}, styleFunction: null}, facetAxis: {enabled: true, size: 40, minUnitWidth: 50, maxUnitWidth: 400, labels: {enabled: true, angle: 0, lineSpacing: 0.2, interLabelSpacing: 0.6, textStyle: {fillColor: "#000", font: "12px Arial"}, margin: 4}}, events: {onSelectionChange: null, onPieChange: null, onPieReadyStateChanged: null}, interaction: {selection: {enabled: true, tolerance: 2}, drilldown: {enabled: true}}, info: {enabled: true, contentsFunction: null}, advanced: {animationTime: 800, interactionTime: 200}, localization: {loadingLabel: "Loading..."}};
                function Facetchart_Settings(settings) {
                Facetchart_Settings.__super__.constructor.call(this, "facetchart");
                        this.applyDefaults(Facetchart_Settings.defaults);
                        this.apply(settings)
                }
        Facetchart_Settings.prototype.apply = function(settings) {
        var changes;
                changes = Facetchart_Settings.__super__.apply.call(this, settings);
                return changes
        };
                return Facetchart_Settings
        })(Linearchart_Settings);
        var Netchart_Renderer;
        Netchart_Renderer = (function() {
        Netchart_Renderer.prototype.scene = null;
                Netchart_Renderer.prototype.events = null;
                Netchart_Renderer.prototype.animationPriority = 999;
                function Netchart_Renderer(chart) {
                this.chart = chart;
                        this.scene = chart.scene;
                        this.events = chart.events;
                        this.imageCache = {};
                        this.imageLoading = {};
                        this.multilinks = {};
                        this.itemRenderer = new Base_MarkerRenderer(this.chart)
                }
        Netchart_Renderer.prototype.doAnimations = function(event) {
        if (event.changes.position) {
        return this.chart.notifyPositionChange(event)
        }
        };
                Netchart_Renderer.prototype.getNodeImage = function(style) {
                var doRounding, doTinting, imageDone, imageId, imageUrl, round, tint;
                        if (!style.image) {
                return null
                }
                tint = style.tintImage && style.fillColor;
                        round = this.scene.settings.style.makeImagesCircular;
                        imageId = style.image;
                        imageUrl = imageId;
                        if (tint) {
                imageId += "##" + style.fillColor
                }
                if (this.imageCache[imageId] != null) {
                return this.imageCache[imageId]
                } else {
                if (this.imageLoading[imageId]) {
                return null
                } else {
                doRounding = (function(_this) {
                return function(image) {
                var data;
                        if (round) {
                data = Base_Graphics.cropImageToCircle(image);
                        return Base_Helpers.buildImage(data, doTinting)
                } else {
                return doTinting(image)
                }
                }
                })(this);
                        doTinting = (function(_this) {
                        return function(image) {
                        var data;
                                if (tint) {
                        data = Base_Graphics.applyColorToImage(im, style.fillColor, false);
                                return Base_Helpers.buildImage(data, imageDone)
                        } else {
                        return imageDone(image)
                        }
                        }
                        })(this);
                        imageDone = (function(_this) {
                        return function(image) {
                        _this.imageCache[imageId] = image;
                                delete _this.imageLoading[imageId];
                                if (!_this.chart.removed) {
                        return _this.events.notifySceneChanges({repaint: true})
                        }
                        }
                        })(this);
                        this.imageLoading[imageId] = true;
                        this.scene.settings.getAssetImage(imageUrl, doRounding);
                        return null
                }
                }
                };
                Netchart_Renderer.prototype.paintScene = function(event) {
                var g, hoverLinkPos, hoverNodePos;
                        hoverNodePos = this.makeHoveredLast(this.scene.nodes(), this.scene.hoverNode);
                        hoverLinkPos = this.makeHoveredLast(this.scene.links(), this.scene.hoverLink);
                        this.scene.updateMultilinks();
                        this.scene.clearModified();
                        this.computeNodeRenderRadii();
                        g = event.context;
                        this.paintSelection(g);
                        this.paintLinks(g);
                        event.animating |= this.paintNodes(g, event.time);
                        this.restoreHovered(this.scene.nodes(), hoverNodePos);
                        return this.restoreHovered(this.scene.links(), hoverLinkPos)
                };
                Netchart_Renderer.prototype.getGeometry = function() {
                var txa, txm, tya, tym, x0s, x0w, x1s, x1w, y0s, y0w, y1s, y1w, zoom, _ref;
                        _ref = this.scene.toDisplayTransform(), txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3];
                        x0s = this.scene.x0;
                        x1s = this.scene.x0 + this.scene.width;
                        y0s = this.scene.y0;
                        y1s = this.scene.y0 + this.scene.height;
                        x0w = (x0s - txa) / txm;
                        x1w = (x1s - txa) / txm;
                        y0w = (y0s - tya) / tym;
                        y1w = (y1s - tya) / tym;
                        zoom = this.scene.zoom;
                        return[txm, txa, tym, tya, zoom, x0s, x1s, y0s, y1s, x0w, y0w, x1w, y1w]
                };
                Netchart_Renderer.prototype.makeHoveredLast = function(list, hobj) {
                var i, len, n1, obj, _i, _len;
                        len = list.length;
                        if (len < 2 || !hobj || hobj === list[len - 1]) {
                return len - 1
                }
                for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
                obj = list[i];
                        if (obj === hobj) {
                n1 = list[len - 1];
                        list[len - 1] = hobj;
                        list[i] = n1;
                        return i
                }
                }
                return len - 1
                };
                Netchart_Renderer.prototype.restoreHovered = function(list, pos) {
                var len, n1;
                        len = list.length;
                        if (pos !== len - 1) {
                n1 = list[pos];
                        list[pos] = list[len - 1];
                        return list[len - 1] = n1
                }
                };
                Netchart_Renderer.prototype.computeNodeRenderRadii = function() {
                var node, r, w, zoom, _i, _len, _ref, _results;
                        zoom = this.scene.zoom;
                        _ref = this.scene.nodes();
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                        r = node.currentRadius * zoom;
                        w = node.currentHwidth * zoom;
                        if (node.lineWidth) {
                r += node.lineWidth / 2;
                        w += node.lineWidth / 2
                }
                node.renderRadius = r;
                        _results.push(node.renderHwidth = w)
                }
                return _results
                };
                Netchart_Renderer.prototype.paintLinks = function(g) {
                var active, count, dashLen, ddx, ddy, decorationScale, decorationSize, dx, dy, i, invlen, l0, l1, len, link, linkLabelMinZoom, linkSpacing, ml, multiId, multiLinks, nodeDetailMinZoom, offset, paintDetails, paintItems, pieInner, pieOuter, pieSizeConst, pieSizeProp, pieSpacing, r, r0, r1, t0, t1, txa, txm, tya, tym, w0, w1, width, x0, x0a, x0b, x0s, x0w, x1, x1s, x1w, y0, y0a, y0b, y0s, y0w, y1, y1s, y1w, ysign, zoom, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _results;
                        _ref = this.getGeometry(), txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3], zoom = _ref[4], x0s = _ref[5], x1s = _ref[6], y0s = _ref[7], y1s = _ref[8], x0w = _ref[9], y0w = _ref[10], x1w = _ref[11], y1w = _ref[12];
                        g.textAlign = "center";
                        g.textBaseline = "middle";
                        multiLinks = this.scene.multilinks;
                        linkLabelMinZoom = this.scene.settings.style.linkLabelMinZoom;
                        nodeDetailMinZoom = this.scene.settings.style.nodeDetailMinZoom;
                        linkSpacing = this.scene.settings.layout.multilinkSpacing * zoom;
                        paintItems = zoom > this.scene.settings.style.itemsMinZoom;
                        decorationScale = this.scene.settings.style.linkDecorationScale;
                        pieSpacing = 2;
                        pieSizeConst = 5;
                        pieSizeProp = 0.1;
                        _ref1 = this.scene.links();
                        _results = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                link = _ref1[_i];
                        x0 = link.from.x;
                        y0 = link.from.y;
                        x1 = link.to.x;
                        y1 = link.to.y;
                        if (Math.max(x0, x1) < x0w || Math.min(x0, x1) > x1w || Math.max(y0, y1) < y0w || Math.min(y0, y1) > y1w) {
                continue
                }
                x0 = x0 * txm + txa;
                        y0 = y0 * tym + tya;
                        x1 = x1 * txm + txa;
                        y1 = y1 * tym + tya;
                        r = Math.max(0.25, link.currentRadius * zoom * 0.5);
                        active = link === this.scene.hoverLink || link.from === this.scene.hoverNode || link.to === this.scene.hoverNode;
                        paintDetails = active || zoom > nodeDetailMinZoom;
                        if (paintDetails) {
                r0 = link.from.renderRadius;
                        r1 = link.to.renderRadius;
                        w0 = link.from.renderHwidth;
                        w1 = link.to.renderHwidth;
                        dx = x1 - x0;
                        dy = y1 - y0;
                        len = Math.sqrt(dx * dx + dy * dy);
                        if (link.toPieValue > 0 && paintDetails) {
                pieInner = r1 + pieSpacing;
                        pieOuter = pieInner + pieSizeConst + pieSizeProp * r1;
                        this.paintLinkPie(g, x1, y1, pieInner, pieOuter, link.toPie0, link.toPie1, link.toPieColor);
                        r1 = pieOuter
                }
                if (len < r0 + r1) {
                continue
                }
                invlen = 1 / len;
                        ddx = dx * invlen;
                        ddy = dy * invlen;
                        if (r0 >= w0) {
                t0 = r0
                } else {
                if (ddy === 0) {
                t0 = w0
                } else {
                ysign = Base_Helpers.sign(ddy);
                        t0 = r0 / ddy * ysign;
                        if (Math.abs(ddx * t0) > w0 - r0) {
                t0 = Base_Geometry.rayIntersectsCircleOuter( - (w0 - r0), 0, Math.abs(ddx), ddy, r0)
                }
                }
                }
                if (r1 === w1) {
                t1 = r1
                } else {
                if (ddy === 0) {
                t1 = w1
                } else {
                ysign = Base_Helpers.sign(ddy);
                        t1 = r1 / ddy * ysign;
                        if (Math.abs(ddx * t1) > w1 - r1) {
                t1 = Base_Geometry.rayIntersectsCircleOuter( - (w1 - r1), 0, Math.abs(ddx), ddy, r1)
                }
                }
                }
                if (len <= t0 + t1) {
                continue
                }
                decorationSize = Math.min(len / 3, Math.max(2, r * decorationScale));
                        if (link.fromDecoration) {
                t0 += decorationSize
                }
                if (link.toDecoration) {
                t1 += decorationSize
                }
                x0 += ddx * t0;
                        y0 += ddy * t0;
                        x1 -= ddx * t1;
                        y1 -= ddy * t1;
                        dx = x1 - x0;
                        dy = y1 - y0;
                        len = len - t0 - t1;
                        invlen = 1 / len;
                        multiId = link.multiId;
                        ml = multiLinks[multiId];
                        if (Base_Helpers.isArray(ml)) {
                count = ml.length;
                        width = Math.min(linkSpacing, r0, r1);
                        offset = width * (ml.indexOf(link) - (count - 1) / 2) / (count - 1);
                        if (link.from.id > link.to.id) {
                x0 += ddy * offset;
                        x1 += ddy * offset;
                        y0 -= ddx * offset;
                        y1 -= ddx * offset
                } else {
                x0 -= ddy * offset;
                        x1 -= ddy * offset;
                        y0 += ddx * offset;
                        y1 += ddx * offset
                }
                }
                g.beginPath();
                        if (link.fromDecoration) {
                this.paintLinkDecoration(g, x0, y0, ddx, ddy, decorationSize, link.fromDecoration, link.fillColor)
                }
                if (link.toDecoration) {
                this.paintLinkDecoration(g, x1, y1, - ddx, - ddy, decorationSize, link.toDecoration, link.fillColor)
                }
                if (link.dashed) {
                x0a = x0 + ddy * r;
                        y0a = y0 - ddx * r;
                        x0b = x0 - ddy * r;
                        y0b = y0 + ddx * r;
                        dashLen = Math.max(5, r * 3);
                        for (i = _j = 0, _ref2 = len / dashLen; _j <= _ref2; i = _j += 2) {
                l0 = i * dashLen;
                        l1 = Math.min((i + 1) * dashLen, len);
                        g.moveTo(x0a + l0 * ddx, y0a + l0 * ddy);
                        g.lineTo(x0b + l0 * ddx, y0b + l0 * ddy);
                        g.lineTo(x0b + l1 * ddx, y0b + l1 * ddy);
                        g.lineTo(x0a + l1 * ddx, y0a + l1 * ddy);
                        g.closePath()
                }
                } else {
                g.moveTo(x0 + ddy * r, y0 - ddx * r);
                        g.lineTo(x0 - ddy * r, y0 + ddx * r);
                        g.lineTo(x1 - ddy * r, y1 + ddx * r);
                        g.lineTo(x1 + ddy * r, y1 - ddx * r);
                        g.closePath()
                }
                Base_Graphics.fill(g, link);
                        // keren !!!!!!!!!!!

                        /*
                         * Messages     Control     Start
                         */
                        
                        
                        /*
                         *                  runMovingMessageType = [];
                                            ifSendingMessageIndex = [];
                                            toNodeIdIndex = [];
                                            movingMessageSpeed = [];
                         */

                         // get the two sides of the current link, and check if they have any message to send
                        var nodeWithNewAtt1 = this.chart.navigator.nodes[link.from.id];
                        var nodeWithNewAtt2 = this.chart.navigator.nodes[link.to.id];
                        
                        var messagefromx;
                        var messagefromy;
                        var messagetox;
                        var messagetoy;
                        
                        /* NODE 1 */
                        
                        if (nodeWithNewAtt1) {
                             if (nodeWithNewAtt1.toNodeIdIndex) {
                            if (nodeWithNewAtt1.toNodeIdIndex.indexOf(link.to.id) !== -1) {
                                
                                var IndexOfMessage = nodeWithNewAtt1.toNodeIdIndex.indexOf(link.to.id);
                                
                                if (nodeWithNewAtt1.ifSendingMessageIndex[IndexOfMessage] == true) {
                                    
                                    g.beginPath();

                                    if (nodeWithNewAtt1.runMovingMessageType[IndexOfMessage] == "Virus") {
                                        g.fillStyle = "#FF1C0A"; // red
                                    }
                                    else {
                                        g.fillStyle = "#2946e6";
                                    }         
                                    

                                    messagefromx = x0 + ddy * r;
                                    messagefromy = y0 - ddx * r;
                                    messagetox = x1 + ddy * r;
                                    messagetoy = y1 - ddx * r;

                                    //this.scene.settings
                                    //console.log((this.scene.settings.navigation.keren_speed_of_messages / 182000));
                                    link.runMovingMessageStepY += ((40/ this.scene.settings.navigation.keren_speed_of_messages) * nodeWithNewAtt1.movingMessageSpeed[IndexOfMessage]);

                                    if (link.runMovingMessageStepY <= 1) {
                                            var deltaX = messagetox - messagefromx;
                                            var deltaY = messagetoy - messagefromy;
                                            var distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                                            var directionX = deltaX / distance;
                                            var directionY = deltaY / distance;
                                            var newX = messagefromx + directionX * (distance * link.runMovingMessageStepY);
                                            var newY = messagefromy + directionY * (distance * link.runMovingMessageStepY);
                                            //aW.beginPath();
                                            g.arc(newX, newY, r * 4, 0, 2 * Math.PI); // keren

                                            var imageObj = new Image();
                                            imageObj.src = "Images/" + nodeWithNewAtt1.runMovingMessageType[IndexOfMessage] + ".png";
                                            g.drawImage(imageObj, newX, newY, r * 20, r * 20);
                                            g.closePath();
                                            g.fill();
                                    }
                                    else
                                    {
                                            nodeWithNewAtt1.ifSendingMessageIndex[IndexOfMessage] = false;
                                            var variable = nodeWithNewAtt1.toNodeIdIndex[IndexOfMessage];
                                            
                                            //console.log("1 finish sending from " + nodeWithNewAtt1.id + " to " + nodeWithNewAtt1.toNodeIdIndex[IndexOfMessage] + ". arr:" + nodeWithNewAtt1.toNodeIdIndex)
                                            
                                            var indexOfAppereance = nodeWithNewAtt1.toNodeIdIndex.indexOf(variable);
                                            
                                            //console.log("nodeWithNewAtt1.toNodeIdIndex: " + nodeWithNewAtt1.toNodeIdIndex);
                                            //console.log("var: " + variable);
                                            //console.log("indexOfAppereance: " + indexOfAppereance);
                                            
                                            while (indexOfAppereance !== -1) {
                                                nodeWithNewAtt1.ifSendingMessageIndex.splice(indexOfAppereance, 1);
                                                nodeWithNewAtt1.toNodeIdIndex.splice(indexOfAppereance, 1);
                                                nodeWithNewAtt1.runMovingMessageType.splice(indexOfAppereance, 1);
                                                nodeWithNewAtt1.movingMessageSpeed.splice(indexOfAppereance, 1);
                                                indexOfAppereance = nodeWithNewAtt1.toNodeIdIndex.indexOf(variable);
                                                

                                                //console.log("nodeWithNewAtt1.toNodeIdIndex: " + nodeWithNewAtt1.toNodeIdIndex);
                                                //console.log("var: " + nodeWithNewAtt1.toNodeIdIndex[IndexOfMessage]);
                                                //console.log("indexOfAppereance: " + indexOfAppereance);
                                            }
                                            
                                            //console.log("2 arr: " + nodeWithNewAtt1.toNodeIdIndex);
                                            
                                            link.runMovingMessageStepY = 0.0;
                                    }
                                }
                            }
                        }}
                
                
                        /* NODE 2 */
                
                        if (nodeWithNewAtt2) {
                            if (nodeWithNewAtt2.toNodeIdIndex) {
                            if (nodeWithNewAtt2.toNodeIdIndex.indexOf(link.from.id) !== -1) {
                                
                                var IndexOfMessage = nodeWithNewAtt2.toNodeIdIndex.indexOf(link.from.id);
                                
                                if (nodeWithNewAtt2.ifSendingMessageIndex[IndexOfMessage] == true) {
                                    
                                    g.beginPath();

                                    if (nodeWithNewAtt2.runMovingMessageType[IndexOfMessage] == "Virus") {
                                        g.fillStyle = "#FF1C0A"; // red
                                    }
                                    else {
                                        g.fillStyle = "#2946e6";
                                    }         
                                    

                                    messagetox = x0 + ddy * r;
                                    messagetoy = y0 - ddx * r;
                                    messagefromx = x1 + ddy * r;
                                    messagefromy = y1 - ddx * r;

                                    //console.log((this.scene.settings.navigation.keren_speed_of_messages));
                                    link.runMovingMessageStepX += ((40 / this.scene.settings.navigation.keren_speed_of_messages) * nodeWithNewAtt2.movingMessageSpeed[IndexOfMessage]);

                                    if (link.runMovingMessageStepX <= 1) {
                                            var deltaX = messagetox - messagefromx;
                                            var deltaY = messagetoy - messagefromy;
                                            var distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                                            var directionX = deltaX / distance;
                                            var directionY = deltaY / distance;
                                            var newX = messagefromx + directionX * (distance * link.runMovingMessageStepX);
                                            var newY = messagefromy + directionY * (distance * link.runMovingMessageStepX);
                                            //aW.beginPath();
                                            g.arc(newX, newY, r * 4, 0, 2 * Math.PI); // keren

                                            var imageObj = new Image();
                                            imageObj.src = "Images/" + nodeWithNewAtt2.runMovingMessageType[IndexOfMessage] + ".png";
                                            g.drawImage(imageObj, newX, newY, r * 20, r * 20);
                                            g.closePath();
                                            g.fill();
                                    }
                                    else
                                    {
                                            nodeWithNewAtt2.ifSendingMessageIndex[IndexOfMessage] = false;
                                            var variable = nodeWithNewAtt2.toNodeIdIndex[IndexOfMessage];
                                            
                                            //console.log("1 finish sending from " + nodeWithNewAtt2.id + " to " + nodeWithNewAtt2.toNodeIdIndex[IndexOfMessage] + ". arr:" + nodeWithNewAtt2.toNodeIdIndex)
                                            
                                            var indexOfAppereance = nodeWithNewAtt2.toNodeIdIndex.indexOf(variable);
                                            
                                            //console.log("nodeWithNewAtt2.toNodeIdIndex: " + nodeWithNewAtt2.toNodeIdIndex);
                                            //console.log("var: " + variable);
                                            //console.log("indexOfAppereance: " + indexOfAppereance);
                                            
                                            while (indexOfAppereance !== -1) {
                                                nodeWithNewAtt2.ifSendingMessageIndex.splice(indexOfAppereance, 1);
                                                nodeWithNewAtt2.toNodeIdIndex.splice(indexOfAppereance, 1);
                                                nodeWithNewAtt2.runMovingMessageType.splice(indexOfAppereance, 1);
                                                nodeWithNewAtt2.movingMessageSpeed.splice(indexOfAppereance, 1);
                                                indexOfAppereance = nodeWithNewAtt2.toNodeIdIndex.indexOf(variable);
                                                

                                                //console.log("nodeWithNewAtt2.toNodeIdIndex: " + nodeWithNewAtt2.toNodeIdIndex);
                                                //console.log("var: " + nodeWithNewAtt2.toNodeIdIndex[IndexOfMessage]);
                                                //console.log("indexOfAppereance: " + indexOfAppereance);
                                            }
                                            
                                            //console.log("2 arr: " + nodeWithNewAtt2.toNodeIdIndex);
                                            
                                            link.runMovingMessageStepX = 0.0;
                                    }
                                }
                            }
                        }
                        }                
                
                
                /*
                 * Messages     Control     End
                 */

                if (paintItems && link.currentItems && !link.removed) {
                _results.push(this.paintLinkItems(g, x0, y0, ddx, ddy, len, link.currentItems))
                } else {
                _results.push(void 0)
                }
                } else {
                if (link.fillColor) {
                g.beginPath();
                        g.lineWidth = Math.max(0.1, r * 2);
                        g.strokeStyle = link.fillColor;
                        if (link.dashed) {
                dx = x1 - x0;
                        dy = y1 - y0;
                        len = Math.sqrt(dx * dx + dy * dy);
                        invlen = 1 / len;
                        ddx = dx * invlen;
                        ddy = dy * invlen;
                        dashLen = Math.max(5, r * 3);
                        for (i = _k = 0, _ref3 = len / dashLen; _k <= _ref3; i = _k += 2) {
                l0 = i * dashLen;
                        l1 = Math.min((i + 1) * dashLen, len);
                        g.moveTo(x0 + l0 * ddx, y0 + l0 * ddy);
                        g.lineTo(x0 + l1 * ddx, y0 + l1 * ddy)
                }
                } else {
                g.moveTo(x0, y0);
                        g.lineTo(x1, y1)
                }
                _results.push(g.stroke())
                } else {
                _results.push(void 0)
                }
                }


                }
                return _results
                };
                Netchart_Renderer.prototype.paintNodes = function(g, time) {
                var PI2, a, animating, displayAsText, grad, hiddenLinksStyle, hlinks, im, imSize, label, labelHHeight, labelHWidth, left, leftOffset, lineHeight, lineNo, lines, node, nodeDetailMinZoom, nodeLabelMinSize, numLines, otherRad, paintItems, r, rad, roundText, rr, s, scale, style, text, txa, txm, ty, tya, tym, w, width, x, x0, x0s, x0w, x1s, x1w, xx, y, y0, y0s, y0w, y1s, y1w, zoom, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4;
                        PI2 = Math.PI * 2;
                        animating = false;
                        _ref = this.getGeometry(), txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3], zoom = _ref[4], x0s = _ref[5], x1s = _ref[6], y0s = _ref[7], y1s = _ref[8], x0w = _ref[9], y0w = _ref[10], x1w = _ref[11], y1w = _ref[12];
                        nodeDetailMinZoom = this.scene.settings.style.nodeDetailMinZoom;
                        nodeLabelMinSize = this.scene.settings.style.nodeLabelMinSize / 2;
                        paintItems = zoom > this.scene.settings.style.itemsMinZoom;
                        hiddenLinksStyle = this.scene.settings.style.hiddenLinks;
                        roundText = this.scene.settings.style.nodeDisplay === "roundtext";
                        displayAsText = roundText || this.scene.settings.style.nodeDisplay === "text";
                        g.textAlign = "center";
                        g.textBaseline = "middle";
                        Base_Graphics.textStyle(g, this.scene.settings.style.nodeLabel);
                        _ref1 = this.scene.nodes();
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                node = _ref1[_i];
                        if (!node.data) {
                continue
                }
                x = node.x;
                        y = node.y;
                        rr = node.renderRadius;
                        r = node.currentRadius;
                        w = node.currentHwidth;
                        if (x + rr < x0w || x - rr > x1w || y + rr < y0w || y - rr > y1w) {
                continue
                }
                x = x * txm + txa;
                        y = y * tym + tya;
                        r = r * zoom;
                        w = w * zoom;
                        if (!node.removed && zoom >= nodeDetailMinZoom) {
                hlinks = node.dataLinks.length - node.links.length;
                        if (hlinks > 0) {
                this.paintHiddenLinks(g, node, x, y, r, hlinks, hiddenLinksStyle, hiddenLinksStyle.size * zoom)
                }
                }
                g.beginPath();
                        if (r !== w) {
                xx = x + w - r;
                        g.moveTo(xx, y - r);
                        g.arc(xx, y, r, - Math.PI / 2, Math.PI / 2, false);
                        xx = x - w + r;
                        g.lineTo(xx, y + r);
                        g.arc(xx, y, r, Math.PI * 0.5, Math.PI * 1.5, false);
                        g.closePath()
                } else {
                g.moveTo(x + r, y);
                        g.arc(x, y, r, 0, PI2)
                }
                Base_Graphics.paint(g, node);
                        if (zoom >= nodeDetailMinZoom || node.active) {
                im = this.getNodeImage(node);
                        label = node.currentLabel;
                        if (!displayAsText || !label) {
                if (im != null) {
                left = x - w;
                        if (node.imageSlicing) {
                s = node.imageSlicing;
                        g.drawImage(im, s[0], s[1], s[2], s[3], left, y - r, r * 2, r * 2)
                } else {
                g.drawImage(im, 0, 0, im.width, im.height, left, y - r, r * 2, r * 2)
                }
                }
                } else {
                if (displayAsText && (label != null) && r > 2) {
                this.itemRenderer.measure(g, label);
                        labelHWidth = label.hwidth;
                        labelHHeight = label.hheight;
                        lineHeight = label.lineHeight;
                        leftOffset = 0;
                        if (roundText) {
                rad = Math.sqrt(labelHWidth * labelHWidth + labelHHeight * labelHHeight);
                        if (im != null) {
                xx = lineHeight + 2 * labelHWidth;
                        otherRad = (xx * xx + labelHHeight * labelHHeight) / 2 / xx;
                        if (otherRad > rad) {
                leftOffset = otherRad - rad;
                        rad = otherRad
                }
                }
                scale = r / rad;
                        leftOffset *= scale
                } else {
                scale = r / labelHHeight
                }
                if (im) {
                if (roundText) {
                imSize = lineHeight * scale
                } else {
                leftOffset = r;
                        imSize = r * 2
                }
                x0 = x - w;
                        y0 = y - imSize / 2;
                        if (node.imageSlicing) {
                s = node.imageSlicing;
                        g.drawImage(im, s[0], s[1], s[2], s[3], x0, y0, imSize, imSize)
                } else {
                g.drawImage(im, 0, 0, im.width, im.height, x0, y0, imSize, imSize)
                }
                }
                g.save();
                        Base_Graphics.textStyle(g, node.labelStyle.textStyle);
                        g.transform(scale, 0, 0, scale, x + leftOffset, y);
                        lines = label.lines;
                        numLines = lines.length;
                        ty = - (numLines - 1) * lineHeight * 0.5;
                        for (lineNo = _j = 0, _ref2 = numLines - 1; _j <= _ref2; lineNo = _j += 1) {
                text = lines[lineNo];
                        g.fillText(text, 0, ty);
                        ty += lineHeight
                }
                g.restore()
                }
                }
                if (!node.removed && paintItems && node.currentItems) {
                this.paintNodeItems(g, x, y, w, r, node.currentItems)
                }
                }
                }
                if (!displayAsText) {
                _ref3 = this.scene.nodes();
                        for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
                node = _ref3[_k];
                        if (!((node.currentLabel != null) && !node.removed && node.renderRadius > nodeLabelMinSize)) {
                continue
                }
                x = node.x * txm + txa;
                        y = node.y * tym + tya;
                        label = node.currentLabel;
                        rr = node.renderRadius;
                        this.itemRenderer.measure(g, label);
                        y += rr + label.hheight * 0.8;
                        this.itemRenderer.paint(g, x, y, 1, label)
                }
                }
                if (this.scene.settings.advanced.perNodeLoadingIndicator) {
                style = this.scene.settings.advanced.style.loadingArcStyle;
                        width = style.lineWidth;
                        g.save();
                        g.lineCap = "round";
                        g.lineWidth = width;
                        a = time / 1400;
                        a = (a - Math.floor(a)) * (Math.PI * 2);
                        _ref4 = this.scene.nodes();
                        for (_l = 0, _len2 = _ref4.length; _l < _len2; _l++) {
                node = _ref4[_l];
                        if (node.loading) {
                animating = true;
                        x = node.x * txm + txa;
                        y = node.y * tym + tya;
                        r = node.currentRadius * zoom;
                        if (x - r < x0s || x + r > x1s || y - r < y0s || y + r > y1s) {
                continue
                }
                grad = g.createLinearGradient(x + r * Math.cos(a + Math.PI), y + r * Math.sin(a + Math.PI), x + r * Math.cos(a), y + r * Math.sin(a));
                        grad.addColorStop(0, style.lineColor);
                        grad.addColorStop(1, "transparent");
                        g.strokeStyle = grad;
                        g.beginPath();
                        g.arc(x, y, r, a, a + Math.PI);
                        g.stroke()
                }
                }
                g.restore()
                }
                return animating
                };
                Netchart_Renderer.prototype.paintSelection = function(g) {
                var PI2, cons, ddx, ddy, dx, dy, invLen, n1, n2, obj, prop, r, selStyle, txa, txm, tya, tym, w, x, x0, x0s, x0w, x1, x1s, x1w, xx, y, y0, y0s, y0w, y1, y1s, y1w, zoom, _i, _len, _ref, _ref1;
                        if (!(this.scene.selection.length > 0)) {
                return
                }
                _ref = this.getGeometry(), txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3], zoom = _ref[4], x0s = _ref[5], x1s = _ref[6], y0s = _ref[7], y1s = _ref[8], x0w = _ref[9], y0w = _ref[10], x1w = _ref[11], y1w = _ref[12];
                        PI2 = Math.PI * 2;
                        selStyle = this.scene.settings.style.selection;
                        prop = selStyle.sizeProportional;
                        cons = selStyle.sizeConstant;
                        g.beginPath();
                        _ref1 = this.scene.selection;
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                obj = _ref1[_i];
                        r = (obj.currentRadius * (1 + prop) + cons) * zoom;
                        if (obj.isNode) {
                w = (obj.currentHwidth - obj.currentRadius) * zoom + r;
                        x = obj.x * txm + txa;
                        y = obj.y * tym + tya;
                        xx = x + w - r;
                        g.moveTo(xx, y - r);
                        g.arc(xx, y, r, - Math.PI / 2, Math.PI / 2, false);
                        xx = x - w + r;
                        g.lineTo(xx, y + r);
                        g.arc(xx, y, r, Math.PI * 0.5, Math.PI * 1.5, false);
                        g.closePath()
                } else {
                if (obj.isLink) {
                n1 = obj.from;
                        n2 = obj.to;
                        x0 = n1.x * txm + txa;
                        y0 = n1.y * tym + tya;
                        x1 = n2.x * txm + txa;
                        y1 = n2.y * tym + tya;
                        dx = x0 - x1;
                        dy = y0 - y1;
                        invLen = r / Math.sqrt(dx * dx + dy * dy);
                        ddx = dx * invLen;
                        ddy = dy * invLen;
                        g.moveTo(x0 + ddy, y0 - ddx);
                        g.lineTo(x0 - ddy, y0 + ddx);
                        g.lineTo(x1 - ddy, y1 + ddx);
                        g.lineTo(x1 + ddy, y1 - ddx);
                        g.closePath()
                }
                }
                }
                return Base_Graphics.paint(g, selStyle)
                };
                Netchart_Renderer.prototype.paintLinkDecoration = function(g, x, y, dx, dy, size, decoration, color) {
                g.fillStyle = color;
                        if (decoration === "circle") {
                g.moveTo(x + size, y);
                        return g.arc(x, y, size, 0, Math.PI * 2, true)
                } else {
                if (decoration === "arrow") {
                g.moveTo(x - dx * size, y - dy * size);
                        g.lineTo(x + dx * size - dy * size, y + dy * size + dx * size);
                        return g.lineTo(x + dx * size + dy * size, y + dy * size - dx * size)
                }
                }
                };
                Netchart_Renderer.prototype.paintLinkPie = function(g, x, y, innerRadius, outerRadius, a0, a1, color) {
                var r, w;
                        r = (innerRadius + outerRadius) / 2;
                        w = outerRadius - innerRadius;
                        g.beginPath();
                        g.arc(x, y, r, a0, a1);
                        return Base_Graphics.paint(g, {lineColor: color, lineWidth: w})
                };
                Netchart_Renderer.prototype.paintLinkItems = function(g, x, y, dx, dy, linkLength, items) {
                var fx, fy, item, ix, iy, xx, yy, _i, _len;
                        for (_i = 0, _len = items.length; _i < _len; _i++) {
                item = items[_i];
                        fx = item.x || 0;
                        fy = item.y || 0;
                        ix = item.px || 0.5;
                        iy = item.py || 0;
                        xx = x + dx * linkLength * ix - dy * iy + fx;
                        yy = y + dy * linkLength * ix + dx * iy + fy;
                        this.itemRenderer.paint(g, xx, yy, 1, item)
                }
                };
                Netchart_Renderer.prototype.paintNodeItems = function(g, x, y, w, h, items) {
                var fx, fy, item, ix, iy, xx, yy, _i, _len;
                        for (_i = 0, _len = items.length; _i < _len; _i++) {
                item = items[_i];
                        fx = item.x || 0;
                        fy = item.y || 0;
                        ix = item.px || 0;
                        iy = item.py || 0;
                        xx = x + w * ix + fx;
                        yy = y + h * iy + fy;
                        this.itemRenderer.paint(g, xx, yy, 1, item)
                }
                };
                Netchart_Renderer.prototype.paintHiddenLinks = function(g, node, x, y, r, count, style, size) {
                var PI2, da, i, invlen, link, sidePr, sinkPr, tipPr, xc, xc1, xt, xx, yc, yt, yy, _i, _j, _len, _ref;
                        PI2 = Math.PI * 2;
                        tipPr = (r + size) / r;
                        sidePr = size * 0.73 / r;
                        sinkPr = (r - size * 0.1) / r;
                        if (node.links.length > 0) {
                xx = 0;
                        yy = 0;
                        _ref = node.links;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                link = _ref[_i];
                        xx += link.otherEnd(node).x;
                        yy += link.otherEnd(node).y
                }
                xx = node.x - xx / node.links.length;
                        yy = node.y - yy / node.links.length;
                        invlen = r / Math.sqrt(xx * xx + yy * yy);
                        xc = xx * invlen;
                        yc = yy * invlen
                } else {
                xc = r;
                        yc = 0
                }
                da = PI2 / count / 3;
                        xt = Math.cos( - da * (count - 1) / 2);
                        yt = Math.sin( - da * (count - 1) / 2);
                        xc1 = xc * xt - yc * yt;
                        yc = xc * yt + yc * xt;
                        xc = xc1;
                        xt = Math.cos(da);
                        yt = Math.sin(da);
                        g.beginPath();
                        for (i = _j = 1; _j <= count; i = _j += 1) {
                g.moveTo(x + xc, y + yc);
                        g.lineTo(x + xc * tipPr, y + yc * tipPr);
                        xc1 = xc * xt - yc * yt;
                        yc = xc * yt + yc * xt;
                        xc = xc1
                }
                g.strokeStyle = style.lineColor;
                        g.lineWidth = style.lineWidth;
                        return g.stroke()
                };
                return Netchart_Renderer
        })();
        var Netchart_Menu;
        Netchart_Menu = (function() {
        Netchart_Menu.prototype.animationPriority = 10;
                Netchart_Menu.prototype.node = null;
                Netchart_Menu.prototype.link = null;
                Netchart_Menu.prototype.contents = null;
                Netchart_Menu.prototype.x = 0;
                Netchart_Menu.prototype.y = 0;
                function Netchart_Menu(chart) {
                var closeButton;
                        this.chart = chart;
                        this.container = chart.layers.container;
                        this.scene = chart.scene;
                        this.events = chart.events;
                        this.buttons = [];
                        this.popup = Base_Helpers.createDom("div", "DVSL-NC-bar-info", null, this.container);
                        closeButton = Base_Helpers.createDom("a", "DVSL-NC-close", "X", this.popup);
                        this.popupValue = Base_Helpers.createDom("div", null, null, this.popup);
                        this.detailsDiv = Base_Helpers.createDom("div", "DVSL-NC-bar-details", null, this.popup);
                        this.popupActions = Base_Helpers.createDom("nav", null, null, this.popup);
                        this.buildDetailsPanel(this.detailsDiv);
                        this.buildCloseButton(closeButton);
                        this.popup.style.position = "absolute";
                        this.popup.style.display = "none"
                }
        Netchart_Menu.prototype.doAnimations = function(event) {
        if (this.node == null) {
        return
        }
        if (((this.node != null) && this.node.removed) || ((this.link != null) && this.link.removed)) {
        return this.hideMenu()
        } else {
        if ((this.node != null) && this.scene.modifiedNodes.hasOwnProperty(this.node.id)) {
        return this.updateMenu()
        }
        }
        };
                Netchart_Menu.prototype.previewPointerDown = function(event) {
                return this.hideMenu()
                };
                Netchart_Menu.prototype.previewWheel = function(event) {
                return this.hideMenu()
                };
                Netchart_Menu.prototype.toggleNodeMenu = function(node) {
                if (this.node === node) {
                return this.hideMenu()
                } else {
                return this.showNodeMenu(node)
                }
                };
                Netchart_Menu.prototype.toggleLinkMenu = function(x, y, link) {
                if (this.link === link) {
                return this.hideMenu()
                } else {
                return this.showLinkMenu(x, y, link)
                }
                };
                Netchart_Menu.prototype.showNodeMenu = function(node) {
                if (!this.scene.settings.nodeMenu.enabled) {
                return
                }
                if (this.node === node) {
                return this.updateMenu()
                } else {
                this.hideMenu();
                        return this.showPopup(node, null)
                }
                };
                Netchart_Menu.prototype.showLinkMenu = function(x, y, link) {
                if (!this.scene.settings.linkMenu.enabled) {
                return
                }
                this.x = x;
                        this.y = y;
                        if (this.link === link) {
                return this.updateMenu()
                } else {
                this.hideMenu();
                        return this.showPopup(null, link)
                }
                };
                Netchart_Menu.prototype.showPopup = function(node, link) {
                this.node = node;
                        this.link = link;
                        if (this.node) {
                this.node.locks += 1
                }
                this.buildButtons();
                        this.contents = null;
                        this.updateMenu();
                        this.popup.style.display = "block";
                        this.updateXY()
                };
                Netchart_Menu.prototype.hideMenu = function() {
                if (!this.node && !this.link) {
                return false
                }
                if (this.node) {
                this.node.locks -= 1
                }
                this.node = null;
                        this.link = null;
                        this.popup.style.display = "none";
                        return false
                };
                Netchart_Menu.prototype.updateMenu = function() {
                var callback, contents, curLink, curNode, obj, settings, text;
                        if (this.node != null) {
                settings = this.scene.settings.nodeMenu;
                        obj = this.node
                } else {
                settings = this.scene.settings.linkMenu;
                        obj = this.link
                }
                if (settings.contentsFunction) {
                curNode = this.node;
                        curLink = this.link;
                        callback = function(data) {
                        if (this.node === curNode && this.link === curLink) {
                        this.contents = data;
                                return this.popupValue.innerHTML = data
                        }
                        };
                        text = settings.contentsFunction.call(this.chart.api, obj.data, obj, callback);
                        if (Base_Helpers.isString(text)) {
                contents = text
                } else {
                if (this.contents === null) {
                contents = "<small>" + this.scene.settings.localization.loadingLabel + "</small>"
                } else {
                contents = this.contents
                }
                }
                } else {
                contents = obj.label
                }
                if (contents !== this.contents) {
                this.contents = contents;
                        this.popupValue.innerHTML = contents
                }
                this.updateButtons();
                        if (settings.showData) {
                this.details.innerHTML = JSON.stringify(obj.data, null, "  ");
                        return this.detailsDiv.style.display = "block"
                } else {
                return this.detailsDiv.style.display = "none"
                }
                };
                Netchart_Menu.prototype.updateXY = function() {
                var h, margin, nx, nx0, nx1, ny, ny0, ny1, w, x0, x1, _ref;
                        margin = 12;
                        if (this.node != null) {
                _ref = this.scene.toDisplay(this.node.x, this.node.y), nx = _ref[0], ny = _ref[1];
                        ny0 = ny - this.node.renderRadius - margin;
                        ny1 = ny + this.node.renderRadius + margin;
                        nx0 = nx - this.node.renderRadius - margin;
                        nx1 = nx + this.node.renderRadius + margin
                } else {
                ny0 = ny1 = ny = this.y;
                        nx0 = this.x - margin;
                        nx1 = this.x + margin
                }
                x0 = this.scene.x0;
                        x1 = this.scene.x0 + this.scene.width;
                        w = this.popup.offsetWidth;
                        h = this.popup.offsetHeight;
                        ny = Math.max(Math.min(ny, this.scene.y0 + this.scene.height - h), this.scene.y0);
                        if (nx1 + w <= x1) {
                nx = nx1
                } else {
                if (nx0 - w >= x0) {
                nx = nx0 - w
                } else {
                nx = Math.max(nx0 - w / 2, x0);
                        ny = ny1
                }
                }
                this.popup.style.left = nx + "px";
                        return this.popup.style.top = ny + "px"
                };
                Netchart_Menu.prototype.buildButtons = function() {
                var action, button, div, _i, _len, _ref, _results;
                        this.popupActions.innerHTML = "";
                        this.buttons = [];
                        if (this.node != null) {
                _ref = this.scene.settings.nodeMenu.buttons;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                button = _ref[_i];
                        if (button === "expand") {
                div = Base_Helpers.createDom("a", "DVSL-NC-button-expand", null, this.popupActions);
                        action = this.updateExpandButton
                } else {
                if (button === "focus") {
                div = Base_Helpers.createDom("a", "DVSL-NC-button-focus", null, this.popupActions);
                        action = this.updateFocusButton
                } else {
                if (button === "lock") {
                div = Base_Helpers.createDom("a", "DVSL-NC-button-lock", null, this.popupActions);
                        action = this.updateLockButton
                } else {
                if (button === "hide") {
                div = Base_Helpers.createDom("a", "DVSL-NC-button-hide", null, this.popupActions);
                        action = this.updateHideButton
                }
                }
                }
                }
                div.href = "#";
                        _results.push(this.buttons.push({e: div, a: action}))
                }
                return _results
                }
                };
                Netchart_Menu.prototype.updateButtons = function() {
                var b, _i, _len, _ref;
                        _ref = this.buttons;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                b = _ref[_i];
                        b.a.call(this, b.e)
                }
                };
                Netchart_Menu.prototype.updateExpandButton = function(div) {
                var name;
                        if (!this.node.expanded || this.node.dataLinks.length > this.node.links.length) {
                name = this.scene.settings.localization.menu.expand;
                        div.className = "DVSL-NC-button-expand";
                        div.title = name;
                        div.innerHTML = name;
                        return div.onclick = (function(_this) {
                        return function(e) {
                        _this.chart.expandNode(_this.node.id, 1);
                                return e.preventDefault()
                        }
                        })(this)
                } else {
                name = this.scene.settings.localization.menu.collapse;
                        div.className = "DVSL-NC-button-collapse";
                        div.title = name;
                        div.innerHTML = name;
                        return div.onclick = (function(_this) {
                        return function(e) {
                        _this.chart.collapseNode(_this.node.id);
                                return e.preventDefault()
                        }
                        })(this)
                }
                };
                Netchart_Menu.prototype.updateFocusButton = function(div) {
                var name;
                        if (this.node.focused) {
                name = this.scene.settings.localization.menu.unfocus;
                        div.className = "DVSL-NC-button-unfocus";
                        div.title = name;
                        div.innerHTML = name;
                        return div.onclick = (function(_this) {
                        return function(e) {
                        _this.chart.removeFocusNode(_this.node.id);
                                return e.preventDefault()
                        }
                        })(this)
                } else {
                name = this.scene.settings.localization.menu.focus;
                        div.className = "DVSL-NC-button-focus";
                        div.title = name;
                        div.innerHTML = name;
                        return div.onclick = (function(_this) {
                        return function(e) {
                        _this.chart.addFocusNode(_this.node.id);
                                return e.preventDefault()
                        }
                        })(this)
                }
                };
                Netchart_Menu.prototype.updateLockButton = function(div) {
                var name;
                        if (this.node.userLock) {
                name = this.scene.settings.localization.menu.fixed;
                        div.className = "DVSL-NC-button-lock";
                        div.title = name;
                        div.innerHTML = name;
                        return div.onclick = (function(_this) {
                        return function(e) {
                        _this.chart.unlockNode(_this.node.id);
                                return e.preventDefault()
                        }
                        })(this)
                } else {
                name = this.scene.settings.localization.menu.dynaminc;
                        div.className = "DVSL-NC-button-unlock";
                        div.title = name;
                        div.innerHTML = name;
                        return div.onclick = (function(_this) {
                        return function(e) {
                        _this.chart.lockNode(_this.node.id);
                                return e.preventDefault()
                        }
                        })(this)
                }
                };
                Netchart_Menu.prototype.updateHideButton = function(div) {
                var name;
                        name = this.scene.settings.localization.menu.hide;
                        div.className = "DVSL-NC-button-hide";
                        div.title = name;
                        div.innerHTML = name;
                        return div.onclick = (function(_this) {
                        return function(e) {
                        _this.chart.hideNode(_this.node.id);
                                return e.preventDefault()
                        }
                        })(this)
                };
                Netchart_Menu.prototype.buildCloseButton = function(a) {
                a.title = this.scene.settings.localization.closeButton;
                        a.href = "#";
                        return a.onclick = (function(_this) {
                        return function(e) {
                        _this.hideMenu();
                                return e.preventDefault()
                        }
                        })(this)
                };
                Netchart_Menu.prototype.buildDetailsPanel = function(div) {
                var a, d;
                        a = Base_Helpers.createDom("small", null, "Technical data", div);
                        this.details = d = Base_Helpers.createDom("pre", null, "", div);
                        d.style.display = "none";
                        return a.onclick = function() {
                        if (d.style.display === "none") {
                        return d.style.display = "block"
                        } else {
                        return d.style.display = "none"
                        }
                        }
                };
                return Netchart_Menu
        })();
        var Netchart_InfoPopup;
        Netchart_InfoPopup = (function() {
        function Netchart_InfoPopup(chart) {
        this.chart = chart;
                this.scene = chart.scene;
                this.options = this.scene.settings;
                this.item = null;
                this.x = null;
                this.y = null;
                this.popup = new Base_InfoPopup(chart)
        }
        Netchart_InfoPopup.prototype.previewPointerMove = function(event) {
        return this.onMove(event.x, event.y)
        };
                Netchart_InfoPopup.prototype.doAnimations = function(event) {
                if (this.x !== null && this.y !== null) {
                return this.onMove(this.x, this.y)
                }
                };
                Netchart_InfoPopup.prototype.previewPointerDown = function(event) {
                this.x = this.y = null;
                        return this.setCurrentObject(0, 0, null)
                };
                Netchart_InfoPopup.prototype.previewPointerDrag = function(event) {
                this.x = this.y = null;
                        return this.setCurrentObject(0, 0, null)
                };
                Netchart_InfoPopup.prototype.onPointerOut = function(event) {
                this.x = this.y = null;
                        return this.setCurrentObject(0, 0, null)
                };
                Netchart_InfoPopup.prototype.onMove = function(x, y) {
                var item;
                        this.x = x;
                        this.y = y;
                        if (!this.options.info.enabled) {
                return
                }
                item = this.scene.hoverNode ? this.scene.hoverNode : this.scene.hoverLink;
                        return this.setCurrentObject(x, y, item)
                };
                Netchart_InfoPopup.prototype.setCurrentObject = function(x, y, item) {
                var contents;
                        if (!item) {
                this.item = null;
                        return this.popup.hide()
                } else {
                if (item !== this.item) {
                contents = this.buildContents(item);
                        this.popup.show(x, x, y, contents)
                } else {
                this.popup.updateXY(x, x, y)
                }
                return this.item = item
                }
                };
                Netchart_InfoPopup.prototype.buildContents = function(item) {
                var callback, func;
                        func = null;
                        if (item instanceof Netchart_Node) {
                func = this.options.info.nodeContentsFunction
                } else {
                if (item instanceof Netchart_Link) {
                func = this.options.info.linkContentsFunction
                }
                }
                if (func) {
                callback = (function(_this) {
                return function(contents) {
                if (item === _this.item) {
                return _this.popup.updateContents(contents)
                }
                }
                })(this);
                        return func.call(this.scene.api, item.data, item, callback)
                } else {
                return item.label
                }
                };
                return Netchart_InfoPopup
        })();
        var Timechart_Scrolling, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Scrolling = (function(_super) {
        __extends(Timechart_Scrolling, _super);
                Timechart_Scrolling.prototype.animationPriority = 1000;
                Timechart_Scrolling.prototype.animationUnit = null;
                Timechart_Scrolling.prototype.targetUnit = null;
                Timechart_Scrolling.prototype.dragStartBar0 = null;
                Timechart_Scrolling.prototype.dragStartBar1 = null;
                function Timechart_Scrolling(chart) {
                Timechart_Scrolling.__super__.constructor.call(this, chart);
                        this.s = new Timechart_TimeSetup(this.scene.settings)
                }
        Timechart_Scrolling.prototype.setTimeRangeSnap = function(from, to, origin, desiredUnit, animate, notifyOrigin, scroll, scale) {
        var anchor, period, unit, _ref;
                _ref = this.snap(from, to, origin, desiredUnit, scroll, scale), from = _ref[0], to = _ref[1], unit = _ref[2], period = _ref[3], anchor = _ref[4];
                return this.setTimeRange(from, to, unit, animate, notifyOrigin, anchor, period)
        };
                Timechart_Scrolling.prototype.computeDisplayPeriod = function(period, anchor, unitStr, dataFrom, dataTo) {
                var from, to, unit, _ref;
                        _ref = this.s.tryComputeDisplayPeriod(period, anchor, unitStr, dataFrom, dataTo, this.scene, this.scene.getCurTime()), from = _ref[0], to = _ref[1], unit = _ref[2];
                        if (from === null || to === null) {
                return[null, null, null]
                }
                return this.computeTimeRangeExtend(from, to, unit)
                };
                Timechart_Scrolling.prototype.computeTimeRangeExtend = function(from, to, unit) {
                var _ref;
                        if (unit == null) {
                unit = this.s.computeDisplayUnit(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, from, to, this.scene)
                }
                from = unit.roundTimeDown(from);
                        to = unit.roundTimeUp(to);
                        if (to === from) {
                to = unit.add(to, 1)
                }
                if (this.scene.settings.interaction.scrolling.noData != null) {
                _ref = this._preventOverscroll(from, to, unit), from = _ref[0], to = _ref[1]
                }
                return[from, to, unit]
                };
                Timechart_Scrolling.prototype.setTimeRange = function(from, to, unit, animate, notifyOrigin, anchor, period) {
                if (anchor == null) {
                anchor = null
                }
                if (period == null) {
                period = null
                }
                if (!(from < to || unit)) {
                return
                }
                from = Math.round(from);
                        to = Math.round(to);
                        if ((unit == null) && from < to) {
                unit = this.s.computeDisplayUnit(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, from, to, this.scene)
                }
                this.scene.anchor = anchor;
                        this.scene.period = period;
                        this.targetUnit = unit;
                        this.animationUnit = (unit == null) || (this.scene.displayUnit && unit.toString() !== this.scene.displayUnit.toString()) ? null : unit;
                        this.goToPosition(from, to, animate);
                        this.events.notifySceneChanges({time: true});
                        if (notifyOrigin) {
                return this.chart.notifyTimeChanged(from, to, unit, notifyOrigin)
                }
                };
                Timechart_Scrolling.prototype.zoomOut = function(displayPeriod, from, to, animate, notifyOrigin) {
                var origin, _ref;
                        origin = (from + to) / 2;
                        _ref = this.computeZoomOut(from, to, displayPeriod), from = _ref[0], to = _ref[1];
                        return this.setTimeRangeSnap(from, to, origin, null, animate, notifyOrigin, false, true)
                };
                Timechart_Scrolling.prototype.zoomIn = function(unit, center, from, to, animate, notifyOrigin) {
                var _ref;
                        if (center === null) {
                center = (from + to) / 2
                }
                _ref = this.onZoomIn(from, to, center, 0.5), from = _ref[0], to = _ref[1];
                        return this.setTimeRangeSnap(from, to, center, unit, animate, notifyOrigin, false, true)
                };
                Timechart_Scrolling.prototype.xyInArea = function(x, y) {
                return this.scene.xyInChart(x, y)
                };
                Timechart_Scrolling.prototype.xyToPosition = function(x, y) {
                return this.scene.xToTime(x)
                };
                Timechart_Scrolling.prototype.onZoomOut = function(from, to, origin, scale) {
                if (scale == null) {
                scale = null
                }
                if (scale) {
                return Timechart_Scrolling.__super__.onZoomOut.call(this, from, to, origin, scale)
                } else {
                return this.computeZoomOut(from, to, null)
                }
                };
                Timechart_Scrolling.prototype.onZoomIn = function(from, to, center, scale) {
                var _ref;
                        if (scale == null) {
                scale = null
                }
                if (scale) {
                return Timechart_Scrolling.__super__.onZoomIn.call(this, from, to, center, scale)
                } else {
                if (this.dragStartBar0) {
                from = this.dragStartBar0;
                        to = this.dragStartBar1;
                        if (to - from > this.scene.timeEnd - this.scene.timeStart) {
                _ref = this.scene.getClickBar(center), from = _ref[0], to = _ref[1]
                }
                }
                }
                return[from, to]
                };
                Timechart_Scrolling.prototype.onScroll = function(from, to, direction) {
                return this.s.scroll(from, to, this.scene.displayUnit, direction, 1, "page")
                };
                Timechart_Scrolling.prototype.onGoHome = function(from, to) {
                var dataTo, dt;
                        dataTo = this.scene.getDisplayLimits()[1];
                        if (dataTo === null) {
                return[from, to]
                }
                this.scene.anchor = "newestData";
                        dt = to - from;
                        return[dataTo - dt, dataTo, dataTo]
                };
                Timechart_Scrolling.prototype.onStartDragging = function(oldFrom, oldTo, pos) {
                var _ref;
                        this.scene.anchor = null;
                        return _ref = this.scene.getClickBar(pos), this.dragStartBar0 = _ref[0], this.dragStartBar1 = _ref[1], _ref
                };
                Timechart_Scrolling.prototype.onSnapWhileDragging = function(from, to, origin, isScrolling, isScaling) {
                var unit, _ref, _ref1;
                        if (this.scene.settings.interaction.scrolling.noData === ("block" != null)) {
                if (isScaling) {
                _ref = this._preventOverscale(from, to, origin), from = _ref[0], to = _ref[1]
                }
                if (typeof unit === "undefined" || unit === null) {
                unit = this.s.computeDisplayUnit(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, from, to, this.scene)
                }
                if (isScrolling) {
                _ref1 = this._preventOverscroll(from, to, unit), from = _ref1[0], to = _ref1[1]
                }
                }
                this.events.notifySceneChanges({time: true});
                        return[from, to]
                };
                Timechart_Scrolling.prototype.onSnapAfterDragging = function(from, to, origin, isScrolling, isScaling) {
                var anchor, period, unit, _ref, _ref1;
                        _ref = this.snap(from, to, origin, unit, isScrolling, isScaling), from = _ref[0], to = _ref[1], unit = _ref[2], period = _ref[3], anchor = _ref[4];
                        this.targetUnit = unit;
                        this.animationUnit = !isScaling || (unit && this.scene.displayUnit.isEqual(unit)) ? this.scene.displayUnit : null;
                        this.scene.period = period;
                        this.scene.anchor = anchor;
                        _ref1 = [null, null], this.dragStartBar0 = _ref1[0], this.dragStartBar1 = _ref1[1];
                        this.events.notifySceneChanges({time: true});
                        this.chart.notifyTimeChanged(from, to, unit, "user");
                        return[from, to]
                };
                Timechart_Scrolling.prototype.onPositionChanged = function(from, to) {
                var unit;
                        unit = this.animationUnit != null ? this.animationUnit : this.s.computeDisplayUnit(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, from, to, this.scene);
                        this.scene.setTimeRange(from, to, unit);
                        return this.events.notifySceneChanges({time: true})
                };
                Timechart_Scrolling.prototype.onAnimationDone = function(from, to) {
                var unit;
                        if (this.targetUnit) {
                unit = this.targetUnit != null ? this.targetUnit : this.s.computeDisplayUnit(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, from, to, this.scene);
                        this.scene.setTimeRange(from, to, unit)
                }
                this.targetUnit = null;
                        this.animationUnit = null;
                        return this.chart.notifyAnimationDone()
                };
                Timechart_Scrolling.prototype.computeZoomOut = function(from, to, unit) {
                var p;
                        if (unit == null) {
                p = this.s.getBiggerDisplayPeriod(this.scene.timeStart, this.scene.timeEnd);
                        if (p != null) {
                unit = p.displayPeriod
                }
                }
                if (unit == null) {
                return[from, to]
                }
                from = unit.roundTimeDown(from);
                        to = unit.roundTimeUp(to);
                        return[from, to]
                };
                Timechart_Scrolling.prototype.snap = function(from, to, origin, desiredUnit, scroll, scale) {
                var anchor, center, dataFrom, dataTo, from0, numberOfUnits, oldFrom, oldTo, period, pfrom, pto, pu, range, snapMode, snapUnit, sp, to0, unit, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
                        if (desiredUnit == null) {
                desiredUnit = null
                }
                if ((this.scene.settings.interaction.scrolling.noData != null) && scale) {
                if (scale) {
                _ref = this._preventOverscale(from, to, origin), from = _ref[0], to = _ref[1]
                }
                }
                if (desiredUnit) {
                unit = desiredUnit
                } else {
                if (!scale) {
                unit = this.scene.displayUnit
                } else {
                oldFrom = this.dragStartFrom != null ? this.dragStartFrom : this.scene.timeStart;
                        oldTo = this.dragStartTo != null ? this.dragStartTo : this.scene.timeEnd;
                        unit = this.s.computeDisplayUnit(oldFrom, oldTo, this.scene.displayUnit, from, to, this.scene)
                }
                }
                if ((this.scene.settings.interaction.scrolling.noData != null) && (scroll || scale)) {
                _ref1 = this._preventOverscroll(from, to, unit), from = _ref1[0], to = _ref1[1]
                }
                from0 = from;
                        to0 = to;
                        period = scale ? null : this.scene.period;
                        anchor = this.scene.anchor;
                        snapMode = this.scene.settings.interaction.snapMode;
                        if (snapMode) {
                if (snapMode === "displayUnit") {
                snapUnit = unit
                } else {
                if (snapMode === "multiperiod" || snapMode === "period") {
                range = to - from;
                        _ref2 = this.scene.getDisplayLimits(), dataFrom = _ref2[0], dataTo = _ref2[1];
                        if (dataFrom != null) {
                range = Math.min(range, dataTo - dataFrom)
                }
                sp = this.s.getClosestDisplayPeriod(range, this.scene.majorTimeUnit, snapMode === "multiperiod");
                        if (sp.displayUnit != null) {
                unit = sp.displayUnit
                }
                snapUnit = sp.displayPeriod;
                        period = sp.displayPeriod;
                        anchor = sp.displayAnchor || anchor
                }
                }
                if (snapMode === "period") {
                from = snapUnit.roundTimeDown(origin);
                        to = snapUnit.add(from, 1)
                } else {
                numberOfUnits = Math.max(snapUnit.numberOfUnits(from, to), 1);
                        center = (from + to) / 2;
                        if (center > origin) {
                from = snapUnit.roundTimeDown(from)
                } else {
                from = snapUnit.roundTimeUp(from)
                }
                to = snapUnit.add(from, numberOfUnits)
                }
                _ref3 = this.scene.settings.toolbars.advanced.periods;
                        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                period = _ref3[_i];
                        _ref4 = this.computeDisplayPeriod(period.displayPeriod, period.displayAnchor, null, this.scene.mainData.dataFrom, this.scene.mainData.dataTo), pfrom = _ref4[0], pto = _ref4[1], pu = _ref4[2];
                        if ((pfrom != null) && (pto != null) && Math.abs(pfrom - from0) + Math.abs(pto - to0) < Math.abs(from - from0) + Math.abs(to - to0)) {
                from = pfrom;
                        to = pto;
                        unit = pu;
                        period = period.displayPeriod;
                        if (!anchor && period.displayAnchor) {
                anchor = period.displayAnchor
                }
                }
                }
                } else {
                from = Math.round(from);
                        to = Math.round(to)
                }
                return[from, to, unit, period, anchor]
                };
                Timechart_Scrolling.prototype._snapToAnchor = function(from, to, unit) {
                var direction, dt, time;
                        if (this.scene.anchor === "now") {
                time = this.scene.getCurTime();
                        direction = - 1
                } else {
                if (this.scene.anchor === "newestData") {
                time = this.scene.mainData.dataTo;
                        direction = - 1
                }
                }
                if ((time != null) && direction === - 1 && to > time) {
                dt = time - to;
                        to = unit.roundTimeUp(to + dt);
                        from = unit.roundTimeUp(from + dt)
                }
                return[from, to]
                };
                Timechart_Scrolling.prototype._preventOverscroll = function(from, to, unit) {
                var dataFrom, dataTo, _ref;
                        if (unit == null) {
                unit = this.scene.displayUnit
                }
                _ref = this.scene.getDisplayLimits(), dataFrom = _ref[0], dataTo = _ref[1];
                        if (!((dataFrom != null) && (dataTo != null))) {
                return[from, to]
                }
                return this.s.preventOverscroll(unit, from, to, dataFrom, dataTo)
                };
                Timechart_Scrolling.prototype._preventOverscale = function(from, to, center) {
                var dataFrom, dataTo, df, dt, units, _ref;
                        _ref = this.scene.getDisplayLimits(), dataFrom = _ref[0], dataTo = _ref[1];
                        df = - Infinity;
                        dt = Infinity;
                        if ((dataFrom != null) && (dataTo != null)) {
                df = dataFrom;
                        dt = dataTo
                }
                units = this.scene.settings.area.displayUnitsParsed;
                        return this.s.preventOverscale(this.scene, units, center, from, to, df, dt)
                };
                return Timechart_Scrolling
        })(Linearchart_Scrolling);
        var Timechart_Selection;
        Timechart_Selection = (function() {
        Timechart_Selection.prototype.animationPriority = 0;
                Timechart_Selection.prototype.chart = null;
                Timechart_Selection.prototype.selectStart = null;
                Timechart_Selection.prototype.selectingPointer = null;
                Timechart_Selection.prototype.isSelecting = false;
                Timechart_Selection.prototype.lastX = 0;
                Timechart_Selection.prototype.lastY = 0;
                Timechart_Selection.prototype.roundAround = false;
                function Timechart_Selection(chart) {
                this.chart = chart;
                        this.scene = chart.scene
                }
        Timechart_Selection.prototype.onSceneChange = function(event) {
        var en, st, _ref;
                if ((event.changes.time || event.changes.bounds) && (this.selectStart != null)) {
        event.x = this.lastX;
                event.y = this.lastY;
                event.identifier = this.selectingPointer;
                this.onPointerDrag(event)
        }
        if (event.changes.selection) {
        return _ref = this.snapSelection(), st = _ref[0], en = _ref[1], _ref
        }
        };
                Timechart_Selection.prototype.paintScene = function(event) {
                var g, h, h2, leftText, rightText, textWidth, x0, xL, xR, y0, y1, y2;
                        if (!(this.scene.selectionStart && this.scene.selectionEnd)) {
                return
                }
                x0 = Math.round(this.scene.x0);
                        y0 = Math.round(this.scene.y0);
                        y1 = Math.round(y0 + this.scene.height);
                        y2 = Math.round(y0 + this.scene.height + this.scene.bottomAxisSize);
                        xL = Math.round(this.scene.timeToX(this.scene.selectionStart));
                        xR = Math.round(this.scene.timeToX(this.scene.selectionEnd));
                        h = this.scene.height + this.scene.bottomAxisSize;
                        h2 = this.scene.bottomAxisSize;
                        leftText = moment(this.scene.selectionStart).utc().format(this.scene.minorTimeFormat);
                        rightText = moment(this.scene.selectionEnd).utc().format(this.scene.minorTimeFormat);
                        g = event.context;
                        textWidth = g.measureText(leftText).width;
                        Base_Graphics.pushClip(g, x0, y0, this.scene.width, h);
                        g.beginPath();
                        g.moveTo(xL, y0);
                        g.lineTo(xL, y2);
                        g.moveTo(xR, y0);
                        g.lineTo(xR, y2);
                        Base_Graphics.stroke(g, this.scene.settings.area.style.selection);
                        Base_Graphics.rectStyle(g, this.scene.settings.area.style.selection);
                        g.fillRect(xL, y0, xR - xL, h);
                        Base_Graphics.textStyle(g, this.scene.settings.area.style.selectionLabel);
                        g.textBaseline = "top";
                        if (textWidth * 3.3 < xR - xL) {
                g.textAlign = "start";
                        g.fillText(leftText, xL + 2, y0 + 2);
                        g.textAlign = "end";
                        g.fillText(rightText, xR - 2, y0 + 2)
                } else {
                g.textAlign = "end";
                        g.fillText(leftText, xL - 2, y0 + 2);
                        g.textAlign = "start";
                        g.fillText(rightText, xR + 2, y0 + 2)
                }
                return Base_Graphics.popClip(g)
                };
                Timechart_Selection.prototype.onPointerMove = function(event) {
                var s0X, s1X;
                        if (!this.scene.settings.interaction.selection.enabled) {
                return
                }
                if (this.scene.xyInBottom(event.x, event.y)) {
                event.cursor = "text"
                }
                if (this.scene.selectionStart && this.scene.selectionEnd && this.scene.xyInChartOrBottom(event.x, event.y) && this.scene.timeStart < this.scene.timeEnd) {
                s0X = this.scene.timeToX(this.scene.selectionStart);
                        s1X = this.scene.timeToX(this.scene.selectionEnd);
                        if (Math.abs(s1X - event.x) <= this.scene.settings.interaction.selection.grabThreshold) {
                event.cursor = "e-resize";
                        return event.consumed = true
                } else {
                if (Math.abs(s0X - event.x) <= this.scene.settings.interaction.selection.grabThreshold) {
                event.cursor = "w-resize";
                        return event.consumed = true
                }
                }
                }
                };
                Timechart_Selection.prototype.onPointerDown = function(event) {
                var s0X, s1X, x0, x1;
                        if ((!this.scene.xyInChartOrBottom(event.x, event.y)) || (this.selectingPointer != null) || (!this.scene.settings.interaction.selection.enabled)) {
                return
                }
                this.lastX = event.x;
                        this.lastY = event.y;
                        if ((this.scene.selectionStart != null) || (this.scene.selectionEnd != null)) {
                x0 = this.scene.timeToX(this.scene.selectionStart);
                        x1 = this.scene.timeToX(this.scene.selectionEnd);
                        s0X = Math.abs(x0 - event.x);
                        s1X = Math.abs(x1 - event.x);
                        if (s0X < this.scene.settings.interaction.selection.grabThreshold && s0X <= s1X) {
                this.selectingPointer = event.identifier;
                        this.selectStart = this.scene.selectionEnd;
                        this.selectingPointer = event.identifier;
                        event.consumed = true;
                        this.roundAround = true;
                        this.isSelecting = true;
                        return
                }
                if (s1X < this.scene.settings.interaction.selection.grabThreshold && s1X <= s0X) {
                this.selectStart = this.scene.selectionStart;
                        this.selectingPointer = event.identifier;
                        event.consumed = true;
                        this.roundAround = true;
                        this.isSelecting = true;
                        return
                }
                }
                if (this.scene.xyInBottom(event.x, event.y)) {
                this.selectingPointer = event.identifier;
                        this.selectStart = this.scene.xToTime(event.x);
                        this.roundAround = false;
                        if (event.x >= x0 && event.x <= x1) {
                return this.isSelecting = false
                } else {
                this.scene.selectionStart = null;
                        this.scene.selectionEnd = null;
                        event.changes.selection = true;
                        return this.isSelecting = false
                }
                }
                };
                Timechart_Selection.prototype.onPointerDrag = function(event) {
                var filling, t0, t1, time;
                        if ((this.selectStart == null) || this.selectingPointer !== event.identifier) {
                return
                }
                this.isSelecting = true;
                        this.lastX = event.x;
                        this.lastY = event.y;
                        time = this.scene.xToTime(event.x);
                        filling = Math.abs(this.selectStart - time);
                        if (this.selectStart < time) {
                t0 = Math.max(this.selectStart - filling, this.scene.snapTimeDown(this.selectStart));
                        t1 = time
                } else {
                t0 = time;
                        t1 = Math.min(this.selectStart + filling, this.scene.snapTimeUp(this.selectStart))
                }
                this.scene.selectionStart = t0;
                        this.scene.selectionEnd = t1;
                        event.changes.selection = true;
                        return event.consumed = true
                };
                Timechart_Selection.prototype.onPointerUp = function(event) {
                var en, st, _ref;
                        if ((this.selectStart == null) || this.selectingPointer !== event.identifier) {
                return
                }
                if (this.isSelecting) {
                _ref = this.snapSelection(), st = _ref[0], en = _ref[1];
                        if (st === en) {
                st = null;
                        en = null
                }
                this.scene.selectionStart = st;
                        this.scene.selectionEnd = en;
                        this.chart.notifySelectionChanged("user");
                        event.changes.selection = true;
                        event.consumed = true
                }
                this.isSelecting = false;
                        this.selectStart = null;
                        return this.selectingPointer = null
                };
                Timechart_Selection.prototype.onPointerCancel = function(event) {
                return this.onPointerUp(event)
                };
                Timechart_Selection.prototype.snapSelection = function() {
                var en, st;
                        if (this.scene.selectionStart) {
                if (this.roundAround) {
                st = this.scene.snapTimeRound(this.scene.selectionStart);
                        en = this.scene.snapTimeRound(this.scene.selectionEnd)
                } else {
                st = this.scene.snapTimeDown(this.scene.selectionStart);
                        en = this.scene.snapTimeUp(this.scene.selectionEnd)
                }
                } else {
                st = null;
                        en = null
                }
                return[st, en]
                };
                return Timechart_Selection
        })();
        var Timechart_InfoPopup, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_InfoPopup = (function(_super) {
        __extends(Timechart_InfoPopup, _super);
                function Timechart_InfoPopup(chart) {
                Timechart_InfoPopup.__super__.constructor.call(this, chart);
                        this.periodCount = 0
                }
        Timechart_InfoPopup.prototype.doAnimations = function(event) {
        var t0, t1;
                if (this.chart.selection.isSelecting && this.scene.selectionStart) {
        t0 = this.scene.selectionStart;
                t1 = this.scene.selectionEnd;
                return this.showInfoPopup(t0, t1, this.buildContent(t0, t1), event)
        }
        };
                Timechart_InfoPopup.prototype.getPopupMouseMoved = function(x, y, prevT0, prevT1, prevContents) {
                var content, g, numBars, t, t0, t1;
                        if (!(!this.scene.displayUnit || this.scene.xyInChartOrBottom(x, y))) {
                return null
                }
                t = this.scene.xToTime(x);
                        g = this.scene.getClickRange(t, y);
                        if (g == null) {
                return null
                }
                t0 = g[0], t1 = g[1], numBars = g[2];
                        if (t0 === prevT0 && t1 === prevT1) {
                return[t0, t1, prevContents]
                }
                if (!((t0 != null) && (t1 != null))) {
                return null
                }
                content = this.buildContent(t0, t1);
                        return[t0, t1, content]
                };
                Timechart_InfoPopup.prototype.buildContent = function(t0, t1, info) {
                var biggerUnit, count, date, dateHtml, from, o, t0m, t1m, to, top, unit, unitName, valueHtml;
                        unit = this.scene.displayUnit;
                        info = this.chart.renderer.exportData(t0, t1);
                        count = Math.ceil(unit.numberOfUnits(t0, t1)) * unit.count;
                        unitName = count === 1 ? this.scene.settings.localization.timeUnitsNames[unit.unit] : this.scene.settings.localization.timeUnitsNamesPlural[unit.unit];
                        if (count === 1) {
                t0m = moment(t0).utc();
                        date = t0m.format(this.scene.settings.localization.infoDates.fullTimeFormats[unit.unit]);
                        dateHtml = "" + date
                } else {
                if (unit.unit === "d" || unit.unit === "M" || unit.unit === "y" || unit.unit === "ms") {
                t1 -= 1
                }
                t0m = moment(t0).utc();
                        t1m = moment(t1).utc();
                        biggerUnit = unit.getBigger() || unit;
                        if (unit.unit !== "y" && biggerUnit.roundTimeDown(t0) === biggerUnit.roundTimeDown(t1)) {
                top = t0m.format(this.scene.settings.localization.infoDates.majorTimeFormats[unit.unit]);
                        from = t0m.format(this.scene.settings.localization.infoDates.minorTimeFormats[unit.unit]);
                        to = t1m.format(this.scene.settings.localization.infoDates.minorTimeFormats[unit.unit]);
                        dateHtml = "" + from + " - " + to + " " + top
                } else {
                from = t0m.format(this.scene.settings.localization.infoDates.fullTimeFormats[unit.unit]);
                        to = t1m.format(this.scene.settings.localization.infoDates.fullTimeFormats[unit.unit]);
                        dateHtml = "" + from + " - " + to
                }
                }
                if (this.scene.settings.info.contentFunction) {
                valueHtml = this.scene.settings.info.contentFunction(info)
                } else {
                valueHtml = this.buildValues(info)
                }
                o = "<em></em><strong>" + dateHtml + ("<small>(" + count + " " + unitName + ")</small></strong>");
                        o += valueHtml;
                        return o
                };
                Timechart_InfoPopup.prototype.buildValues = function(info) {
                var color, group, out, param, series, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
                        out = "";
                        for (_i = 0, _len = info.length; _i < _len; _i++) {
                group = info[_i];
                        if (group.name && group.data.length > 1) {
                out += "<h3>" + group.name + "</h3>"
                }
                out += '<table cellspacing="0">';
                        _ref = group.data;
                        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                series = _ref[_j];
                        out += "<tr><td";
                        color = series.config.style.lineColor || series.config.style.fillColor;
                        if (color) {
                out += ' style="color: ' + color + '"'
                }
                out += "> " + (series.name || group.name) + "</td>";
                        if (!series.values) {
                out += "<td>No data</td>"
                } else {
                if (series.values.count > 1 && this.scene.settings.info.aggregations && this.scene.settings.info.aggregations.length > 0) {
                _ref1 = this.scene.settings.info.aggregations;
                        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                param = _ref1[_k];
                        out += ("<td>" + param + "</td><td>") + Base_Helpers.numberFormat(series.values[param]) + "</td>"
                }
                } else {
                out += "<td>" + Base_Helpers.numberFormat(series.values.sum) + "</td>"
                }
                }
                out += "</tr>"
                }
                out += "</table>"
                }
                return out
                };
                return Timechart_InfoPopup
        })(Linearchart_InfoPopup);
        var Timechart_ClickNotifier;
        Timechart_ClickNotifier = (function() {
        Timechart_ClickNotifier.prototype.animationPriority = 0;
                Timechart_ClickNotifier.prototype.chart = null;
                Timechart_ClickNotifier.prototype.scene = null;
                Timechart_ClickNotifier.prototype.pointer = null;
                function Timechart_ClickNotifier(chart) {
                this.chart = chart;
                        this.scene = this.chart.scene
                }
        Timechart_ClickNotifier.prototype.previewPointerMove = function(event) {
        return this.pointer = null
        };
                Timechart_ClickNotifier.prototype.previewPointerDown = function(event) {
                return this.pointer = event.identifier
                };
                Timechart_ClickNotifier.prototype.onClick = function(event) {
                var range, t;
                        if (event.identifier === this.pointer) {
                range = this.getClickRange(event.x, event.y);
                        if (range != null) {
                t = this.scene.xToTime(event.x);
                        if ((this.scene.selectionStart != null) && (this.scene.selectionStart > t || this.scene.selectionEnd < t)) {
                this.scene.selectionStart = null;
                        this.scene.selectionEnd = null;
                        this.chart.notifySelectionChanged("user");
                        event.changes.selection = true;
                        return event.consumed = true
                } else {
                event.clickStart = range[0];
                        event.clickEnd = range[1];
                        this.chart.notifyClick(event);
                        return event.consumed = true
                }
                }
                }
                };
                Timechart_ClickNotifier.prototype.onRightClick = function(event) {
                var range, ue;
                        range = this.getClickRange(event.x, event.y);
                        if (range != null) {
                event.clickStart = range[0];
                        event.clickEnd = range[1];
                        ue = this.chart.notifyRightClick(event);
                        if (ue.defaultPrevented) {
                return event.consumed = true
                }
                }
                };
                Timechart_ClickNotifier.prototype.onDoubleClick = function(event) {
                var range;
                        range = this.getClickRange(event.x, event.y);
                        if (range != null) {
                event.clickStart = range[0];
                        event.clickEnd = range[1];
                        this.chart.notifyDoubleClick(event);
                        return event.consumed = true
                }
                };
                Timechart_ClickNotifier.prototype.getClickRange = function(x, y) {
                if (!this.scene.xyInChartOrBottom(x, y)) {
                return null
                }
                return this.scene.getClickRange(this.scene.xToTime(x), y)
                };
                return Timechart_ClickNotifier
        })();
        var Timechart_TimeUpdater, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        };
        Timechart_TimeUpdater = (function() {
        function Timechart_TimeUpdater(chart) {
        var m;
                this.chart = chart;
                this.dataTick = __bind(this.dataTick, this);
                this.timerTick = __bind(this.timerTick, this);
                this.animationPriority = 1050;
                this.settings = this.chart.settings;
                this.scene = this.chart.scene;
                this.events = this.chart.events;
                if (this.settings.currentTime.enabled) {
        m = new Linearchart_Marker();
                m.time = this.scene.getCurTime();
                m.style = this.scene.settings.currentTime.style;
                m.label = this.scene.settings.currentTime.label;
                this.scene.markers.push(m)
        }
        if (this.settings.advanced.timeUpdateInterval) {
        setTimeout(this.timerTick, this.settings.advanced.timeUpdateInterval)
        }
        if (this.settings.advanced.dataUpdateInterval) {
        setTimeout(this.dataTick, this.settings.advanced.dataUpdateInterval)
        }
        }
        Timechart_TimeUpdater.prototype.doAnimations = function(event) {
        this.updateCurTime();
                if (event.changes.data) {
        return this.updateVisiblePeriod()
        }
        };
                Timechart_TimeUpdater.prototype.timerTick = function() {
                if (this.chart.removed) {
                return
                }
                this.chart.updateSize();
                        if (this.updateCurTime()) {
                this.events.notifySceneChanges({markers: true})
                }
                this.updateVisiblePeriod();
                        return setTimeout(this.timerTick, this.settings.advanced.timeUpdateInterval)
                };
                Timechart_TimeUpdater.prototype.updateVisiblePeriod = function() {
                var curTime, dt, latestDataTime, timeEnd, timeStart, unit;
                        if (!(this.scene.displayUnit && (this.scene.timeEnd != null))) {
                return
                }
                curTime = this.scene.getCurTime();
                        latestDataTime = this.scene.getDataLimits()[1];
                        timeEnd = this.scene.timeEnd;
                        timeStart = this.scene.timeStart;
                        if (this.settings.area.followAnchor) {
                if (this.scene.anchor === "now" && timeEnd < curTime) {
                unit = this.scene.displayUnit;
                        dt = unit.roundTimeUp(curTime) - timeEnd;
                        this.chart.scrolling.setTimeRangeSnap(timeStart + dt, timeEnd + dt, timeEnd + dt, this.scene.displayUnit, true, "timer", true, false)
                }
                if (this.scene.anchor === "newestData" && timeEnd < latestDataTime) {
                unit = this.scene.displayUnit;
                        dt = unit.roundTimeUp(latestDataTime) - timeEnd;
                        return this.chart.scrolling.setTimeRangeSnap(timeStart + dt, timeEnd + dt, timeEnd + dt, this.scene.displayUnit, true, "timer", true, false)
                }
                }
                };
                Timechart_TimeUpdater.prototype.updateCurTime = function() {
                var curTime;
                        if (!(this.settings.currentTime.enabled && this.scene.displayUnit)) {
                return false
                }
                curTime = this.scene.getCurTime();
                        this.scene.markers[0].time = curTime;
                        return this.scene.timeStart <= curTime && this.scene.timeEnd >= curTime
                };
                Timechart_TimeUpdater.prototype.dataTick = function() {
                var callback, curTime, data, id, _ref;
                        if (this.chart.removed) {
                return
                }
                if (this.scene.displayUnit) {
                curTime = this.scene.getCurTime();
                        callback = (function(_this) {
                        return function() {
                        _this.updateVisiblePeriod();
                                return _this.events.notifySceneChanges({data: true})
                        }
                        })(this);
                        _ref = this.scene.data;
                        for (id in _ref) {
                data = _ref[id];
                        data.updateData(this.scene.displayUnit.unit, curTime, callback)
                }
                }
                return setTimeout(this.dataTick, this.settings.advanced.dataUpdateInterval)
                };
                return Timechart_TimeUpdater
        })();
        var Timechart_TimeAxis;
        Timechart_TimeAxis = (function() {
        Timechart_TimeAxis.prototype.scene = null;
                Timechart_TimeAxis.prototype.context = null;
                Timechart_TimeAxis.prototype.tt = null;
                Timechart_TimeAxis.prototype.curSceneScale = 0;
                Timechart_TimeAxis.prototype.minorFormat = null;
                Timechart_TimeAxis.prototype.majorFormat = null;
                Timechart_TimeAxis.prototype.minorTimeUnit = null;
                Timechart_TimeAxis.prototype.majorTimeUnit = null;
                Timechart_TimeAxis.prototype.minorLabelHeight = null;
                Timechart_TimeAxis.prototype.majorLabelHeight = null;
                Timechart_TimeAxis.prototype.minorLabelWidths = null;
                Timechart_TimeAxis.prototype.minorLabelBallonWidths = null;
                Timechart_TimeAxis.prototype.majorLabelWidths = null;
                Timechart_TimeAxis.prototype.multiYearWidth = null;
                Timechart_TimeAxis.prototype.majorSlices = null;
                Timechart_TimeAxis.prototype.minorSlices = null;
                function Timechart_TimeAxis(chart) {
                this.chart = chart;
                        this.scene = this.chart.scene;
                        this.tt = new Timechart_TimeSetup(this.scene);
                        this.options = this.scene.settings.timeAxis
                }
        Timechart_TimeAxis.prototype.computeTextSizes = function(g) {
        var unit, w, widestTime, _i, _j, _len, _len1, _ref, _ref1;
                widestTime = moment(218342562955000).utc();
                g.save();
                Base_Graphics.textStyle(g, this.scene.settings.timeAxis.style.minorTimeLabel);
                this.minorLabelHeight = g.measureText("M").width;
                this.minorLabelWidths = {};
                this.minorLabelBallonWidths = {};
                _ref = Base_TimeStep.knownUnits;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        unit = _ref[_i];
                w = g.measureText(widestTime.format(this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[unit])).width;
                this.minorLabelWidths[unit] = w;
                this.minorLabelBallonWidths[unit] = w + this.minorLabelHeight * 1.2
        }
        Base_Graphics.textStyle(g, this.scene.settings.timeAxis.style.majorTimeLabel);
                this.majorLabelHeight = g.measureText("M").width;
                this.majorLabelWidths = {};
                _ref1 = Base_TimeStep.knownUnits;
                for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        unit = _ref1[_j];
                this.majorLabelWidths[unit] = g.measureText(widestTime.format(this.scene.settings.localization.timeAxisDates.majorLabelTimeFormats[unit])).width + this.majorLabelHeight
        }
        this.multiYearWidth = g.measureText("8888 - 8888").width + this.majorLabelHeight;
                return g.restore()
        };
                Timechart_TimeAxis.prototype.multiples = {s: [1, 2, 5, 15, 30], m: [1, 2, 5, 15, 30], h: [1, 3, 6, 12, 24], d: [1, 2, 5, 10], w: [1, 5, 10, 20], M: [1, 3, 6], y: [1, 10, 100, 1000]};
                Timechart_TimeAxis.prototype.getLabelWidth = function(step) {
                if (step.unit === "y" && step.count > 1) {
                return this.multiYearWidth
                } else {
                return this.majorLabelWidths[step.unit]
                }
                };
                Timechart_TimeAxis.prototype.computeLabels = function(displayUnit) {
                var baseUnit, chartDt, m, majorUnit, minorUnit, nextUnit, s, unit, unit2, unitDt, unitSpacing, _i, _j, _len, _len1, _ref, _ref1;
                        s = new Timechart_TimeSetup(this.scene.settings);
                        chartDt = this.scene.timeEnd - this.scene.timeStart;
                        nextUnit = s.toBiggerDisplayPeriod(displayUnit);
                        if (nextUnit != null) {
                baseUnit = new Base_TimeStep("s", 1);
                        if (nextUnit.isSmaller(baseUnit)) {
                nextUnit = baseUnit
                }
                unit = null;
                        while (((unit == null) && (nextUnit != null)) || ((nextUnit != null) && nextUnit.approxTime() <= chartDt * 0.5) || ((unit != null) && (nextUnit != null) && unit.approxTime() < this.scene.dxToDtime(this.getLabelWidth(unit)))) {
                unit = nextUnit;
                        nextUnit = s.toBiggerDisplayPeriod(nextUnit)
                }
                }
                if (nextUnit == null) {
                unit = displayUnit.unit === "y" ? displayUnit : new Base_TimeStep("y", 1);
                        _ref = this.multiples.y;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                m = _ref[_i];
                        unit = new Base_TimeStep("y", m);
                        if (unit.approxTime() > this.scene.dxToDtime(this.getLabelWidth(unit))) {
                break
                }
                }
                }
                majorUnit = unit;
                        minorUnit = null;
                        unit = this.scene.displayUnit.clone();
                        unit2 = new Base_TimeStep(Base_TimeStep.toSmallerUnit[majorUnit.unit], 1);
                        if (unit2.unit && unit2.isBigger(unit)) {
                unit = unit2
                }
                unitDt = unit.approxTime();
                        unitSpacing = this.scene.dxToDtime(this.minorLabelWidths[unit.unit]) * 1.5;
                        _ref1 = this.multiples[unit.unit];
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                m = _ref1[_j];
                        if (m < unit.count) {
                m = unit.count
                }
                unit.count = m;
                        unitDt = unit.approxTime();
                        if (unitSpacing <= unitDt) {
                minorUnit = unit;
                        break
                }
                }
                if (minorUnit && minorUnit.isEqual(majorUnit)) {
                minorUnit = null
                }
                return[minorUnit, majorUnit]
                };
                Timechart_TimeAxis.prototype.paintScene = function(event) {
                var barSlices, counter, fiMajor, fromIndex, g, height, i, iMajor, isEven, isMultiYear, ly0, ly1, lytext, maI, maI0, maX, majorStep, miI, miI0, miX, minorStep, num, sceneScale, t, t1, text, textWidth, textX, textY, tiMajor, times, toIndex, tx0, tx1, ty0, ty1, x, x0, x1, xMajor, xa, xb, xes, xinc, y0, y00, y1, yMajor, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
                        if (!((this.scene.displayUnit != null) && this.scene.settings.timeAxis.enabled && (this.scene.timeStart < this.scene.timeEnd))) {
                return
                }
                g = event.context;
                        if (this.minorLabelHeight === null) {
                this.computeTextSizes(g)
                }
                x0 = this.scene.x0;
                        y00 = this.scene.y0;
                        y0 = y00 + this.scene.height + 1;
                        height = this.scene.bottomAxisSize;
                        y1 = y0 + height;
                        x1 = x0 + this.scene.width;
                        yMajor = y1 - this.majorLabelHeight * 1.8;
                        Base_Graphics.pushClip(g, x0, y00, this.scene.width, height + this.scene.height);
                        sceneScale = this.scene.getScale();
                        if (!(Math.abs(1 - this.curSceneScale / sceneScale) < 0.001)) {
                this.curSceneScale = sceneScale;
                        _ref = this.computeLabels(this.scene.displayUnit), minorStep = _ref[0], majorStep = _ref[1];
                        this.minorFormat = minorStep != null ? this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[minorStep.unit] : null;
                        this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelTimeFormats[majorStep.unit];
                        this.minorTimeUnit = minorStep;
                        this.majorTimeUnit = majorStep;
                        if (this.majorSlices === null || majorStep.approxTime() !== this.majorSlices.step.approxTime()) {
                this.majorSlices = new Timechart_TimeSlicer(this.scene, majorStep)
                }
                if ((minorStep != null) && (this.minorSlices === null || minorStep.approxTime() !== this.minorSlices.step.approxTime())) {
                this.minorSlices = new Timechart_TimeSlicer(this.scene, minorStep, [], null, null, false)
                } else {
                if (minorStep === null) {
                this.minorSlices = null
                }
                }
                }
                this.majorSlices.update();
                        xes = this.majorSlices.xes;
                        times = this.majorSlices.times;
                        fromIndex = this.majorSlices.fromIndex;
                        toIndex = this.majorSlices.toIndex;
                        num = this.majorSlices.step.numberOfUnits(0, times[fromIndex]);
                        isEven = (num | 0) % 2 === 0;
                        g.beginPath();
                        for (i = _i = fromIndex, _ref1 = toIndex - 2; _i <= _ref1; i = _i += 1) {
                isEven = !isEven;
                        if (isEven) {
                continue
                }
                xa = (Math.max(xes[i], x0) | 0) + 1;
                        xb = Math.min(xes[i + 1], x1) | 0;
                        g.rect(xa, y0, xb - xa, height)
                }
                Base_Graphics.fill(g, this.scene.settings.timeAxis.style.dateLighten);
                        if (this.options.vgrid) {
                g.beginPath();
                        for (i = _j = _ref2 = fromIndex + 1, _ref3 = toIndex - 2; _j <= _ref3; i = _j += 1) {
                x = (xes[i] | 0) + 0.5;
                        if (x >= x1) {
                break
                }
                g.moveTo(x, y00);
                        g.lineTo(x, y1)
                }
                Base_Graphics.stroke(g, this.options.style.vgrid)
                }
                isMultiYear = this.majorSlices.step.unit === "y" && this.majorSlices.step.count > 1;
                        textWidth = this.getLabelWidth(this.majorSlices.step);
                        if (this.scene.settings.timeAxis.style.showMajorTimeBalloons) {
                g.beginPath();
                        for (i = _k = fromIndex, _ref4 = toIndex - 2; _k <= _ref4; i = _k += 1) {
                tx0 = xes[i];
                        tx1 = xes[i + 1];
                        if (tx0 >= x1 || tx1 <= x0) {
                continue
                }
                t = times[i];
                        textX = (tx0 + tx1) / 2;
                        if (tx0 < x0) {
                tx0 = x0;
                        textX = Math.min((tx0 + tx1) / 2, tx1 - textWidth)
                }
                if (tx1 > x1) {
                tx1 = x1;
                        textX = Math.max((tx0 + tx1) / 2, tx0 + textWidth)
                }
                Base_Graphics.strokeBalloon2(g, textX, yMajor + 1, textWidth, this.majorLabelHeight)
                }
                Base_Graphics.paint(g, this.scene.settings.timeAxis.style.majorTimeBalloonStyle)
                }
                Base_Graphics.textStyle(g, this.scene.settings.timeAxis.style.majorTimeLabel);
                        g.textAlign = "center";
                        g.textBaseline = "middle";
                        for (i = _l = fromIndex, _ref5 = toIndex - 2; _l <= _ref5; i = _l += 1) {
                tx0 = xes[i];
                        tx1 = xes[i + 1];
                        if (tx0 >= x1 || tx1 <= x0) {
                continue
                }
                t = times[i];
                        if (isMultiYear) {
                t1 = times[i + 1];
                        text = moment(t).utc().format(this.majorFormat) + " - " + moment(t1).utc().format(this.majorFormat)
                } else {
                text = moment(t).utc().format(this.majorFormat)
                }
                textX = (tx0 + tx1) / 2;
                        if (tx0 < x0) {
                tx0 = x0;
                        textX = Math.min((tx0 + tx1) / 2, tx1 - textWidth)
                }
                if (tx1 > x1) {
                tx1 = x1;
                        textX = Math.max((tx0 + tx1) / 2, tx0 + textWidth)
                }
                g.fillText(text, textX, yMajor)
                }
                if (this.minorSlices) {
                this.minorSlices.update();
                        times = this.minorSlices.times;
                        xes = this.minorSlices.xes;
                        fromIndex = this.minorSlices.fromIndex;
                        toIndex = this.minorSlices.toIndex;
                        textWidth = this.minorLabelWidths[this.minorSlices.step.unit];
                        lytext = y0 + (this.minorLabelHeight * 0.4) | 0;
                        ly0 = y0 - 1;
                        ly1 = lytext + (this.minorLabelHeight * 1.6) | 0;
                        if (this.scene.settings.timeAxis.style.showMinorTimeBalloons) {
                g.beginPath();
                        textY = null;
                        for (i = _m = fromIndex, _ref6 = toIndex - 1; _m <= _ref6; i = _m += 1) {
                x = xes[i];
                        textY = Base_Graphics.strokeBalloon(g, x, y0 - 5, textWidth, this.minorLabelHeight)
                }
                Base_Graphics.paint(g, this.scene.settings.timeAxis.style.minorTimeBalloonStyle)
                } else {
                fiMajor = this.majorSlices.fromIndex;
                        tiMajor = this.majorSlices.toIndex;
                        xMajor = this.majorSlices.xes;
                        g.beginPath();
                        iMajor = fiMajor;
                        for (i = _n = fromIndex, _ref7 = toIndex - 1; _n <= _ref7; i = _n += 1) {
                x = xes[i];
                        while (x > xMajor[iMajor]) {
                iMajor += 1
                }
                if (xMajor[iMajor] === x) {
                continue
                }
                if (x >= x1) {
                break
                }
                x = (x | 0) - 0.5;
                        g.moveTo(x, ly0);
                        g.lineTo(x, ly1)
                }
                Base_Graphics.stroke(g, this.scene.settings.timeAxis.style.minorTimeRuler1);
                        g.beginPath();
                        iMajor = fiMajor;
                        for (i = _o = fromIndex, _ref8 = toIndex - 1; _o <= _ref8; i = _o += 1) {
                x = xes[i];
                        while (x > xMajor[iMajor]) {
                iMajor += 1
                }
                if (xMajor[iMajor] === x) {
                continue
                }
                if (x >= x1) {
                break
                }
                x = (x | 0) + 0.5;
                        g.moveTo(x, ly0);
                        g.lineTo(x, ly1)
                }
                Base_Graphics.stroke(g, this.scene.settings.timeAxis.style.minorTimeRuler2)
                }
                Base_Graphics.textStyle(g, this.scene.settings.timeAxis.style.minorTimeLabel);
                        g.textAlign = this.scene.settings.timeAxis.style.showMinorTimeBalloons ? "center" : "left";
                        xinc = this.scene.settings.timeAxis.style.showMinorTimeBalloons ? 0 : 3;
                        g.textBaseline = "top";
                        for (i = _p = fromIndex, _ref9 = toIndex - 1; _p <= _ref9; i = _p += 1) {
                x = xes[i];
                        t = times[i];
                        text = moment(t).utc().format(this.minorFormat);
                        g.fillText(text, x + xinc, lytext)
                }
                }
                barSlices = null;
                        if (this.scene.settings.timeAxis.style.miniTimeRuler && (barSlices != null) && barSlices.xes[barSlices.fromIndex + 1] - barSlices.xes[barSlices.fromIndex] > 2) {
                ty0 = y0 - 1;
                        ty1 = y0 + 3;
                        xes = barSlices.xes;
                        maI0 = this.majorSlices.fromIndex;
                        miI0 = this.minorSlices != null ? this.minorSlices.fromIndex : maI0;
                        maX = this.majorSlices.xes;
                        miX = this.minorSlices != null ? this.minorSlices.xes : maX;
                        g.beginPath();
                        maI = maI0;
                        miI = miI0;
                        counter = 0;
                        for (i = _q = _ref10 = barSlices.fromIndex, _ref11 = barSlices.toIndex - 2; _ref10 <= _ref11 ? _q <= _ref11 : _q >= _ref11; i = _ref10 <= _ref11 ? ++_q : --_q) {
                x = xes[i];
                        while (x > maX[maI]) {
                maI += 1
                }
                if (maX[maI] === x) {
                continue
                }
                while (x > miX[miI]) {
                miI += 1
                }
                if (miX[miI] === x) {
                continue
                }
                if (x >= x1) {
                break
                }
                x = (x | 0) - 0.5;
                        g.moveTo(x, ty0);
                        g.lineTo(x, ty1);
                        counter++
                }
                if (counter) {
                Base_Graphics.stroke(g, this.scene.settings.timeAxis.style.minorTimeRuler1)
                }
                counter = 0;
                        g.beginPath();
                        maI = maI0;
                        miI = miI0;
                        for (i = _r = _ref12 = barSlices.fromIndex, _ref13 = barSlices.toIndex - 2; _ref12 <= _ref13 ? _r <= _ref13 : _r >= _ref13; i = _ref12 <= _ref13 ? ++_r : --_r) {
                x = xes[i];
                        while (x > maX[maI]) {
                maI += 1
                }
                if (maX[maI] === x) {
                continue
                }
                while (x > miX[miI]) {
                miI += 1
                }
                if (miX[miI] === x) {
                continue
                }
                if (x >= x1) {
                break
                }
                x = (x | 0) + 0.5;
                        g.moveTo(x, ty0);
                        g.lineTo(x, ty1);
                        counter++
                }
                if (counter) {
                Base_Graphics.stroke(g, this.scene.settings.timeAxis.style.minorTimeRuler2)
                }
                }
                Base_Graphics.popClip(g);
                        this.scene.minorTimeFormat = this.minorFormat;
                        this.scene.minorTimeUnit = this.minorTimeUnit;
                        this.scene.majorTimeFormat = this.majorFormat;
                        this.scene.majorTimeUnit = this.majorTimeUnit
                };
                return Timechart_TimeAxis
        })();
        var Timechart_DataWarehouse;
        Timechart_DataWarehouse = (function() {
        function Timechart_DataWarehouse(chart) {
        this.chart = chart;
                this.scene = this.chart.scene;
                this.dataSources = {};
                this.requests = {};
                this.results = {};
                this.dataSlicesCache = {};
                this.nextRequestId = 0;
                this.hasNewRequests = false
        }
        Timechart_DataWarehouse.prototype.registerDataProcessingRequest = function(params) {
        this.requests[this.nextRequestId] = params;
                this.results[this.nextRequestId] = {leadIn: null, leadOut: null, times: [], xes: [], values: [], fromIndex: 0, toIndex: 0, data: [], from: 0, to: 0, slicer: null, dataExistsFrom: null, dataExistsTo: null};
                this.hasNewRequests = true;
                return this.nextRequestId++
        };
                Timechart_DataWarehouse.prototype.removeDataProcessingRequest = function(id) {
                delete this.requests[id];
                        return delete this.results[id]
                };
                Timechart_DataWarehouse.prototype.getData = function(requestId) {
                return this.results[requestId]
                };
                Timechart_DataWarehouse.prototype.clear = function() {
                this.requests = {};
                        return this.results = {}
                };
                Timechart_DataWarehouse.prototype.process = function(event) {
                var changes, dataUpdate, forceDataUpdate, i, k, request, result, v, _ref, _ref1, _ref2;
                        changes = event.changes;
                        if (changes.settings || changes.data) {
                this.dataSources = {};
                        _ref = this.scene.data;
                        for (k in _ref) {
                v = _ref[k];
                        this.dataSources[k] = v
                }
                }
                if (!(changes.time || changes.data || changes.displayUnit || changes.bounds || changes.settings || this.hasNewRequests)) {
                return
                }
                if (this.scene.timeStart >= this.scene.timeEnd) {
                _ref1 = this.requests;
                        for (i in _ref1) {
                request = _ref1[i];
                        result = this.results[i];
                        result.dataExistsFrom = null;
                        result.dataExistsTo = null
                }
                return
                }
                this.hasNewRequests = false;
                        this.loading = false;
                        this.hasSomeData = false;
                        forceDataUpdate = changes.data || changes.time;
                        _ref2 = this.requests;
                        for (i in _ref2) {
                request = _ref2[i];
                        result = this.results[i];
                        dataUpdate = this.updateData(forceDataUpdate, request, result);
                        this.updateSlices(dataUpdate, request, result)
                }
                this.scene.loading = this.loading;
                        if (this.loading) {
                this.scene.setMessage("noData", this.scene.settings.localization.loadingLabel, 10)
                } else {
                if (!this.hasSomeData) {
                this.scene.setMessage("noData", this.scene.settings.localization.noDataLabel, 999)
                } else {
                this.scene.setMessage("noData", null)
                }
                }
                };
                Timechart_DataWarehouse.prototype.updateData = function(dataUpdate, request, result) {
                var data, dataSource, displayUnit, dt, from, to;
                        dataSource = this.dataSources[request.source];
                        displayUnit = this.getUnitToUse(request);
                        dt = (this.scene.timeEnd - this.scene.timeStart) * dataSource.settings.prefetchRatio;
                        if (dataUpdate || (!result.from && this.scene.timeStart) || (!result.to && this.scene.timeEnd) || result.from >= result.to || this.scene.timeStart - dt < result.from || this.scene.timeEnd + dt > result.to || ((result.dataExistsFrom != null) && result.dataExistsFrom > this.scene.timeEnd) || ((result.dataExistsTo != null) && result.dataExistsTo < this.scene.timeStart)) {
                dataUpdate = true;
                        from = this.scene.timeStart - dt * 2;
                        to = this.scene.timeEnd + dt * 2;
                        data = dataSource.getDataForRange(from, to, displayUnit, (function(_this) {
                        return function() {
                        return _this._newDataArrived()
                        }
                        })(this));
                        if (!dataSource.noData) {
                this.hasSomeData = true
                }
                if (data.from > this.scene.timeEnd || data.to < this.scene.timeStart) {
                result.data = [];
                        result.from = 0;
                        result.to = 0;
                        result.dataExistsFrom = null;
                        result.datasExistsTo = null;
                        this.loading || (this.loading = data.loading)
                } else {
                this.loading || (this.loading = data.loading && (data.from > this.scene.timeStart || data.to < this.scene.timeEnd));
                        result.data = data.values;
                        result.from = from;
                        result.to = to;
                        result.dataExistsFrom = data.from;
                        result.dataExistsTo = data.to
                }
                }
                return dataUpdate
                };
                Timechart_DataWarehouse.prototype.updateSlices = function(dataUpdate, request, result) {
                var agr, data, dataIndex, displayUnit, i, np, slice, sliceNewAfter, sliceNewBefore, sliceOffset, times, values, _ref;
                        displayUnit = this.getUnitToUse(request);
                        dataIndex = request.index;
                        agr = request.aggregation;
                        np = request.noDataPolicy;
                        data = result.data;
                        slice = result.slicer = this.getSlice(request, displayUnit);
                        _ref = slice.update(this.scene.timeStart, this.scene.timeEnd), sliceOffset = _ref[0], sliceNewBefore = _ref[1], sliceNewAfter = _ref[2];
                        times = result.times = slice.times;
                        result.xes = slice.xes;
                        values = result.values = slice.values;
                        data = result.data;
                        result.fromIndex = slice.fromIndex;
                        result.toIndex = slice.toIndex;
                        if (!data) {
                result.values = (function() {
                var _i, _len, _results;
                        _results = [];
                        for (_i = 0, _len = times.length; _i < _len; _i++) {
                i = times[_i];
                        _results.push(null)
                }
                return _results
                })();
                        result.leadIn = null;
                        return result.leadOut = null
                } else {
                if (data.length > 0 && dataIndex >= data[0].length) {
                return this.chart.error("No data for this DataIndex: " + dataIndex + ", only " + (data[0].length - 1) + " values present")
                } else {
                if (dataUpdate) {
                this.fillValues(data, times, values, slice.fromIndex, slice.toIndex, agr, dataIndex)
                } else {
                this.fillValues(data, times, values, slice.fromIndex, sliceNewBefore + 1, agr, dataIndex);
                        this.fillValues(data, times, values, sliceNewAfter - 1, slice.toIndex, agr, dataIndex)
                }
                return this.setLeads(request, result)
                }
                }
                };
                Timechart_DataWarehouse.prototype.getSlice = function(request, displayUnit) {
                var agr, cacheIndex, index, np, s, source, unit;
                        source = request.source;
                        index = request.index;
                        unit = displayUnit.toString();
                        agr = request.aggregation;
                        np = request.noDataPolicy;
                        cacheIndex = "" + source + ":" + index + ":" + unit + ":" + agr + ":" + np;
                        if (this.dataSlicesCache.hasOwnProperty(cacheIndex)) {
                s = this.dataSlicesCache[cacheIndex]
                } else {
                s = this.dataSlicesCache[cacheIndex] = new Timechart_TimeSlicer(this.scene, displayUnit, ["values"])
                }
                return s
                };
                Timechart_DataWarehouse.prototype.getUnitToUse = function(request) {
                return this.scene.displayUnit
                };
                Timechart_DataWarehouse.prototype.setLeads = function(request, result) {
                var agr, data, dataIndex, dataPos, fromIndex, leadIn, leadOut, np, t, t0, t1, time, times, toIndex, v, values, x, x0, x1, _ref, _ref1;
                        np = request.noDataPolicy;
                        agr = request.aggregation;
                        dataIndex = request.index;
                        data = result.data;
                        values = result.values;
                        times = result.times;
                        leadIn = null;
                        leadOut = null;
                        if (np === "join" && data) {
                fromIndex = result.fromIndex;
                        if (values[fromIndex] === null) {
                dataPos = Timechart_Data.binSearch(data, times[fromIndex]);
                        dataPos = Timechart_Data.linSearchDown(data, dataPos, dataIndex);
                        if (dataPos !== - 1) {
                time = data[dataPos][0];
                        _ref = result.slicer.makeMiniSlice(time), t0 = _ref[0], x0 = _ref[1], t1 = _ref[2], x1 = _ref[3];
                        t = [t0, t1];
                        x = [x0, x1];
                        v = [null, null];
                        this.fillValues(data, t, v, 0, 2, agr, dataIndex, {fromIndex: 0, toIndex: 2});
                        leadIn = {times: t, xes: x, values: v}
                }
                }
                toIndex = result.toIndex;
                        if (values[toIndex - 2] === null) {
                dataPos = Timechart_Data.binSearch(data, times[toIndex - 1]);
                        dataPos = Timechart_Data.linSearchUp(data, dataPos, dataIndex);
                        if (dataPos !== - 1) {
                time = data[dataPos][0];
                        _ref1 = result.slicer.makeMiniSlice(time), t0 = _ref1[0], x0 = _ref1[1], t1 = _ref1[2], x1 = _ref1[3];
                        t = [t0, t1];
                        x = [x0, x1];
                        v = [null, null];
                        this.fillValues(data, t, v, 0, 2, agr, dataIndex);
                        leadOut = {times: t, xes: x, values: v, fromIndex: 0, toIndex: 2}
                }
                }
                }
                result.leadIn = leadIn;
                        return result.leadOut = leadOut
                };
                Timechart_DataWarehouse.prototype.fillValues = function(data, times, values, timesI0, timesI1, agr, dataIndex) {
                if (timesI0 + 1 >= timesI1) {
                return
                }
                if (agr === "sum") {
                return this.fillValueSum(data, times, values, timesI0, timesI1, dataIndex)
                } else {
                if (agr === "min") {
                return this.fillValueMin(data, times, values, timesI0, timesI1, dataIndex)
                } else {
                if (agr === "max") {
                return this.fillValueMax(data, times, values, timesI0, timesI1, dataIndex)
                } else {
                if (agr === "avg") {
                return this.fillValueAvg(data, times, values, timesI0, timesI1, dataIndex)
                } else {
                if (agr === "first") {
                return this.fillValueFirst(data, times, values, timesI0, timesI1, dataIndex)
                } else {
                if (agr === "last") {
                return this.fillValueLast(data, times, values, timesI0, timesI1, dataIndex)
                } else {
                return this.chart.error("Unrecognized aggregation function: " + agr)
                }
                }
                }
                }
                }
                }
                };
                Timechart_DataWarehouse.prototype.fillValueSum = function(data, times, values, timesI0, timesI1, dataIndex) {
                var acc, count, dataLen, fromIndex, i, toTime, value, _i, _ref;
                        dataLen = data.length;
                        fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
                        for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
                toTime = times[i + 1];
                        acc = 0;
                        count = 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                value = data[fromIndex][dataIndex];
                        fromIndex += 1;
                        if (value !== null) {
                acc += value;
                        count += 1
                }
                }
                if (count > 0) {
                values[i] = acc
                } else {
                values[i] = null
                }
                }
                };
                Timechart_DataWarehouse.prototype.fillValueMin = function(data, times, values, timesI0, timesI1, dataIndex) {
                var acc, count, dataLen, fromIndex, i, toTime, value, _i, _ref;
                        dataLen = data.length;
                        fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
                        for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
                toTime = times[i + 1];
                        acc = Infinity;
                        count = 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                value = data[fromIndex][dataIndex];
                        fromIndex += 1;
                        if (value !== null) {
                acc = Math.min(acc, value);
                        count += 1
                }
                }
                if (count > 0) {
                values[i] = acc
                } else {
                values[i] = null
                }
                }
                };
                Timechart_DataWarehouse.prototype.fillValueMax = function(data, times, values, timesI0, timesI1, dataIndex) {
                var acc, count, dataLen, fromIndex, i, toTime, value, _i, _ref;
                        dataLen = data.length;
                        fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
                        for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
                toTime = times[i + 1];
                        acc = - Infinity;
                        count = 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                value = data[fromIndex][dataIndex];
                        fromIndex += 1;
                        if (value !== null) {
                count += 1;
                        acc = Math.max(acc, value)
                }
                }
                if (count > 0) {
                values[i] = acc
                } else {
                values[i] = null
                }
                }
                };
                Timechart_DataWarehouse.prototype.fillValueAvg = function(data, times, values, timesI0, timesI1, dataIndex) {
                var acc, count, dataLen, fromIndex, i, toTime, value, _i, _ref;
                        dataLen = data.length;
                        fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
                        for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
                toTime = times[i + 1];
                        acc = 0;
                        count = 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                value = data[fromIndex][dataIndex];
                        fromIndex += 1;
                        if (value !== null) {
                acc += value;
                        count += 1
                }
                }
                if (count > 0) {
                values[i] = acc / count
                } else {
                values[i] = null
                }
                }
                };
                Timechart_DataWarehouse.prototype.fillValueFirst = function(data, times, values, timesI0, timesI1, dataIndex) {
                var acc, count, dataLen, fromIndex, i, toTime, value, _i, _ref;
                        dataLen = data.length;
                        fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
                        for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
                toTime = times[i + 1];
                        acc = null;
                        count = 0;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                value = data[fromIndex][dataIndex];
                        fromIndex += 1;
                        if (value !== null && count === 0) {
                acc = value;
                        count += 1
                }
                }
                values[i] = acc
                }
                };
                Timechart_DataWarehouse.prototype.fillValueLast = function(data, times, values, timesI0, timesI1, dataIndex) {
                var acc, dataLen, fromIndex, i, toTime, value, _i, _ref;
                        dataLen = data.length;
                        fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
                        for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
                toTime = times[i + 1];
                        acc = null;
                        while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
                value = data[fromIndex][dataIndex];
                        fromIndex += 1;
                        if (value !== null) {
                acc = value
                }
                }
                values[i] = acc
                }
                };
                Timechart_DataWarehouse.prototype._newDataArrived = function() {
                return this.chart.events.notifySceneChanges({data: true})
                };
                return Timechart_DataWarehouse
        })();
        var Timechart_Renderer;
        Timechart_Renderer = (function() {
        function Timechart_Renderer(chart, dataWarehouse) {
        this.chart = chart;
                this.dataWarehouse = dataWarehouse;
                this.scene = this.chart.scene;
                this.events = this.chart.events;
                this.animationPriority = 999;
                this.buildSeries();
                this.shades = new Linearchart_DataLimitRenderer(this)
        }
        Timechart_Renderer.prototype.buildSeries = function() {
        var opts, series, _i, _j, _len, _len1, _ref, _ref1, _results;
                this.valueAxis = {};
                _ref = this.scene.settings.computedValueAxisList;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        opts = _ref[_i];
                this.valueAxis[opts.id] = new Linearchart_ValueAxis(this, opts)
        }
        this.r = new Linearchart_Renderer(this.chart, this.valueAxis);
                this.dataWarehouse.clear();
                this.requestIds = [];
                _ref1 = this.scene.settings.computedSeries;
                _results = [];
                for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        series = _ref1[_j];
                _results.push(this.requestIds.push(this.dataWarehouse.registerDataProcessingRequest(series.data)))
        }
        return _results
        };
                Timechart_Renderer.prototype.onSceneChange = function(event) {
                var changes;
                        changes = event.changes;
                        if (changes.settings && (changes.settingsChanges.computedSeries || changes.settingsChanges.valueAxis)) {
                this.buildSeries()
                }
                if (changes.bounds || changes.settings) {
                Linearchart_ValueAxis.placeAxis(event.context, this.valueAxis)
                }
                if (changes.bounds || changes.settings) {
                changes.scale = true;
                        return changes.time = true
                }
                };
                Timechart_Renderer.prototype.doAnimations = function(event) {
                var changes, data, id, name, x, _i, _len, _ref, _ref1, _ref2, _results;
                        changes = event.changes;
                        this.dataWarehouse.process(event);
                        if (this.scene.displayUnit != null) {
                if (this.displayUnit !== this.scene.displayUnit) {
                this.displayUnit = this.scene.displayUnit;
                        changes.displayUnit = true
                }
                data = [];
                        _ref = this.requestIds;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                id = _ref[_i];
                        data.push(this.dataWarehouse.getData(id))
                }
                if (changes.time || changes.data || changes.displayUnit || changes.bounds) {
                this.r.process(data)
                }
                _ref1 = this.valueAxis;
                        for (name in _ref1) {
                x = _ref1[name];
                        x.process(event)
                }
                this.r.afterProcess();
                        _ref2 = this.valueAxis;
                        _results = [];
                        for (name in _ref2) {
                x = _ref2[name];
                        _results.push(x.afterProcess(event))
                }
                return _results
                }
                };
                Timechart_Renderer.prototype.paintScene = function(event) {
                var context, h, name, o, w, x, y, _ref, _ref1, _ref2, _results;
                        context = event.context;
                        _ref = [this.scene.x0, this.scene.y0, this.scene.width, this.scene.height], x = _ref[0], y = _ref[1], w = _ref[2], h = _ref[3];
                        _ref1 = this.valueAxis;
                        for (name in _ref1) {
                o = _ref1[name];
                        o.paintUnder(context)
                }
                Base_Graphics.pushClip(context, x, y, w, h);
                        this.r.paint(event);
                        this.shades.paint(context);
                        Base_Graphics.popClip(context);
                        _ref2 = this.valueAxis;
                        _results = [];
                        for (name in _ref2) {
                o = _ref2[name];
                        _results.push(o.paint(context, context))
                }
                return _results
                };
                Timechart_Renderer.prototype.exportData = function(from, to) {
                return this.r.exportData(from, to)
                };
                return Timechart_Renderer
        })();
        var Base_Resizer;
        Base_Resizer = (function() {
        Base_Resizer.prototype.chart = null;
                Base_Resizer.prototype.oh = 0;
                Base_Resizer.prototype.sy = 0;
                Base_Resizer.prototype.barVisible = false;
                Base_Resizer.prototype.resizing = false;
                Base_Resizer.prototype.enabled = false;
                function Base_Resizer(chart) {
                this.chart = chart;
                        this.scene = this.chart.scene;
                        this.layers = this.chart.layers
                }
        Base_Resizer.prototype.onSceneChange = function(ev) {
        if (Base_Helpers.hasProp(ev, "changes/settings")) {
        return this.enabled = this.scene.settings.interaction.resizing.enabled
        }
        };
                Base_Resizer.prototype.onPointerOut = function(ev) {
                if (!this.enabled) {
                return
                }
                return this.hideUI()
                };
                Base_Resizer.prototype.onPointerMove = function(ev) {
                var dy;
                        if (!this.enabled) {
                return
                }
                dy = this.scene.chartHeight - ev.y;
                        if (dy < this.scene.settings.interaction.resizing.advanced.resizerHandleVisibilityTolerance) {
                if (!this.barVisible) {
                this.showUI()
                }
                if (dy < this.scene.settings.interaction.resizing.advanced.resizerHandleEnableTolerance) {
                ev.consumed = true;
                        return ev.cursor = "ns-resize"
                }
                } else {
                if (this.barVisible) {
                return this.hideUI()
                }
                }
                };
                Base_Resizer.prototype.onPointerDown = function(ev) {
                var dy;
                        if (!this.enabled) {
                return
                }
                this.sy = ev.y;
                        dy = this.scene.chartHeight - ev.y;
                        this.resizing = dy < this.scene.settings.interaction.resizing.advanced.resizerHandleEnableTolerance && ev.y <= this.scene.chartHeight;
                        if (this.resizing) {
                this.oh = this.scene.chartHeight;
                        this.showUI();
                        ev.cursor = "ns-resize";
                        return ev.consumed = true
                }
                };
                Base_Resizer.prototype.onDoubleClick = function(ev) {
                var dy, h, s;
                        if (!this.enabled) {
                return
                }
                this.sy = ev.y;
                        dy = this.scene.chartHeight - ev.y;
                        if (dy < this.scene.settings.interaction.resizing.advanced.resizerHandleEnableTolerance && ev.y <= this.scene.chartHeight) {
                ev.consumed = true;
                        if (this.wasMaximized) {
                h = this.originalHeight;
                        this.wasMaximized = false
                } else {
                this.originalHeight = this.oh;
                        this.wasMaximized = true;
                        s = Base_Helpers.getScroll();
                        h = this.oh + s[1] + window.innerHeight - ev.pageY - dy - 10
                }
                this.scene.settings.height = Math.min(this.scene.settings.maxHeight, Math.max(this.scene.settings.minHeight, h));
                        return this.chart.updateSize()
                }
                };
                Base_Resizer.prototype.onPointerDrag = function(ev) {
                if (!this.enabled) {
                return
                }
                if (this.resizing) {
                ev.consumed = true;
                        this.wasMaximized = false;
                        this.scene.settings.height = Math.min(this.scene.settings.maxHeight, Math.max(this.scene.settings.minHeight, this.oh + (ev.y - this.sy)));
                        return this.chart.updateSize()
                }
                };
                Base_Resizer.prototype.showUI = function() {
                if (this.barVisible) {
                return
                }
                this.barVisible = true;
                        return Base_Helpers.fadeIn(this.layers.resizerBar)
                };
                Base_Resizer.prototype.hideUI = function() {
                if (!this.barVisible) {
                return
                }
                this.barVisible = false;
                        this.resizing = false;
                        return Base_Helpers.fadeOut(this.layers.resizerBar)
                };
                return Base_Resizer
        })();
        var Base_MessagesOverlay;
        Base_MessagesOverlay = (function() {
        Base_MessagesOverlay.prototype.animationPriority = 0;
                Base_MessagesOverlay.prototype.scene = null;
                Base_MessagesOverlay.prototype.loadingTime = null;
                function Base_MessagesOverlay(chart) {
                this.chart = chart;
                        this.scene = chart.scene
                }
        Base_MessagesOverlay.prototype.doAnimations = function(event) {
        if (this.scene.loading) {
        return event.animating = true
        }
        };
                Base_MessagesOverlay.prototype.paintScene = function(event) {
                var a, arcStyle, g, grad, height, loading, msg, r, scene, w, width, x, y, yy;
                        scene = this.scene;
                        msg = this.scene.getMessage();
                        loading = this.scene.loading;
                        if (!loading) {
                this.loadingTime = null
                }
                if (!((msg != null) || loading)) {
                return
                }
                if (this.loadingTime == null) {
                this.loadingTime = event.time
                }
                arcStyle = this.scene.settings.advanced.style.loadingArcStyle;
                        g = event.context;
                        if (arcStyle.location === "corner") {
                x = scene.x0 + scene.width;
                        y = scene.y0
                } else {
                x = scene.x0 + scene.width / 2;
                        y = scene.y0 + scene.height / 2
                }
                if (msg != null) {
                Base_Graphics.textStyle(g, this.scene.settings.advanced.style.messageTextStyle);
                        g.textBaseline = "middle";
                        g.textAlign = "center";
                        height = g.measureText("M").width * 1.5;
                        width = g.measureText(msg).width;
                        if (arcStyle.location === "corner") {
                x -= width;
                        y += height * 1.5
                }
                if (this.scene.loading) {
                y -= height;
                        yy = y + arcStyle.r + height
                } else {
                yy = y
                }
                g.fillText(msg, x, yy)
                }
                if (this.scene.loading) {
                r = arcStyle.r;
                        w = arcStyle.lineWidth;
                        if (!msg && arcStyle.location === "corner") {
                x -= (r + w) * 1.2;
                        y += (r + w) * 1.2
                }
                g.save();
                        g.lineCap = "round";
                        g.lineWidth = w;
                        a = (event.time - this.loadingTime) / 700 * Math.PI;
                        grad = g.createLinearGradient(x + r * Math.cos(a + Math.PI), y + r * Math.sin(a + Math.PI), x + r * Math.cos(a), y + r * Math.sin(a));
                        grad.addColorStop(0, arcStyle.lineColor);
                        grad.addColorStop(1, "transparent");
                        g.strokeStyle = grad;
                        g.beginPath();
                        g.arc(x, y, r, a, a + Math.PI);
                        g.stroke();
                        return g.restore()
                }
                };
                return Base_MessagesOverlay
        })();
        var Base_Title;
        Base_Title = (function() {
        function Base_Title(chart) {
        this.chart = chart;
                this.scene = chart.scene;
                this.lines = [];
                this.lineSpacing = 0
        }
        Base_Title.prototype.computeSize = function(g, is_export) {
        var availableWidth, h, i, line, line1, line1Width, lineWidth, m, text, title, w, width, words, _i, _ref;
                if (is_export == null) {
        is_export = false
        }
        title = this.scene.settings.title;
                this.lines = [];
                if (!(((title.enabled && !is_export) || (title.enabledOnExport && is_export)) && title.text)) {
        return[0, 0]
        }
        m = 2 * title.margin;
                text = title.text;
                g.save();
                Base_Graphics.textStyle(g, title.style);
                w = g.measureText(text).width;
                h = g.measureText("M").width;
                this.lineSpacing = h * 1.4;
                availableWidth = this.scene.chartWidth;
                if (w + m > availableWidth) {
        width = 0;
                words = text.split(" ");
                line = words[0];
                lineWidth = g.measureText(line).width;
                for (i = _i = 1, _ref = words.length - 1; _i <= _ref; i = _i += 1) {
        line1 = line + " " + words[i];
                line1Width = g.measureText(line1).width;
                if (line1Width <= availableWidth) {
        line = line1;
                lineWidth = line1Width
        } else {
        this.lines.push(line);
                w = Math.max(w, lineWidth);
                line = words[i];
                lineWidth = g.measureText(line).width
        }
        }
        this.lines.push(line);
                w = Math.max(width, lineWidth)
        } else {
        this.lines.push(text)
        }
        g.restore();
                w += m;
                h = m + (this.lines.length - 1) * this.lineSpacing + h;
                return[w, h]
        };
                Base_Title.prototype.paintScene = function(event) {
                var enabled, g, h, h0, left, line, margin, right, title, top, w, w0, x, y, _i, _len, _ref, _ref1, _ref2, _results;
                        title = this.scene.settings.title;
                        enabled = event["export"] ? title.enabledOnExport : title.enabled;
                        if (!(enabled && title.text)) {
                return
                }
                g = event.context;
                        left = 0;
                        top = 0;
                        _ref = this.computeSize(g), w = _ref[0], h = _ref[1];
                        if (event["export"]) {
                _ref1 = this.computeSize(g, true), w0 = _ref1[0], h0 = _ref1[1];
                        if (h0 > h) {
                top = h0 * - 1
                }
                }
                right = this.scene.chartWidth;
                        margin = title.margin;
                        Base_Graphics.textStyle(g, title.style);
                        y = top + margin;
                        g.textBaseline = "top";
                        if (title.align === "left") {
                g.textAlign = "start";
                        x = left + margin
                } else {
                if (title.align === "right") {
                g.textAlign = "end";
                        x = right - margin
                } else {
                g.textAlign = "center";
                        x = (left + right) / 2
                }
                }
                _ref2 = this.lines;
                        _results = [];
                        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                line = _ref2[_i];
                        g.fillText(line, x, y);
                        _results.push(y += this.lineSpacing)
                }
                return _results
                };
                return Base_Title
        })();
        var Base_Credits, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        };
        Base_Credits = (function() {
        function Base_Credits(chart, settings) {
        this.chart = chart;
                this.settings = settings;
                this.imageLoaded = __bind(this.imageLoaded, this);
                this.scene = this.chart.scene;
                if (this.settings.enabledOnExport || this.settings.enabled) {
        this.scene.settings.getAssetImage(this.settings.image);
                if (this.settings.imageExport) {
        this.scene.settings.getAssetImage(this.settings.imageExport)
        }
        }
        this.left = 0;
                this.top = 0;
                this.width = 0;
                this.height = 0
        }
        Base_Credits.prototype.paintScene = function(event) {
        var canvas, ch, context, cw, ei, enabled, i, margin, x, y;
                enabled = event["export"] ? this.settings.enabledOnExport : this.settings.enabled;
                if (!enabled) {
        return
        }
        i = this.scene.settings.getAssetImage(this.settings.image);
                ei = this.settings.imageExport ? this.scene.settings.getAssetImage(this.settings.imageExport) : i;
                if (event["export"]) {
        i = ei
        }
        if (i) {
        margin = 3;
                context = event.context;
                canvas = context.canvas;
                cw = this.scene.chartWidth;
                ch = this.scene.chartHeight;
                this.width = i.width * this.settings.imageScaling;
                this.height = i.height * this.settings.imageScaling;
                x = cw - this.width - margin;
                y = ch - this.height - margin;
                context.drawImage(i, 0, 0, i.width, i.height, x, y, this.width, this.height);
                this.left = x;
                return this.top = y
        }
        };
                Base_Credits.prototype.onPointerMove = function(event) {
                var x, y;
                        x = event.x;
                        y = event.y;
                        if (x > this.left && y > this.top && x < this.left + this.width && y < this.top + this.height && this.settings.url) {
                return event.cursor = "pointer"
                }
                };
                Base_Credits.prototype.onClick = function(event) {
                var x, y;
                        x = event.x;
                        y = event.y;
                        if (x > this.left && y > this.top && x < this.left + this.width && y < this.top + this.height && this.settings.url) {
                Base_Helpers.openUrl(this.settings.url);
                        return event.consumed = true
                }
                };
                Base_Credits.prototype.imageLoaded = function(image) {
                if (this.settings.location = "outside") {
                return this.chart.updateSize(true)
                } else {
                return this.chart.events.notifySceneChanges({repaint: true})
                }
                };
                Base_Credits.prototype.computeSize = function(g, is_export) {
                var credits, i;
                        if (is_export == null) {
                is_export = false
                }
                credits = this.settings;
                        this.lines = [];
                        if (!((credits.enabled && !is_export) || (credits.enabledOnExport && is_export))) {
                return[0, 0]
                }
                i = this.scene.settings.getAssetImage(this.settings.image, this.imageLoaded);
                        if (i && this.settings.location === "outside") {
                return[i.width * this.settings.imageScaling, i.height * this.settings.imageScaling]
                } else {
                return[0, 0]
                }
                };
                return Base_Credits
        })();
        var Piechart_Navigator;
        Piechart_Navigator = (function() {
        Piechart_Navigator.prototype.animationPriority = 1001;
                function Piechart_Navigator(chart) {
                this.chart = chart;
                        this.scene = chart.scene;
                        this.events = chart.events
                }
        Piechart_Navigator.prototype.setPie = function(id, offset, origin) {
        var changes, pie;
                if (!Base_Helpers.isArray(id)) {
        id = [id]
        }
        this.scene.pendingAction = null;
                changes = 0;
                while (this.scene.length() > id.length) {
        this.scene.pop();
                changes++
        }
        while (this.scene.length() > 0 && this.scene.peek().id !== id[this.scene.length() - 1]) {
        this.scene.pop();
                changes++
        }
        while (this.scene.length() < id.length) {
        pie = new Piechart_Pie();
                pie.id = id[this.scene.length()];
                pie.offset = this.scene.length() + 1 === id.length ? offset : 0;
                this.scene.push(pie);
                this.scene.view.updatePie(pie);
                changes++
        }
        pie = this.scene.peek();
                if (pie.offset !== offset) {
        this.scroll(pie, offset);
                changes++
        } else {
        if (changes && pie) {
        this.scene.view.updatePie(pie)
        }
        }
        if (changes) {
        this.chart.notifyChartUpdate(origin);
                return this.events.notifySceneChanges({pie: true})
        }
        };
                Piechart_Navigator.prototype.getPie = function() {
                var pie, _i, _len, _ref, _results;
                        _ref = this.scene.stack;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                pie = _ref[_i];
                        _results.push(pie.id)
                }
                return _results
                };
                Piechart_Navigator.prototype.getPieOffset = function() {
                return this.scene.peek().offset
                };
                Piechart_Navigator.prototype.goBack = function(origin) {
                if (!(this.scene.length() > 1)) {
                return
                }
                this.scene.pop();
                        this.scene.pendingAction = null;
                        return this.updateAndNotifyCurrent(origin)
                };
                Piechart_Navigator.prototype.goCenter = function(origin) {
                var pie;
                        pie = this.scene.peek();
                        if (pie.offset > 0 && this.scene.settings.interaction.others.centerGoesToPrevious) {
                return this.goPrevious(pie, origin)
                } else {
                if (this.scene.length() > 1) {
                this.scene.pop();
                        this.scene.pendingAction = null;
                        return this.updateAndNotifyCurrent(origin)
                }
                }
                };
                Piechart_Navigator.prototype.drillDown = function(pieId, origin) {
                var pie;
                        this.scene.pendingAction = null;
                        pie = new Piechart_Pie();
                        pie.id = pieId;
                        pie.offset = 0;
                        this.scene.push(pie);
                        return this.updateAndNotifyCurrent(origin)
                };
                Piechart_Navigator.prototype.goOthers = function(pie, origin) {
                var ready;
                        if (!pie.othersStack) {
                pie.othersStack = []
                }
                pie.othersStack.push(pie.offset);
                        ready = this.scene.view.scrollForward(pie, pie.offset + pie.count);
                        if (!ready) {
                this.scene.pendingAction = "forward";
                        this.scene.pendingOffset = null
                }
                this.events.notifySceneChanges({pie: true});
                        return this.chart.notifyChartUpdate(origin)
                };
                Piechart_Navigator.prototype.goPrevious = function(pie, origin) {
                var ready;
                        if (!(pie.offset > 0)) {
                return
                }
                ready = this.scene.view.scrollBackward(pie);
                        if (!ready) {
                this.scene.pendingAction = "back";
                        this.scene.pendingOffset = null
                }
                this.chart.notifyChartUpdate(origin);
                        return this.events.notifySceneChanges({pie: true})
                };
                Piechart_Navigator.prototype.scroll = function(pie, offset) {
                var ready;
                        ready = true;
                        if (pie.offset > offset) {
                ready = this.scene.view.scrollBackward(pie, offset);
                        if (!ready) {
                this.scene.pendingAction = "back";
                        return this.scene.pendingOffset = offset
                }
                } else {
                if (pie.offset < offset) {
                ready = this.scene.view.scrollForward(pie, offset);
                        if (!ready) {
                this.scene.pendingAction = "forward";
                        return this.scene.pendingOffset = offset
                }
                }
                }
                };
                Piechart_Navigator.prototype.updateAndNotifyCurrent = function(origin) {
                var pie;
                        pie = this.scene.peek();
                        this.scene.view.updatePie(pie);
                        this.chart.notifyChartUpdate(origin);
                        return this.events.notifySceneChanges({pie: true})
                };
                Piechart_Navigator.prototype.expandSlice = function(slice, origin) {
                var id, pie;
                        pie = slice.pie;
                        if (pie === this.scene.peek()) {
                if (slice === pie.othersSlice) {
                this.chart.setSelection([]);
                        this.goOthers(pie, origin);
                        return true
                } else {
                if (slice === pie.previousSlice) {
                this.chart.setSelection([]);
                        this.goPrevious(pie, origin);
                        return true
                } else {
                id = slice.id;
                        if (slice.expandable && this.scene.data.canExapnd(id)) {
                this.chart.setSelection([]);
                        this.drillDown(id, origin);
                        return true
                }
                }
                }
                } else {
                this.chart.setSelection([]);
                        this.goBack(origin);
                        return true
                }
                return false
                };
                Piechart_Navigator.prototype.onSceneChange = function(event) {
                var activePie, activePieReady, ids, pie, ready, _i, _j, _len, _len1, _ref, _ref1;
                        activePieReady = false;
                        activePie = this.scene.peek();
                        if (event.changes.dataArrived) {
                ids = event.changes.dataArrivedIds;
                        _ref = this.scene.pies;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                pie = _ref[_i];
                        if (ids.hasOwnProperty(pie.id)) {
                if (pie === activePie) {
                if (this.scene.pendingAction === "forward") {
                ready = this.scene.view.scrollForward(pie, this.scene.pendingOffset)
                } else {
                if (this.scene.pendingAction === "back") {
                ready = this.scene.view.scrollBackward(pie, this.scene.pendingOffset)
                } else {
                ready = this.scene.view.updatePie(pie)
                }
                }
                if (ready) {
                this.scene.pendingAction = null;
                        this.scene.pendingOffset = null
                }
                activePieReady = ready
                } else {
                this.scene.view.updatePie(pie)
                }
                event.changes.pie = true
                }
                }
                }
                if (event.changes.data) {
                _ref1 = this.scene.stack;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                pie = _ref1[_j];
                        if (!pie.data || pie === activePie || event.changes.dataDeep) {
                if (pie === activePie) {
                if (this.scene.pendingAction === "forward") {
                ready = this.scene.view.scrollForward(pie, this.scene.pendingOffset)
                } else {
                if (this.scene.pendingAction === "back") {
                ready = this.scene.view.scrollBackward(pie, this.scene.pendingOffset)
                } else {
                ready = this.scene.view.updatePie(pie)
                }
                }
                if (ready) {
                this.scene.pendingAction = null;
                        this.scene.pendingOffset = null
                }
                activePieReady = ready
                } else {
                this.scene.view.updatePie(pie)
                }
                event.changes.pie = true
                }
                }
                }
                if (activePieReady) {
                return this.chart.notifyChartUpdate(null)
                }
                };
                return Piechart_Navigator
        })();
        var Piechart_InfoPopup;
        Piechart_InfoPopup = (function() {
        function Piechart_InfoPopup(chart) {
        this.chart = chart;
                this.scene = chart.scene;
                this.options = this.scene.settings;
                this.events = chart.events;
                this.currentSlice = null;
                this.x = null;
                this.y = null;
                this.popup = new Base_InfoPopup(chart)
        }
        Piechart_InfoPopup.prototype.previewPointerMove = function(event) {
        return this.onMove(event.x, event.y)
        };
                Piechart_InfoPopup.prototype.doAnimations = function(event) {
                if (this.x !== null && this.y !== null) {
                return this.onMove(this.x, this.y)
                }
                };
                Piechart_InfoPopup.prototype.previewPointerDown = function(event) {
                this.x = this.y = null;
                        return this.setCurrentObject(0, 0, null)
                };
                Piechart_InfoPopup.prototype.previewPointerDrag = function(event) {
                this.x = this.y = null;
                        return this.setCurrentObject(0, 0, null)
                };
                Piechart_InfoPopup.prototype.onPointerOut = function(event) {
                this.x = this.y = null;
                        return this.setCurrentObject(0, 0, null)
                };
                Piechart_InfoPopup.prototype.onMove = function(x, y) {
                var pie, slice;
                        this.x = x;
                        this.y = y;
                        if (!this.options.info.enabled) {
                return
                }
                slice = this.scene.findSliceAt(x, y, this.scene.settings.interaction.selection.tolerance);
                        pie = this.scene.findPieAt(x, y, this.scene.settings.interaction.selection.tolerance);
                        if (pie && !slice) {
                slice = pie.getActiveSlice()
                }
                return this.setCurrentObject(x, y, slice)
                };
                Piechart_InfoPopup.prototype.setCurrentObject = function(x, y, obj) {
                var contents;
                        if (!obj) {
                this.currentSlice = null;
                        return this.popup.hide()
                } else {
                if (obj !== this.currentSlice) {
                contents = this.buildContents(obj);
                        this.popup.show(x, x, y, contents)
                } else {
                this.popup.updateXY(x, x, y)
                }
                return this.currentSlice = obj
                }
                };
                Piechart_InfoPopup.prototype.buildContents = function(slice) {
                var callback;
                        if (this.options.info.contentsFunction) {
                callback = (function(_this) {
                return function(contents) {
                if (slice === _this.currentSlice) {
                return _this.popup.updateContents(contents)
                }
                }
                })(this);
                        return this.options.info.contentsFunction.call(this.scene.api, slice.data, slice, callback)
                } else {
                return slice.label
                }
                };
                return Piechart_InfoPopup
        })();
        var Piechart_PieView, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Piechart_PieView = (function(_super) {
        __extends(Piechart_PieView, _super);
                function Piechart_PieView(chart) {
                this.chart = chart;
                        this.scene = this.chart.scene;
                        this.renderer = new Piechart_PieRenderer(chart);
                        this.animator = new Piechart_Animations(chart);
                        this.layout = new Piechart_PieLayout(chart, this);
                        this.builder = new Piechart_PieBuilder(chart)
                }
        Piechart_PieView.prototype.updatePie = function(pie) {
        return this.builder.updatePie(pie)
        };
                Piechart_PieView.prototype.scrollForward = function(pie, offset) {
                return this.builder.scrollForward(pie, offset)
                };
                Piechart_PieView.prototype.scrollBackward = function(pie, offset) {
                return this.builder.scrollBackward(pie, offset)
                };
                Piechart_PieView.prototype.onSceneChange = function(event) {
                return this.renderer.onSceneChange(event)
                };
                Piechart_PieView.prototype.doAnimations = function(event) {
                var changedPies, pie, pieChanges, _i, _len;
                        if (event.changes.settings || event.changes.pie || event.changes.bounds || true) {
                pieChanges = false;
                        pie = this.scene.peek();
                        if (pie != null) {
                pieChanges || (pieChanges = this.layout.placeStack(pie, event.context))
                }
                }
                changedPies = this.animator.doAnimations(event);
                        for (_i = 0, _len = changedPies.length; _i < _len; _i++) {
                pie = changedPies[_i];
                        this.layout.placeLabels(pie, event.context)
                }
                if (pieChanges || changedPies) {
                return this.chart.notifyPositionChange(event)
                }
                };
                Piechart_PieView.prototype.paintScene = function(event) {
                return this.renderer.paintScene(event)
                };
                Piechart_PieView.prototype.getMovement = function(pie, event) {
                var a0, a1, d0, d1, dd, df, x0, x1, y0, y1;
                        x0 = event.x - event.dx - pie.x;
                        y0 = event.y - event.dy - pie.y;
                        x1 = event.x - pie.x;
                        y1 = event.y - pie.y;
                        a0 = Math.atan2(y0, x0);
                        a1 = Math.atan2(y1, x1);
                        if (a0 - a1 > Math.PI) {
                a1 += Math.PI * 2
                }
                if (a1 - a0 > Math.PI) {
                a0 += Math.PI * 2
                }
                df = (a1 - a0) / (pie.currentEndAngle - pie.currentStartAngle);
                        d0 = Math.sqrt(x0 * x0 + y0 * y0);
                        d1 = Math.sqrt(x1 * x1 + y1 * y1);
                        dd = d1 - d0;
                        return[df, dd]
                };
                Piechart_PieView.prototype.findPieAt = function(px, py, tolerance) {
                var add, distSq, dx, dy, i, mul, pie, r0, r1, r1sq, x, xx, y, _i, _ref;
                        add = this.scene.currentInnerRadius;
                        mul = this.scene.currentRadius - add;
                        for (i = _i = _ref = this.scene.pies.length - 1; _i >= 0; i = _i += - 1) {
                pie = this.scene.pies[i];
                        x = pie.x;
                        y = pie.y;
                        r0 = pie.currentInnerRadius * mul + add;
                        r1 = pie.currentRadius * mul + add;
                        xx = Math.max(0, r0 - tolerance);
                        xx = r1 + tolerance;
                        r1sq = xx * xx;
                        dx = px - x;
                        dy = py - y;
                        distSq = dx * dx + dy * dy;
                        if (pie.background) {
                if (distSq <= r1sq) {
                return pie
                }
                }
                }
                return null
                };
                Piechart_PieView.prototype.findSliceAt = function(px, py, tolerance) {
                var a1, ad, add, cosa0, cosa1, dist, distSq, dp1, dp2, dx, dy, i, mul, pie, r0, r0sq, r1, r1sq, selectionDistance, sina0, sina1, slice, x, xx, y, _i, _j, _len, _ref, _ref1;
                        add = this.scene.currentInnerRadius;
                        mul = this.scene.currentRadius - add;
                        selectionDistance = this.scene.settings.interaction.selection.cutoutDistance;
                        for (i = _i = _ref = this.scene.pies.length - 1; _i >= 0; i = _i += - 1) {
                pie = this.scene.pies[i];
                        if (pie.background) {
                continue
                }
                x = pie.x;
                        y = pie.y;
                        r0 = pie.currentInnerRadius * mul + add;
                        r1 = pie.currentRadius * mul + add;
                        xx = Math.max(0, r0 - tolerance);
                        r0sq = xx * xx;
                        xx = r1 + tolerance + selectionDistance;
                        r1sq = xx * xx;
                        dx = px - x;
                        dy = py - y;
                        distSq = dx * dx + dy * dy;
                        if (distSq < r0sq || distSq > r1sq) {
                continue
                }
                dist = Math.sqrt(distSq);
                        dx /= dist;
                        dy /= dist;
                        a1 = pie.currentStartAngle;
                        ad = pie.currentEndAngle - a1;
                        a1 += ad * pie.scrollOffset;
                        cosa1 = Math.cos(a1);
                        sina1 = Math.sin(a1);
                        _ref1 = pie.allSlices;
                        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
                slice = _ref1[_j];
                        cosa0 = cosa1;
                        sina0 = sina1;
                        a1 += ad * slice.currentFraction;
                        cosa1 = Math.cos(a1);
                        sina1 = Math.sin(a1);
                        if (dist >= r0 + slice.cutoutDistance && dist <= r1 + slice.cutoutDistance) {
                dp1 = sina0 * dx - cosa0 * dy;
                        dp2 = sina1 * dx - cosa1 * dy;
                        if (dp1 < 0 && dp2 > 0) {
                return slice
                }
                if (Math.abs(ad * slice.currentFraction) > Math.PI) {
                if ((dp1 < 0 && dp2 < 0) || (dp1 > 0 && dp2 > 0)) {
                return slice
                }
                }
                }
                }
                }
                return this.findLabelAt(px, py, tolerance)[0]
                };
                Piechart_PieView.prototype.findLabelAt = function(px, py, tolerance) {
                var i, l, pie, slice, x, y, _i, _j, _len, _ref, _ref1;
                        for (i = _i = _ref = this.scene.pies.length - 1; _i >= 0; i = _i += - 1) {
                pie = this.scene.pies[i];
                        x = px - pie.x;
                        y = py - pie.y;
                        _ref1 = pie.allSlices;
                        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
                slice = _ref1[_j];
                        if (slice.currentLabel) {
                l = slice.currentLabel;
                        if (l.visible && l.x - l.hwidth <= x && l.x + l.hwidth >= x && l.y - l.hheight <= y && l.y + l.hheight >= y) {
                return[slice, l]
                }
                }
                if (slice.currentInsideLabel) {
                l = slice.currentInsideLabel;
                        if (l.visible && l.x - l.hwidth <= x && l.x + l.hwidth >= x && l.y - l.hheight <= y && l.y + l.hheight >= y) {
                return[slice, l]
                }
                }
                }
                }
                return[null, null]
                };
                return Piechart_PieView
        })(Piechart_View);
        var Facetchart_Layer, Facetchart_Renderer;
        Facetchart_Layer = (function() {
        function Facetchart_Layer(event, chart, facet) {
        var va, _i, _len, _ref;
                this.chart = chart;
                this.facet = facet;
                this.scene = this.chart.scene;
                this.valueAxis = {};
                this.facetAxis = new Facetchart_FacetAxis(chart, facet);
                this.xes = [];
                _ref = this.scene.settings.computedValueAxisList;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        va = _ref[_i];
                this.valueAxis[va.id] = new Linearchart_ValueAxis(chart, va)
        }
        this.r = new Linearchart_Renderer(this.chart, this.valueAxis);
                Linearchart_ValueAxis.placeAxis(event.context, this.valueAxis)
        }
        Facetchart_Layer.prototype.updateSize = function(event) {
        return Linearchart_ValueAxis.placeAxis(event.context, this.valueAxis)
        };
                Facetchart_Layer.prototype.doAnimations = function(event, bounds) {
                var changes, h, i, left, max, min, name, offset, right, series, si, ss, times, tradd, trmul, values, vv, w, x, x0, x1, xes, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4, _results;
                        x = bounds[0], y = bounds[1], w = bounds[2], h = bounds[3];
                        offset = this.facet.offset;
                        left = this.facet.left;
                        right = this.facet.right;
                        left = x + w * left;
                        right = x + w * right;
                        x0 = Math.max(x, left);
                        x1 = Math.min(x + w, right);
                        this.bounds = [x0, y, x1 - x0, h];
                        changes = event.changes;
                        if (changes.position || changes.data || changes.bounds || changes.items) {
                trmul = (right - left) / (this.facet.to - this.facet.from);
                        tradd = left - this.facet.from * trmul;
                        times = [];
                        xes = [];
                        min = Math.max(offset, Math.floor(this.facet.from - 1));
                        max = Math.min(offset + this.facet.count, Math.ceil(this.facet.to + 1));
                        for (i = _i = min, _ref = max - 1; _i <= _ref; i = _i += 1) {
                times.push(i);
                        xes.push(i * trmul + tradd)
                }
                times.push(max);
                        xes.push(max * trmul + tradd);
                        this.xes = xes;
                        values = [];
                        _ref1 = this.scene.settings.computedSeries;
                        for (si = _j = 0, _len = _ref1.length; _j < _len; si = ++_j) {
                series = _ref1[si];
                        vv = [];
                        ss = [];
                        for (i = _k = min, _ref2 = max - 1; _k <= _ref2; i = _k += 1) {
                vv.push(this.facet.items[i - offset].values[si].value);
                        ss.push(this.facet.items[i - offset].values[si])
                }
                values.push({xes: xes, times: times, fromIndex: 0, toIndex: times.length, values: vv, style: ss})
                }
                this.r.process(values)
                }
                _ref3 = this.valueAxis;
                        for (name in _ref3) {
                x = _ref3[name];
                        x.process(event)
                }
                this.r.afterProcess();
                        _ref4 = this.valueAxis;
                        _results = [];
                        for (name in _ref4) {
                x = _ref4[name];
                        _results.push(x.afterProcess(event))
                }
                return _results
                };
                Facetchart_Layer.prototype.paintScene = function(event) {
                var context, h, name, o, w, x, y, _ref, _ref1, _ref2;
                        context = event.context;
                        _ref = this.bounds, x = _ref[0], y = _ref[1], w = _ref[2], h = _ref[3];
                        context.globalAlpha = this.facet.opacity;
                        _ref1 = this.valueAxis;
                        for (name in _ref1) {
                o = _ref1[name];
                        o.paintUnder(context, context)
                }
                Base_Graphics.pushClip(context, x, y, w, h);
                        this.r.paint(event);
                        Base_Graphics.popClip(context);
                        this.facetAxis.paint(event, this.bounds[0], this.bounds[2], this.xes);
                        _ref2 = this.valueAxis;
                        for (name in _ref2) {
                o = _ref2[name];
                        o.paint(context, context)
                }
                return context.globalAlpha = 1
                };
                return Facetchart_Layer
        })();
        Facetchart_Renderer = (function() {
        Facetchart_Renderer.prototype.animationPriority = 999;
                function Facetchart_Renderer(chart) {
                this.chart = chart;
                        this.scene = this.chart.scene;
                        this.events = this.chart.events;
                        this.layers = []
                }
        Facetchart_Renderer.prototype.onSceneChange = function(event) {
        var changes, f, i, l, layer, _i, _j, _len, _len1, _ref, _ref1, _results;
                changes = event.changes;
                if (changes.settings || changes.navigation) {
        if (changes.settings && (changes.settingsChanges.valueAxis || changes.settingsChanges.series)) {
        this.layers = []
        }
        _ref = this.layers;
                for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        layer = _ref[i];
                if (layer.facet !== this.scene.stack[i]) {
        this.layers = this.layers.slice(0, i)
        }
        }
        while (this.layers.length < this.scene.stack.length) {
        f = this.scene.stack[this.layers.length];
                l = new Facetchart_Layer(event, this.chart, f);
                this.layers.push(l)
        }
        }
        if (changes.bounds) {
        _ref1 = this.layers;
                _results = [];
                for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        l = _ref1[_j];
                _results.push(l.updateSize(event))
        }
        return _results
        }
        };
                Facetchart_Renderer.prototype.doAnimations = function(event) {
                var h, layer, w, x, y, _i, _len, _ref, _results;
                        x = this.scene.x0;
                        y = this.scene.y0;
                        w = this.scene.width;
                        h = this.scene.height;
                        _ref = this.layers;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                layer = _ref[_i];
                        _results.push(layer.doAnimations(event, [x, y, w, h]))
                }
                return _results
                };
                Facetchart_Renderer.prototype.paintScene = function(event) {
                var layer, _i, _len, _ref, _results;
                        _ref = this.layers;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                layer = _ref[_i];
                        _results.push(layer.paintScene(event))
                }
                return _results
                };
                Facetchart_Renderer.prototype.exportData = function(from, to) {
                return this.layers[this.layers.length - 1].r.exportData(from, to)
                };
                return Facetchart_Renderer
        })();
        var Facetchart_InfoPopup, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Facetchart_InfoPopup = (function(_super) {
        __extends(Facetchart_InfoPopup, _super);
                function Facetchart_InfoPopup(chart) {
                Facetchart_InfoPopup.__super__.constructor.call(this, chart)
                }
        Facetchart_InfoPopup.prototype.doAnimations = function(event) {
        if (event.changes.position || event.changes.navigation) {
        return this.updatePopup(event)
        }
        };
                Facetchart_InfoPopup.prototype.getPopupMouseMoved = function(x, y, prevT0, prevT1, prevContents) {
                var content, facet, t, t0, t1;
                        if (!(this.scene.xyInChartOrBottom(x, y) && this.scene.activeFacet)) {
                return null
                }
                facet = this.scene.activeFacet;
                        t = this.scene.xToPosition(x);
                        t0 = Math.floor(t);
                        t1 = Math.ceil(t);
                        if (t0 === t1) {
                t1 = t0 + 1
                }
                if (t0 < facet.offset || t1 > facet.offset + facet.count) {
                return null
                }
                if (t0 === prevT0 && t1 === prevT1) {
                return[t0, t1, prevContents]
                }
                content = this.buildContent(facet, t0, t1);
                        return[t0, t1, content]
                };
                Facetchart_InfoPopup.prototype.buildContent = function(facet, t0, t1, info) {
                var callback, item, label, valueHtml;
                        item = facet.items[t0 - facet.offset];
                        if (this.scene.settings.info.contentsFunction) {
                callback = (function(_this) {
                return function(contents) {
                if (t0 === _this.t0 && t1 === _this.t1) {
                return _this.popup.updateContents(contents)
                }
                }
                })(this);
                        return this.scene.settings.info.contentsFunction.call(this.scene.api, item.data, item, callback)
                } else {
                info = this.chart.renderer.exportData(t0, t1);
                        valueHtml = this.buildValues(info);
                        label = item.label || "";
                        return"<em></em><strong>" + label + "</strong>" + valueHtml
                }
                };
                Facetchart_InfoPopup.prototype.buildValues = function(info) {
                var color, group, out, param, series, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
                        out = "";
                        for (_i = 0, _len = info.length; _i < _len; _i++) {
                group = info[_i];
                        if (group.name && group.data.length > 1) {
                out += "<h3>" + group.name + "</h3>"
                }
                out += '<table cellspacing="0">';
                        _ref = group.data;
                        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                series = _ref[_j];
                        out += "<tr><td";
                        color = series.config.style.lineColor || series.config.style.fillColor;
                        if (color) {
                out += ' style="color: ' + color + '"'
                }
                out += "> " + (series.name || group.name) + "</td>";
                        if (!series.values) {
                out += "<td>No data</td>"
                } else {
                if (series.values.count > 1 && this.scene.settings.info.aggregations && this.scene.settings.info.aggregations.length > 0) {
                _ref1 = this.scene.settings.info.aggregations;
                        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                param = _ref1[_k];
                        out += "<td>" + param + "</td><td>" + series.values[param] + "</td>"
                }
                } else {
                out += "<td>" + series.values.sum + "</td>"
                }
                }
                out += "</tr>"
                }
                out += "</table>"
                }
                return out
                };
                return Facetchart_InfoPopup
        })(Linearchart_InfoPopup);
        var Base_Bar_CycleButton, Base_MultiBar, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        }, __bind = function(fn, me) {
return function() {
return fn.apply(me, arguments)
        }
};
        Base_Bar_CycleButton = (function(_super) {
        __extends(Base_Bar_CycleButton, _super);
                function Base_Bar_CycleButton(options) {
                this.options = {label: null, type: "gear", enclosureClass: "enc-bare", activeClass: null, onClick: (function(_this) {
                return function() {
                options.multibar.cycleNext(options.nextItemNo);
                        return options.multibar.chart.updateSize(true)
                }
                })(this)};
                        Base_Helpers.configure(this.options, options);
                        Base_Bar_CycleButton.__super__.constructor.call(this, this.options)
                }
        return Base_Bar_CycleButton
        })(Base_Bar_Button);
        Base_MultiBar = (function(_super) {
        __extends(Base_MultiBar, _super);
                function Base_MultiBar(container, chart, settings) {
                var def, enabled, i, item, v, _i, _len;
                        this.container = container;
                        this.chart = chart;
                        this.settings = settings;
                        this.cycleTo = __bind(this.cycleTo, this);
                        Base_MultiBar.__super__.constructor.call(this, {});
                        this.currentBarIndex = - 1;
                        this.ui.container = container;
                        enabled = this.settings.enabled;
                        def = this.settings["default"];
                        if ((def != null) && (!Base_Helpers.arrayContains(enabled, def))) {
                enabled.push(def)
                }
                for (i = _i = 0, _len = enabled.length; _i < _len; i = ++_i) {
                v = enabled[i];
                        item = this.buildToolbar(v, container);
                        if (item) {
                if (enabled.length > 1) {
                item.addItem(new Base_Bar_CycleButton(), {spot: "right", multibar: this, nextItemNo: (i + 1) % enabled.length})
                }
                this.addItem(item)
                }
                if (def === v) {
                this.cycleTo(i)
                }
                }
                if (this.currentBarIndex === - 1) {
                this.cycleTo(0)
                }
                }
        Base_MultiBar.prototype.buildToolbar = function(name, container) {
        throw"Need to implement in subclass"
        };
                Base_MultiBar.prototype.cycleTo = function(itemNo) {
                if (this.currentBarIndex === itemNo) {
                return
                }
                if (this.currentBarIndex !== - 1) {
                this.items[this.currentBarIndex].obj.hide(true)
                }
                this.currentBarIndex = itemNo;
                        return this.items[this.currentBarIndex].obj.show(true)
                };
                Base_MultiBar.prototype.getLocationPreference = function() {
                return this.items[this.currentBarIndex].obj.getLocationPreference()
                };
                Base_MultiBar.prototype.setPosition = function(x, y, width) {
                return this.items[this.currentBarIndex].obj.setPosition(x, y, width)
                };
                return Base_MultiBar
        })(Base_View);
        var Timechart_Infobar, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Infobar = (function(_super) {
        __extends(Timechart_Infobar, _super);
                Timechart_Infobar.prototype.relativeClass = "infobar";
                function Timechart_Infobar(options, chart) {
                this.chart = chart;
                        Timechart_Infobar.__super__.constructor.call(this, options, chart);
                        if (this.chart.scene.settings.toolbars.logScale) {
                this.scale = this.addItem(new Linearchart_Bar_LinLogLabel(), {spot: "right"})
                }
                if (this.chart.scene.settings.toolbars.periodSelection) {
                this.period = this.addItem(new Timechart_Bar_PeriodLabel(), {spot: "right"})
                }
                if (this.chart.scene.settings.toolbars.displayUnit) {
                this.period = this.addItem(new Timechart_Bar_DisplayUnitLabel(), {spot: "right"})
                }
                }
        return Timechart_Infobar
        })(Base_Bar);
        var Base_Toolbar, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Base_Toolbar = (function(_super) {
        __extends(Base_Toolbar, _super);
                function Base_Toolbar() {
                return Base_Toolbar.__super__.constructor.apply(this, arguments)
                }
        Base_Toolbar.prototype.relativeClass = "toolbar";
                Base_Toolbar.prototype.panScene = true;
                return Base_Toolbar
        })(Base_Bar);
        var Linearchart_Bar_ExportDropdown, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Linearchart_Bar_ExportDropdown = (function(_super) {
        __extends(Linearchart_Bar_ExportDropdown, _super);
                function Linearchart_Bar_ExportDropdown(options) {
                this.options = {css: "export", title: "Export Data", setInitialValue: false, getOptionName: (function(o) {
                return o.name
                }), getOptionIdentifier: (function(o) {
                return o.toString()
                }), onChange: (function(_this) {
                return function(obj) {
                var k, v;
                        k = obj.selected;
                        v = _this.options.data[k];
                        return Base_Export["export"](_this.parent.chart.api, v)
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Linearchart_Bar_ExportDropdown.__super__.constructor.call(this, this.options)
                }
        Linearchart_Bar_ExportDropdown.prototype.init = function() {
        this.options.data = [{name: "For Office and Web (jpeg)", type: "jpeg", scaling: 1, transparent: false, dimensions: {}}, {name: "For Photoshop (png)", type: "png", scaling: 3, transparent: true, dimensions: {}}, {name: "For Printer (pdf)", type: "pdf", transparent: false, dimensions: {}}];
                return Linearchart_Bar_ExportDropdown.__super__.init.call(this)
        };
                return Linearchart_Bar_ExportDropdown
        })(Base_Bar_Dropdown);
        var Timechart_Bar_PeriodDayButton, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Bar_PeriodDayButton = (function(_super) {
        __extends(Timechart_Bar_PeriodDayButton, _super);
                function Timechart_Bar_PeriodDayButton(options) {
                this.options = {type: "day", title: "View data for the last day", period: "1 d", onClick: (function(_this) {
                return function(obj) {
                return _this.setOption()
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Timechart_Bar_PeriodDayButton.__super__.constructor.call(this, this.options)
                }
        return Timechart_Bar_PeriodDayButton
        })(Timechart_Bar_PeriodButton);
        var Timechart_Bar_PeriodWeekButton, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Bar_PeriodWeekButton = (function(_super) {
        __extends(Timechart_Bar_PeriodWeekButton, _super);
                function Timechart_Bar_PeriodWeekButton(options) {
                this.options = {type: "week", title: "View data for the last week", period: "1 w", onClick: (function(_this) {
                return function(obj) {
                return _this.setOption()
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Timechart_Bar_PeriodWeekButton.__super__.constructor.call(this, this.options)
                }
        return Timechart_Bar_PeriodWeekButton
        })(Timechart_Bar_PeriodButton);
        var Timechart_Bar_PeriodMonthButton, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Bar_PeriodMonthButton = (function(_super) {
        __extends(Timechart_Bar_PeriodMonthButton, _super);
                function Timechart_Bar_PeriodMonthButton(options) {
                this.options = {type: "month", title: "View data for the last month", period: "1 M", onClick: (function(_this) {
                return function(obj) {
                return _this.setOption()
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Timechart_Bar_PeriodMonthButton.__super__.constructor.call(this, this.options)
                }
        return Timechart_Bar_PeriodMonthButton
        })(Timechart_Bar_PeriodButton);
        var Timechart_Bar_PeriodDropdown, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Bar_PeriodDropdown = (function(_super) {
        __extends(Timechart_Bar_PeriodDropdown, _super);
                function Timechart_Bar_PeriodDropdown(options) {
                this.options = {css: "none", title: "Select period for which to show the data", setInitialValue: false, getOptionName: (function(o) {
                return o.name
                }), getOptionIdentifier: (function(o) {
                return o.displayAnchor + o.displayPeriod
                }), onChange: (function(_this) {
                return function(obj) {
                var k, p;
                        k = obj.selected;
                        if (k > 0) {
                p = obj.options.data[k];
                        return _this.chart().setDisplayPeriod(p.displayPeriod, p.displayAnchor, p.displayUnit, true, "user")
                }
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Timechart_Bar_PeriodDropdown.__super__.constructor.call(this, this.options)
                }
        Timechart_Bar_PeriodDropdown.prototype.init = function() {
        var chart, periods;
                chart = this.chart();
                periods = [{name: chart.settings.localization.custom}].concat(chart.settings.toolbars.advanced.periodsParsed);
                this.options.data = periods;
                this.chart().on("timeChange", (function(_this) {
        return function(e) {
        return _this.updateOption(e, 1)
        }
        })(this));
                return Timechart_Bar_PeriodDropdown.__super__.init.call(this)
        };
                Timechart_Bar_PeriodDropdown.prototype.updateOption = function(ev, fts) {
                var chart, found, k, n, p, v, _i, _len, _ref;
                        chart = this.chart();
                        if (ev.changes && ev.changes.time || fts) {
                p = this.options.data[this.selected];
                        if ((p != null) && chart.isThisDisplayPeriod(p.displayPeriod, p.displayAnchor)) {
                return
                }
                found = false;
                        _ref = this.options.data;
                        for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
                v = _ref[k];
                        if (chart.isThisDisplayPeriod(v.displayPeriod, v.displayAnchor)) {
                n = k;
                        found = true;
                        break
                }
                }
                if (!found) {
                n = 0
                }
                return this.setOption(n, 1)
                }
                };
                return Timechart_Bar_PeriodDropdown
        })(Base_Bar_Dropdown);
        var Timechart_Bar_DisplayUnitDropdown, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Bar_DisplayUnitDropdown = (function(_super) {
        __extends(Timechart_Bar_DisplayUnitDropdown, _super);
                function Timechart_Bar_DisplayUnitDropdown(options) {
                this.options = {css: "bars", title: "Select units in which to show the data", setInitialValue: false, getOptionName: (function(o) {
                return o.name
                }), getOptionIdentifier: (function(o) {
                return o.toString()
                }), onChange: (function(_this) {
                return function(obj) {
                var k, p;
                        k = obj.selected;
                        p = obj.options.data[k];
                        return _this.chart().setDisplayUnit(p.toString(), true, _this.chart().scene.settings.toolbars.advanced.displayUnit.dynamic, null, "user")
                }
                })(this), onSceneChange: (function(_this) {
                return function(ev) {
                return _this.updateOption(ev)
                }
                })(this)};
                        Base_Helpers.extend(this.options, options);
                        Timechart_Bar_DisplayUnitDropdown.__super__.constructor.call(this, this.options)
                }
        Timechart_Bar_DisplayUnitDropdown.prototype.init = function() {
        this.options.data = this.chart().scene.settings.area.displayUnitsParsed;
                return Timechart_Bar_DisplayUnitDropdown.__super__.init.call(this)
        };
                Timechart_Bar_DisplayUnitDropdown.prototype.paintScene = function() {
                return this.updateOption(null, 1)
                };
                Timechart_Bar_DisplayUnitDropdown.prototype.updateOption = function(ev, fps) {
                var bu, chart;
                        chart = this.chart();
                        if ((ev && ev.changes.time) || fps) {
                bu = chart.scene.displayUnit;
                        if (bu === null || bu === this.displayUnitValue) {
                return
                }
                this.displayUnitValue = bu;
                        return this.setOption(bu, true)
                }
                };
                return Timechart_Bar_DisplayUnitDropdown
        })(Base_Bar_Dropdown);
        var Base_Impl, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        }, __hasProp = {}.hasOwnProperty;
        Base_Impl = (function() {
        Base_Impl.prototype.container = null;
                Base_Impl.prototype.settings = null;
                Base_Impl.prototype.scene = null;
                Base_Impl.prototype.layers = null;
                Base_Impl.prototype.removed = false;
                Base_Impl.prototype.EVENT_NAMES = null;
                Base_Impl.prototype.bigfoot = [0, "//zoomcharts.com/logo-development.png", "//zoomcharts.com"];
                Base_Impl.prototype.curState = null;
                Base_Impl.prototype.goingBack = false;
                Base_Impl.prototype.chartUpdateOrigin = null;
                Base_Impl.prototype.currentNavigationState = null;
                Base_Impl.prototype.previousSizeW = 0;
                Base_Impl.prototype.previousSizeH = 0;
                Base_Impl.prototype.onAssetsLoaded = function() {
                return Base_Helpers.error("Need to override onAssetsLoaded")
                };
                Base_Impl.prototype.onRemove = function() {
                return Base_Helpers.error("Need to override onRemove")
                };
                Base_Impl.prototype.onSizeChanged = function(width, height) {
                return Base_Helpers.error("Need to override onSizeChanged")
                };
                Base_Impl.prototype.onSettingsChanged = function(changes) {
                return Base_Helpers.error("Need to override onSettingsChanged")
                };
                Base_Impl.prototype.addData = function(data, sourceId) {
                return Base_Helpers.error("Add data not implemented for this chart")
                };
                Base_Impl.prototype.removeData = function(data, sourceId) {
                return Base_Helpers.error("Remove data not implemented for this chart")
                };
                Base_Impl.prototype.reloadData = function() {
                return Base_Helpers.error("Reload data not implemented for this chart")
                };
                Base_Impl.prototype.replaceData = function() {
                return Base_Helpers.error("Replace data not implemented for this chart")
                };
                function Base_Impl(settings) {
                this.loadAssets = __bind(this.loadAssets, this);
                        this.defaultError = __bind(this.defaultError, this);
                        this.chartUpdateNotify = __bind(this.chartUpdateNotify, this);
                        this._windowResize = __bind(this._windowResize, this);
                        var key, name, value, _ref;
                        if (!this.EVENT_NAMES) {
                this.EVENT_NAMES = {};
                        _ref = settings.events;
                        for (name in _ref) {
                value = _ref[name];
                        if (name.indexOf("on") === 0) {
                key = name[2].toLowerCase() + name.slice(3);
                        this.EVENT_NAMES[name] = key;
                        this.EVENT_NAMES[key] = key
                }
                }
                }
                if (!settings.container) {
                throw"Chart container not set"
                }
                if (!(settings.container.nodeType > 0)) {
                throw"Chart container not a dom object"
                }
                }
        Base_Impl.prototype.initialize = function(api, components) {
        var browser, sx, sy, _ref;
                this.api = api;
                this.eventListeners = {};
                this.assetsLoaded = true;
                this.loadedAssets = {};
                this.imgAssets = {};
                if (this.settings.advanced.assets != null) {
        this.loadAssets(this.settings.advanced.assets)
        }
        browser = Base_Helpers.detectBrowser();
                _ref = Base_Helpers.canvasScaling(), sx = _ref[0], sy = _ref[1];
                if ((this.settings.advanced.highDpi.hasOwnProperty(browser) && this.settings.advanced.highDpi[browser]) || this.settings.advanced.highDpi["default"]) {
        this.scene.canvasScaleX = sx;
                this.scene.canvasScaleY = sy
        } else {
        this.scene.canvasScaleX = 1;
                this.scene.canvasScaleY = 1
        }
        this.container = this.settings.container;
                if (this.container._DVSL_ChartInstance !== void 0 && this.container._DVSL_ChartInstance !== null) {
        this.container._DVSL_ChartInstance.remove()
        }
        this.container._DVSL_ChartInstance = this;
                this.container.appendChild(this.layers.container);
                this.events = new Base_ChartEvents(this.layers.mouseTrackLayer, this.layers.canvas, this);
                this.title = new Base_Title(this);
                this.credits = new Base_Credits(this, this.scene.settings.credits);
                return this.api._impl = this
        };
                Base_Impl.prototype.finalInitialize = function() {
                var diff, f, l, messages, s, time;
                        this.events.addElement(this.title);
                        this.events.addElement(this.credits);
                        this.events.addElement(new Base_Resizer(this));
                        this.events.addElement(new Base_MessagesOverlay(this));
                        if (this.settings.advanced.trackTouches) {
                this.events.addElement(new Base_TouchMarkers(this.scene))
                }
                l = this.bigfoot;
                        if (l[0] > 0) {
                time = new Date().getTime();
                        diff = time - l[0];
                        if (diff > 0) {
                messages = ["Trial expired", "Trial expired", "It expired " + (moment.duration(diff).humanize()) + " ago", "Use the link at bottom-right to upgrade"];
                        this.scene.setMessage("d", messages[0], 1000);
                        this._xcount = 0;
                        f = (function(_this) {
                        return function() {
                        if (_this._xcount < messages.length - 1) {
                        _this._xcount += 1
                        } else {
                        Base_Helpers.openUrl(l[2])
                        }
                        _this.scene.setMessage("d", messages[_this._xcount], 1000);
                                return _this.updateSettings({area: {style: {fillColor: "rgba(255,230,230, " + (Math.min(1, _this._xcount / messages.length)) + ")"}}, advanced: {style: {messageTextStyle: {font: "" + (15 + _this._xcount * 5) + "px Arial"}}}})
                        }
                        })(this);
                        this.events.addElement({previewPointerUp: f})
                } else {
                if (diff > - 604800000) {
                this.scene.setMessage("d", "Trial ending soon, " + (moment.duration( - diff).humanize()) + " remainig", 1000)
                }
                }
                s = {url: l[2], image: l[1] + "?t=" + time, imageExport: Base_images_logo, imageScaling: 1, location: "inside", enabled: true, enabledOnExport: true};
                        this.events.addElement(new Base_Credits(this, s))
                } else {
                if (l[0] < 0) {
                this.scene.getAssetImage()
                }
                }
                Base_Helpers.listen(window, "resize", this._windowResize);
                        this.updateSize();
                        this.events.notifySceneChanges({settings: true, settingsChanges: this.scene.settings, data: true, bounds: true});
                        return this.updateEvents({}, this.settings.events)
                };
                Base_Impl.prototype.updateSettings = function(newSettings, origin) {
                var changes, old;
                        if (origin == null) {
                origin = null
                }
                this.log("Update Settings, " + (JSON.stringify(newSettings)));
                        old = Base_Helpers.clone(this.settings.events);
                        changes = this.settings.apply(newSettings);
                        if (this.removed) {
                return
                }
                if (changes.events) {
                this.updateEvents(old, this.settings.events)
                }
                if (changes.advanced && changes.advanced.assets) {
                this.loadAssets(this.settings.advanced.assets)
                }
                if (changes.width || changes.height || changes.maxWidth || changes.minWidth || changes.minHeight || changes.maxHeight) {
                this.updateSize(true)
                }
                this.onSettingsChanged(changes);
                        this.events.notifySceneChanges({settings: true, settingsChanges: changes});
                        if (origin) {
                return this.notifySettingsChanged(changes, origin)
                }
                };
                Base_Impl.prototype.remove = function() {
                this.removed = true;
                        this.events.remove();
                        this.container.removeChild(this.layers.container);
                        this.onRemove();
                        this.layers = null;
                        this.scene = null;
                        this.events = null;
                        this.container._DVSL_ChartInstance = void 0;
                        return Base_Helpers.unlisten(window, "resize", this._windowResize)
                };
                Base_Impl.prototype._windowResize = function() {
                return this.updateSize(false)
                };
                Base_Impl.prototype.updateSize = function(force) {
                var clientHeight, clientWidth, minHeight, minWidth;
                        if (force == null) {
                force = false
                }
                if (this.removed) {
                return
                }
                clientWidth = this.settings.width;
                        clientHeight = this.settings.height;
                        minWidth = 0;
                        minHeight = 0;
                        if (this.layers.container.style.display !== "") {
                minWidth = this.settings.minWidth;
                        minHeight = this.settings.minHeight
                }
                if (!clientWidth) {
                clientWidth = parseInt(Math.max(minWidth, Math.min(this.settings.maxWidth, this.scene.settings.container.clientWidth)))
                }
                if (!clientHeight) {
                clientHeight = parseInt(Math.max(minHeight, Math.min(this.settings.maxHeight, this.scene.settings.container.clientHeight)))
                }
                if (clientWidth !== this.previousSizeW || clientHeight !== this.previousSizeH || force) {
                this.layers.container.style.height = clientHeight + "px";
                        this.layers.container.style.width = clientWidth + "px";
                        this.log("Update size, " + clientHeight + ", " + clientWidth);
                        this.previousSizeH = clientHeight;
                        this.previousSizeW = clientWidth;
                        this.scene.chartHeight = clientHeight;
                        this.scene.chartWidth = clientWidth;
                        this.events.mouseEvents.updateContainerPosition();
                        return this.onSizeChanged(clientWidth, clientHeight)
                }
                };
                Base_Impl.prototype.on = function(event, handler) {
                event = this.EVENT_NAMES[event];
                        if (!event) {
                this.error("Unrecognized event name: " + event);
                        return
                }
                if (!this.eventListeners[event]) {
                this.eventListeners[event] = []
                }
                return this.eventListeners[event].push(handler)
                };
                Base_Impl.prototype.off = function(event, handler) {
                event = this.EVENT_NAMES[event];
                        if (!event) {
                this.error("Unrecognized event name: " + event);
                        return
                }
                if (this.eventListeners[event] != null) {
                return Base_Helpers.removeFromArray(this.eventListeners[event], handler)
                }
                };
                Base_Impl.prototype.updateEvents = function(oldSettings, newSettings) {
                var event, prop, _ref, _results;
                        _ref = this.EVENT_NAMES;
                        _results = [];
                        for (prop in _ref) {
                event = _ref[prop];
                        if (oldSettings[prop] != null) {
                this.off(event, oldSettings[prop])
                }
                if (newSettings[prop] != null) {
                _results.push(this.on(event, newSettings[prop]))
                } else {
                _results.push(void 0)
                }
                }
                return _results
                };
                Base_Impl.prototype.notifyHoverChanged = function(e) {
                e.origin = "user";
                        return this.dispatchEventParams("hoverChange", this.extendEventParams(e), null)
                };
                Base_Impl.prototype.notifyDoubleClick = function(e) {
                e.origin = "user";
                        return this.dispatchEvent("doubleClick", this.extendEventParams(e), this.defaultDoubleClick)
                };
                Base_Impl.prototype.notifyRightClick = function(e) {
                e.origin = "user";
                        return this.dispatchEvent("rightClick", this.extendEventParams(e), this.defaultRightClick)
                };
                Base_Impl.prototype.notifyClick = function(e) {
                e.origin = "user";
                        return this.dispatchEvent("click", this.extendEventParams(e), this.defaultClick)
                };
                Base_Impl.prototype.notifyAnimationDone = function() {
                return this.dispatchEventParams("animationDone", this.extendEventParams({}), null)
                };
                Base_Impl.prototype.notifySelectionChanged = function(origin) {
                return this.dispatchEventParams("selectionChange", this.extendEventParams({origin: origin}), null)
                };
                Base_Impl.prototype.notifySettingsChanged = function(changes, origin) {
                return this.dispatchEventParams("settingsChange", this.extendEventParams({changes: changes, origin: origin}), null)
                };
                Base_Impl.prototype.notifyPositionChange = function(e) {
                e.origin = "user";
                        return this.dispatchEventParams("positionChange", this.extendEventParams(e), null)
                };
                Base_Impl.prototype.notifyChartUpdate = function(origin) {
                var time, timeout;
                        timeout = this.scene.settings.events.chartUpdateDelay;
                        time = new Date().getTime();
                        if (origin) {
                this.chartUpdateWasBack = this.goingBack;
                        this.chartUpdateOrigin = origin;
                        this.chartUpdateTime = time
                }
                timeout = this.chartUpdateTime + timeout - time;
                        if (timeout > 0) {
                return this.chartUpdateTimeout = setTimeout(this.chartUpdateNotify, timeout)
                } else {
                return this.chartUpdateNotify()
                }
                };
                Base_Impl.prototype.cancelChartUpdateNotify = function() {
                this.chartUpdateOrigin = null;
                        if (this.chartUpdateTimeout) {
                clearTimeout(this.chartUpdateTimeout);
                        return this.chartUpdateTimeout = null
                }
                };
                Base_Impl.prototype.chartUpdateNotify = function() {
                var origin, state;
                        if (!this.chartUpdateOrigin) {
                return
                }
                state = this.saveNavigation();
                        if (state && (!this.curState || JSON.stringify(state) !== JSON.stringify(this.curState))) {
                if (!this.chartUpdateWasBack && this.curState) {
                this.scene.pushBack(this.curState)
                }
                this.curState = state;
                        origin = this.chartUpdateOrigin;
                        this.chartUpdateOrigin = null;
                        return this.doChartUpdateNotify(origin)
                }
                };
                Base_Impl.prototype.back = function(animate, origin) {
                var state;
                        if (animate == null) {
                animate = true
                }
                if (origin == null) {
                origin = "api"
                }
                if (this.scene.backStack.length === 0) {
                return false
                }
                state = this.scene.backStack.pop();
                        this.goingBack = true;
                        this.restoreNavigation(state, animate, origin);
                        return this.goingBack = false
                };
                Base_Impl.prototype.saveNavigation = function() {
                return Base_Helpers.error("Need to override saveNavigation")
                };
                Base_Impl.prototype.restoreNavigation = function(state, animate, origin) {
                return Base_Helpers.error("Need to override restoreNavigation")
                };
                Base_Impl.prototype.doChartUpdateNotify = function(origin) {
                return this.dispatchEventParams("chartUpdate", this.extendEventParams({origin: origin}), null)
                };
                Base_Impl.prototype.dispatchEventParams = function(name, params, defaultFunc) {
                var event, key, value;
                        if (!(defaultFunc || ((this.eventListeners[name] != null) && this.eventListeners[name].length > 0))) {
                return{}
                }
                event = Base_Helpers.createEvent(name);
                        for (key in params) {
                if (!__hasProp.call(params, key)) {
                continue
                }
                value = params[key];
                        if (event[key] === void 0) {
                event[key] = value
                }
                }
                return this.dispatchEvent(name, event, defaultFunc)
                };
                Base_Impl.prototype.dispatchEvent = function(name, event, defaultFunc) {
                var l, _i, _len, _ref;
                        if (!(defaultFunc || ((this.eventListeners[name] != null) && this.eventListeners[name].length > 0))) {
                return event
                }
                event.chart = this.api;
                        if (this.eventListeners[name] != null) {
                _ref = this.eventListeners[name];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                l = _ref[_i];
                        this.log("Call user event handler, " + name, event);
                        l.call(this.api, event)
                }
                }
                if (!event.defaultPrevented && (defaultFunc != null)) {
                this.log("Call default event handler, " + name);
                        defaultFunc.call(this.api, event)
                }
                return event
                };
                Base_Impl.prototype.error = function(msg, arg) {
                return this.dispatchEventParams("error", {message: msg, arg: arg}, this.defaultError)
                };
                Base_Impl.prototype.log = function(msg, arg) {
                if (this.settings.advanced.logging) {
                return Base_Helpers.log(msg, arg)
                }
                };
                Base_Impl.prototype.defaultError = function(event) {
                if (this.settings.events.onError) {
                this.settings.events.onError(event)
                }
                return Base_Helpers.error(event.message, event.arg ? event.arg : null)
                };
                Base_Impl.prototype.loadAssets = function() {
                var asset, assetToLoad, loaded, _i, _len, _ref;
                        assetToLoad = null;
                        _ref = this.settings.advanced.assets;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                asset = _ref[_i];
                        if (!this.loadedAssets.hasOwnProperty(asset)) {
                assetToLoad = asset;
                        break
                }
                }
                if (assetToLoad) {
                if (this.assetsLoaded) {
                this.log("Loading assets")
                }
                this.assetsLoaded = false;
                        loaded = (function(_this) {
                        return function(asset) {
                        if (_this.removed) {
                        return
                        }
                        _this.loadedAssets[asset] = true;
                                return _this.loadAssets()
                        }
                        })(this);
                        return this.loadAsset(assetToLoad, loaded)
                } else {
                if (!this.assetsLoaded) {
                this.log("Chart assets loaded");
                        this.onAssetsLoaded()
                }
                return this.assetsLoaded = true
                }
                };
                Base_Impl.prototype.loadAsset = function(asset, callback) {
                var elem, ext, url;
                        url = asset.src;
                        url = this.settings.getAssetUrl(asset);
                        ext = Base_Helpers.getExtension(asset);
                        if (ext === "css") {
                elem = document.createElement("link");
                        elem.setAttribute("rel", "stylesheet");
                        elem.setAttribute("href", url);
                        elem.setAttribute("type", "text/css");
                        elem.addEventListener("load", function() {
                        return callback(asset)
                        });
                        elem.addEventListener("error", (function(_this) {
                        return function() {
                        _this.error("Assets: Failed to load asset", asset);
                                return callback(asset)
                        }
                        })(this));
                        document.getElementsByTagName("head")[0].appendChild(elem);
                        return setTimeout((function(_this) {
                        return function() {
                        var img;
                                if (!_this.loadedAssets.hasOwnProperty(asset) && !_this.imgAssets.hasOwnProperty(asset)) {
                        _this.imgAssets[asset] = true;
                                img = document.createElement("img");
                                img.onerror = function() {
                                return callback(asset)
                                };
                                return img.src = url
                        }
                        }
                        })(this), 200)
                } else {
                if (ext === "js") {
                elem = document.createElement("script");
                        elem.setAttribute("src", url);
                        elem.setAttribute("type", "text/javascript");
                        elem.addEventListener("load", function() {
                        return callback(asset)
                        });
                        elem.addEventListener("error", (function(_this) {
                        return function() {
                        _this.error("Assets: Failed to load asset", asset);
                                return callback(asset)
                        }
                        })(this));
                        return document.getElementsByTagName("head")[0].appendChild(elem)
                } else {
                this.error("Assets: Do not know how to load", asset);
                        return callback(asset)
                }
                }
                };
                return Base_Impl
        })();
        var Linearchart_Impl, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        }, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Linearchart_Impl = (function(_super) {
        __extends(Linearchart_Impl, _super);
                Linearchart_Impl.prototype.scrolling = null;
                Linearchart_Impl.prototype.renderer = null;
                Linearchart_Impl.prototype.toolbar = null;
                Linearchart_Impl.prototype.bottomAxisSettings = null;
                function Linearchart_Impl(settings) {
                this.onSizeChanged = __bind(this.onSizeChanged, this);
                        Linearchart_Impl.__super__.constructor.call(this, this.settings)
                }
        Linearchart_Impl.prototype.onAssetsLoaded = function() {
        this.updateSize(true);
                if (this.toolbar) {
        return this.toolbar.render()
        }
        };
                Linearchart_Impl.prototype.onSizeChanged = function(clientWidth, clientHeight) {
                var bottomMargin, ch, context, cw, height, leftMargin, leftPadding, rightMargin, rightPadding, th, toolbarHeight, toolbarOutside, topMargin, tw, width, _ref, _ref1, _ref2, _ref3;
                        context = this.layers.canvas.getContext("2d");
                        _ref = Linearchart_ValueAxis.computeMargins(context, this.settings.computedValueAxisList), leftMargin = _ref[0], leftPadding = _ref[1], rightPadding = _ref[2], rightMargin = _ref[3];
                        bottomMargin = 0;
                        topMargin = 0;
                        if (this.toolbar) {
                _ref1 = this.toolbar.getLocationPreference(), toolbarHeight = _ref1[0], toolbarOutside = _ref1[1];
                        if (toolbarOutside) {
                this.toolbar.setPosition(leftMargin, 0, clientWidth - leftMargin - rightMargin);
                        topMargin += toolbarHeight
                } else {
                this.toolbar.setPosition(leftMargin + leftPadding + 1, 0, clientWidth - leftMargin - leftPadding - rightMargin - rightPadding)
                }
                }
                if (this.bottomAxisSettings.enabled) {
                this.scene.bottomAxisSize = this.bottomAxisSettings.size;
                        bottomMargin += this.scene.bottomAxisSize
                } else {
                this.scene.bottomAxisSize = 0
                }
                _ref2 = this.title.computeSize(context), tw = _ref2[0], th = _ref2[1];
                        topMargin += th;
                        _ref3 = this.credits.computeSize(context), cw = _ref3[0], ch = _ref3[1];
                        bottomMargin += ch;
                        height = Math.max(clientHeight, topMargin + bottomMargin + 1);
                        width = Math.max(clientWidth, leftMargin + rightMargin + 1);
                        this.scene.x0 = leftMargin;
                        this.scene.y0 = topMargin;
                        this.scene.width = width - leftMargin - rightMargin;
                        this.scene.height = height - topMargin - bottomMargin;
                        this.scene.leftMargin = leftMargin;
                        this.scene.rightMargin = rightMargin;
                        this.scene.topMargin = topMargin;
                        this.scene.bottomMargin = bottomMargin;
                        this.layers.updateSize();
                        if (this.events != null) {
                return this.events.notifySceneChanges({bounds: true})
                }
                };
                Linearchart_Impl.prototype.replaceSeries = function(newSeries) {
                this.settings.series = [];
                        return this.updateSettings({series: newSeries})
                };
                Linearchart_Impl.prototype.setLogScale = function(enabled, origin) {
                var id, va, vaChanges, _ref;
                        vaChanges = {};
                        _ref = this.settings.valueAxis;
                        for (id in _ref) {
                va = _ref[id];
                        vaChanges[id] = {logScale: enabled}
                }
                return this.updateSettings({valueAxis: vaChanges}, origin)
                };
                return Linearchart_Impl
        })(Base_Impl);
        var Facetchart_Toolbar, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Facetchart_Toolbar = (function(_super) {
        __extends(Facetchart_Toolbar, _super);
                Facetchart_Toolbar.prototype.panScene = false;
                Facetchart_Toolbar.prototype.relativeClass = "infobar";
                function Facetchart_Toolbar(container, chart) {
                var s;
                        this.chart = chart;
                        Facetchart_Toolbar.__super__.constructor.call(this, {container: container}, this.chart);
                        s = this.addItem(new Base_Bar_ButtonSet({buttonMode: "none"}), {spot: "left"});
                        if (this.chart.scene.settings.toolbars.backButton) {
                s.addItem(new Linearchart_Bar_BackButton({label: null}))
                }
                if (this.chart.scene.settings.toolbars.zoomOutButton) {
                s.addItem(new Linearchart_Bar_ZoomOutButton({label: null}))
                }
                if (this.chart.scene.settings.toolbars.logScale) {
                this.addItem(new Linearchart_Bar_LinLogButton({label: null}), {spot: "right"})
                }
                if (this.chart.scene.settings.toolbars["export"]) {
                this.addItem(new Linearchart_Bar_ExportDropdown({showTitle: null}), {spot: "right"})
                }
                }
        Facetchart_Toolbar.prototype.render = function() {
        Facetchart_Toolbar.__super__.render.call(this);
                return this.show()
        };
                return Facetchart_Toolbar
        })(Base_Toolbar);
        var Timechart_Toolbar, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Toolbar = (function(_super) {
        __extends(Timechart_Toolbar, _super);
                Timechart_Toolbar.prototype.displayUnit = null;
                Timechart_Toolbar.prototype.displayUnitValue = null;
                function Timechart_Toolbar(options, chart) {
                var b, s;
                        this.chart = chart;
                        Timechart_Toolbar.__super__.constructor.call(this, options, this.chart);
                        s = this.addItem(new Base_Bar_ButtonSet({buttonMode: "none"}), {spot: "left"});
                        if (this.chart.scene.settings.toolbars.backButton) {
                s.addItem(new Linearchart_Bar_BackButton())
                }
                if (this.chart.scene.settings.toolbars.zoomOutButton) {
                s.addItem(new Linearchart_Bar_ZoomOutButton())
                }
                if (this.chart.scene.settings.toolbars.logScale) {
                s = this.addItem(new Base_Bar_ButtonSet(), {spot: "right"});
                        b = s.addItem(new Linearchart_Bar_LinButton());
                        b = s.addItem(new Linearchart_Bar_LogButton())
                }
                if (this.chart.scene.settings.toolbars.periodSelection) {
                s = this.addItem(new Base_Bar_ButtonSet({buttonMode: "one"}), {spot: "right"});
                        s.addItem(new Timechart_Bar_PeriodDayButton());
                        s.addItem(new Timechart_Bar_PeriodWeekButton());
                        s.addItem(new Timechart_Bar_PeriodMonthButton());
                        s.addItem(new Timechart_Bar_PeriodDropdown())
                }
                if (this.chart.scene.settings.toolbars.displayUnit) {
                this.addItem(new Timechart_Bar_DisplayUnitDropdown(), {spot: "right"})
                }
                }
        return Timechart_Toolbar
        })(Base_Toolbar);
        var Timechart_ToolbarAdv, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_ToolbarAdv = (function(_super) {
        __extends(Timechart_ToolbarAdv, _super);
                Timechart_ToolbarAdv.prototype.displayUnit = null;
                Timechart_ToolbarAdv.prototype.displayUnitValue = null;
                Timechart_ToolbarAdv.prototype.panScene = false;
                Timechart_ToolbarAdv.prototype.relativeClass = "infobar";
                function Timechart_ToolbarAdv(options, chart) {
                var b, s;
                        this.chart = chart;
                        Timechart_ToolbarAdv.__super__.constructor.call(this, options, this.chart);
                        s = this.addItem(new Base_Bar_ButtonSet({buttonMode: "none"}), {spot: "left"});
                        if (this.chart.scene.settings.toolbars.backButton) {
                s.addItem(new Linearchart_Bar_BackButton())
                }
                if (this.chart.scene.settings.toolbars.zoomOutButton) {
                s.addItem(new Linearchart_Bar_ZoomOutButton())
                }
                if (this.chart.scene.settings.toolbars.logScale) {
                s = this.addItem(new Base_Bar_ButtonSet(), {spot: "right"});
                        b = s.addItem(new Linearchart_Bar_LinButton());
                        b = s.addItem(new Linearchart_Bar_LogButton())
                }
                if (this.chart.scene.settings.toolbars.periodSelection) {
                s = this.addItem(new Base_Bar_ButtonSet({buttonMode: "one"}), {spot: "right"});
                        s.addItem(new Timechart_Bar_PeriodDayButton());
                        s.addItem(new Timechart_Bar_PeriodWeekButton());
                        s.addItem(new Timechart_Bar_PeriodMonthButton());
                        s.addItem(new Timechart_Bar_PeriodDropdown())
                }
                if (this.chart.scene.settings.toolbars.displayUnit) {
                this.addItem(new Timechart_Bar_DisplayUnitDropdown(), {spot: "right"})
                }
                }
        return Timechart_ToolbarAdv
        })(Base_Toolbar);
        var Timechart_ToolbarBare, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_ToolbarBare = (function(_super) {
        __extends(Timechart_ToolbarBare, _super);
                Timechart_ToolbarBare.prototype.displayUnit = null;
                Timechart_ToolbarBare.prototype.displayUnitValue = null;
                Timechart_ToolbarBare.prototype.panScene = false;
                Timechart_ToolbarBare.prototype.relativeClass = "infobar";
                function Timechart_ToolbarBare(options, chart) {
                var s;
                        this.chart = chart;
                        Timechart_ToolbarBare.__super__.constructor.call(this, options, this.chart);
                        s = this.addItem(new Base_Bar_ButtonSet({buttonMode: "none"}), {spot: "left"});
                        if (this.chart.scene.settings.toolbars.backButton) {
                s.addItem(new Linearchart_Bar_BackButton({label: null}))
                }
                if (this.chart.scene.settings.toolbars.zoomOutButton) {
                s.addItem(new Linearchart_Bar_ZoomOutButton({label: null}))
                }
                if (this.chart.scene.settings.toolbars.logScale) {
                this.addItem(new Linearchart_Bar_LinLogButton({label: null}), {spot: "right"})
                }
                if (this.chart.scene.settings.toolbars.periodSelection) {
                s = this.addItem(new Base_Bar_ButtonSet({buttonMode: "one"}), {spot: "right"});
                        s.addItem(new Timechart_Bar_PeriodDayButton());
                        s.addItem(new Timechart_Bar_PeriodWeekButton());
                        s.addItem(new Timechart_Bar_PeriodMonthButton());
                        s.addItem(new Timechart_Bar_PeriodDropdown({showTitle: null, label: null, hasIcon: null}))
                }
                if (this.chart.scene.settings.toolbars.displayUnit) {
                this.addItem(new Timechart_Bar_DisplayUnitDropdown({showTitle: null}), {spot: "right"})
                }
                if (this.chart.scene.settings.toolbars["export"]) {
                this.addItem(new Linearchart_Bar_ExportDropdown({showTitle: null}), {spot: "right"})
                }
                }
        return Timechart_ToolbarBare
        })(Base_Toolbar);
        var Netchart_Impl, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        }, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Netchart_Impl = (function(_super) {
        __extends(Netchart_Impl, _super);
                Netchart_Impl.prototype.api = null;
                Netchart_Impl.prototype.renderer = null;
                Netchart_Impl.prototype.scrolling = null;
                Netchart_Impl.prototype.selection = null;
                function Netchart_Impl(settings, api) {
                this.defaultDoubleClick = __bind(this.defaultDoubleClick, this);
                        this.defaultRightClick = __bind(this.defaultRightClick, this);
                        this.defaultClick = __bind(this.defaultClick, this);
                        this.onSizeChanged = __bind(this.onSizeChanged, this);
                        this.settings = new Netchart_Settings(settings);
                        Netchart_Impl.__super__.constructor.call(this, this.settings);
                        this.scene = new Netchart_Scene();
                        this.scene.settings = this.settings;
                        this.graph = new Netchart_Graph(this);
                        this.navigator = new Netchart_Navigator(this);
                        this.scrolling = new Netchart_Scrolling(this);
                        this.layout = new Netchart_Layout(this);
                        this.layers = new Netchart_Layers(this, this.scene);
                        this.initialize(api);
                        this.renderer = new Netchart_Renderer(this);
                        this.info = new Netchart_InfoPopup(this);
                        this.menu = new Netchart_Menu(this);
                        this.events.addElement(this.graph);
                        this.events.addElement(this.navigator);
                        this.events.addElement(this.layout);
                        this.events.addElement(this.scrolling);
                        this.autoZoom = this.events.addElement(new Netchart_AutoZoom(this));
                        this.events.addElement(new Netchart_Selection(this));
                        this.events.addElement(new Netchart_Styles(this));
                        this.events.addElement(this.renderer);
                        this.zoomControl = this.events.addElement(new Netchart_ZoomControl(this));
                        this.events.addElement(this.menu);
                        this.events.addElement(this.info);
                        this.autoZoom.resetZoom = true;
                        this.scene.data = new Netchart_Data(this);
                        this.scene.data.applyPreloadedData();
                        this.scene.loading = false;
                        this.navigator.onNewDataObject();
                        this.navigator.showInitialNodes();
                        this.finalInitialize()
                }
        Netchart_Impl.prototype.onAssetsLoaded = function() {
        this.updateSize();
                return this.zoomControl.showDom()
        };
                Netchart_Impl.prototype.onRemove = function() {
                this.layers = null;
                        this.renderer = null;
                        this.scene.data.remove();
                        this.scene.data = null;
                        return this.scene = null
                };
                Netchart_Impl.prototype.onSettingsChanged = function(changes) {
                var ch, reinitChart;
                        this.layers.updateSettings(changes);
                        ch = {};
                        reinitChart = changes.navigation && (changes.navigation.mode || changes.navigation.initialNodes);
                        if ((changes.data != null) && (changes.data.dataFunction || changes.data.format || (changes.data.units != null) || changes.data.preloaded || changes.data.url)) {
                this.buildNewDataObj();
                        this.navigator.onNewDataObject();
                        reinitChart = true
                }
                if (reinitChart) {
                this.navigator.showInitialNodes();
                        this.autoZoom.resetZoom = true
                }
                if (changes.filterss) {
                ch.filters = true
                }
                return this.events.notifySceneChanges(ch)
                };
                Netchart_Impl.prototype.save = function() {
                var nav, xy;
                        xy = this.graph.save();
                        nav = this.navigator.save();
                        return JSON.stringify({xy: xy, nav: nav})
                };
                Netchart_Impl.prototype.restore = function(stateStr, animate) {
                var nav, state, xy;
                        if (!stateStr) {
                return
                }
                state = JSON.parse(stateStr);
                        xy = state.xy;
                        nav = state.nav;
                        if (nav) {
                this.navigator.restore(nav)
                }
                if (xy) {
                this.graph.restore(xy)
                }
                return this.autoZoom.resetZoom = true
                };
                Netchart_Impl.prototype.onSizeChanged = function(clientWidth, clientHeight) {
                this.scene.y0 = 0;
                        this.scene.x0 = 0;
                        this.scene.height = clientHeight;
                        this.scene.width = clientWidth;
                        this.layers.updateSize();
                        if (this.events != null) {
                return this.events.notifySceneChanges({bounds: true})
                }
                };
                Netchart_Impl.prototype.lockNode = function(id, x, y) {
                if (Base_Helpers.isObject(id)) {
                id = id.id
                }
                return this.graph.lockNode(id, x, y)
                };
                Netchart_Impl.prototype.unlockNode = function(id) {
                if (Base_Helpers.isObject(id)) {
                id = id.id
                }
                return this.graph.unlockNode(id)
                };
                Netchart_Impl.prototype.addFocusNode = function(id, levels) {
                if (Base_Helpers.isObject(id)) {
                id = id.id
                }
                if (this.settings.navigation.autoZoomOnFocus) {
                this.scene.autoZoomActive = true
                }
                return this.navigator.addFocusNode(id, levels)
                };
                Netchart_Impl.prototype.clearFocus = function() {
                return this.navigator.clear()
                };
                Netchart_Impl.prototype.getCurrentNodes = function() {
                var n, nodes, _i, _len, _ref;
                        nodes = [];
                        _ref = this.scene.nodes();
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                n = _ref[_i];
                        if (!n.removed) {
                nodes.push(n)
                }
                }
                return nodes
                };
                Netchart_Impl.prototype.getCurrentLinks = function() {
                var links, n, _i, _len, _ref;
                        links = [];
                        _ref = this.scene.links();
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                n = _ref[_i];
                        if (!n.removed) {
                links.push(n)
                }
                }
                return links
                };
                Netchart_Impl.prototype.getNodeDimensions = function(node) {
                var r, w, x, y, _ref;
                        if (!Base_Helpers.isObject(node)) {
                node = this.getNode(node)
                }
                if (!node) {
                return null
                }
                _ref = this.scene.toDisplay(node.x, node.y), x = _ref[0], y = _ref[1];
                        r = node.currentRadius * this.scene.zoom;
                        w = node.currentHwidth * this.scene.zoom;
                        return{x: x, y: y, radius: r, hwidth: w}
                };
                Netchart_Impl.prototype.removeFocusNode = function(id) {
                if (Base_Helpers.isObject(id)) {
                id = id.id
                }
                return this.navigator.unexpandNode(id)
                };
                Netchart_Impl.prototype.runMovingMessage = function(id1, id2, messageType, tick) {
                if (Base_Helpers.isObject(id1)) {
                id1 = id1.id
                }
                if (Base_Helpers.isObject(id2)) {
                id2 = id2.id
                }
                return this.navigator.runMovingMessage(id1, id2, messageType, tick)
                };
                Netchart_Impl.prototype.expandNode = function(id, levels) {
                if (levels == null) {
                levels = 1
                }
                if (Base_Helpers.isObject(id)) {
                id = id.id
                }
                return this.navigator.expandNode(id, levels + 1)
                };
                Netchart_Impl.prototype.collapseNode = function(id) {
                if (Base_Helpers.isObject(id)) {
                id = id.id
                }
                return this.navigator.collapseNode(id)
                };
                Netchart_Impl.prototype.uncollapseNode = function(id) {
                if (Base_Helpers.isObject(id)) {
                id = id.id
                }
                return this.navigator.uncollapseNode(id)
                };
                Netchart_Impl.prototype.hideNode = function(id) {
                if (Base_Helpers.isObject(id)) {
                id = id.id
                }
                return this.navigator.hideNode(id)
                };
                Netchart_Impl.prototype.getNode = function(id) {
                return this.scene.idToNode[id]
                };
                Netchart_Impl.prototype.setSelection = function(selection, alreadyChanged) {
                var hasChanges, n, realSelection, _i, _len;
                        realSelection = [];
                        for (_i = 0, _len = selection.length; _i < _len; _i++) {
                n = selection[_i];
                        if (n instanceof Netchart_Node || n instanceof Netchart_Link) {
                realSelection.push(n)
                } else {
                this.error("SetSelection: Non chart object in selection: " + n)
                }
                }
                hasChanges = alreadyChanged | this.scene.selection.length !== realSelection.length;
                        if (realSelection.length === 1 && !hasChanges) {
                hasChanges = this.scene.selection[0] !== realSelection[0]
                }
                if (hasChanges) {
                this.scene.selection = realSelection;
                        this.events.notifySceneChanges({selection: true});
                        return this.notifySelectionChanged("api")
                }
                };
                Netchart_Impl.prototype.zoomIn = function(nodes, animate) {
                return this.error("ZoomIn: not implmeneted")
                };
                Netchart_Impl.prototype.reloadData = function() {
                this.buildNewDataObj();
                        return this.navigator.onNewDataObject()
                };
                Netchart_Impl.prototype.replaceData = function(data) {
                this.buildNewDataObj();
                        return this.scene.data.dataArrived(null, data)
                };
                Netchart_Impl.prototype.addData = function(data, sourceId) {
                return this.scene.data.dataArrived(null, data)
                };
                Netchart_Impl.prototype.removeData = function(data, sourceId) {
                this.scene.data.removeData(data);
                        return this.events.notifySceneChanges({data: true})
                };
                Netchart_Impl.prototype.exportData = function(visibleOnly, exportCoords) {
                var r;
                        if (visibleOnly) {
                r = this.graph.exportData()
                } else {
                r = this.scene.data.exportData()
                }
                if (exportCoords) {
                this.graph.exportCoordinates(r.nodes)
                }
                return r
                };
                Netchart_Impl.prototype.buildNewDataObj = function() {
                this.scene.data.remove();
                        this.events.clearSceneChanges({dataArrived: true});
                        this.scene.data = new Netchart_Data(this);
                        return this.events.notifySceneChanges({data: true})
                };
                Netchart_Impl.prototype.closePopup = function() {
                return this.menu.hideMenu()
                };
                Netchart_Impl.prototype.extendEventParams = function(p) {
                var _ref;
                        if (p.x || p.y) {
                _ref = this.scene.fromDisplay(p.x, p.y), p.chartX = _ref[0], p.chartY = _ref[1]
                }
                p.nodes = this.scene.nodes();
                        p.links = this.scene.links();
                        p.hoverLink = this.scene.hoverLink;
                        p.hoverNode = this.scene.hoverNode;
                        p.hoverItem = this.scene.hoverItem;
                        p.selection = this.scene.selection;
                        return p
                };
                Netchart_Impl.prototype.defaultClick = function(event) {
                var node;
                        if (event.clickNode != null) {
                node = event.clickNode;
                        if (this.scene.settings.navigation.expandOnClick) {
                if (!node.expanded) {
                this.expandNode(node.id);
                        return event.preventDefault()
                } else {
                if (node.expanded && this.scene.settings.navigation.mode === "manual") {
                this.collapseNode(node.id);
                        return event.preventDefault()
                }
                }
                }
                }
                };
                Netchart_Impl.prototype.defaultRightClick = function(event) {
                if (event.clickNode != null) {
                this.scene.data.getNodeLinks(event.clickNode.id);
                        this.menu.toggleNodeMenu(event.clickNode);
                        event.preventDefault()
                }
                if (event.clickLink != null) {
                this.menu.toggleLinkMenu(event.x, event.y, event.clickLink);
                        return event.preventDefault()
                }
                };
                Netchart_Impl.prototype.defaultDoubleClick = function(event) {
                var node;
                        node = event.clickNode;
                        if (node) {
                this.addFocusNode(node.id);
                        return event.preventDefault()
                }
                };
                return Netchart_Impl
        })(Base_Impl);
        var Piechart_Impl, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        }, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Piechart_Impl = (function(_super) {
        __extends(Piechart_Impl, _super);
                Piechart_Impl.prototype.api = null;
                function Piechart_Impl(settings, api) {
                this.defaultDoubleClick = __bind(this.defaultDoubleClick, this);
                        this.defaultClick = __bind(this.defaultClick, this);
                        this.onSizeChanged = __bind(this.onSizeChanged, this);
                        this.settings = new Piechart_Settings(settings);
                        Piechart_Impl.__super__.constructor.call(this, this.settings);
                        this.scene = new Piechart_Scene();
                        this.scene.settings = this.settings;
                        this.scene.selectionIds = this.settings.area.initialSelectionIds;
                        this.scene.loading = false;
                        this.layers = new Piechart_Layers(this, this.scene);
                        this.initialize(api);
                        this.scene.view = new Piechart_PieView(this);
                        this.events.addElement(new Piechart_InfoPopup(this));
                        this.selection = this.events.addElement(new Piechart_Selection(this));
                        this.navigator = this.events.addElement(new Piechart_Scrolling(this));
                        this.navigator = this.events.addElement(new Piechart_Navigator(this));
                        this.events.addElement(new Piechart_Styles(this));
                        this.events.addElement(this.scene.view);
                        this.scene.data = new Piechart_Data(this);
                        this.finalInitialize();
                        this.navigator.setPie(this.settings.area.initialPieId, this.settings.area.initialPieOffset, "init")
                }
        Piechart_Impl.prototype.onAssetsLoaded = function() {
        return this.updateSize(true)
        };
                Piechart_Impl.prototype.onRemove = function() {
                this.layers = null;
                        this.renderer = null;
                        this.scene.data.remove();
                        this.scene.data = null;
                        return this.scene = null
                };
                Piechart_Impl.prototype.onSettingsChanged = function(changes) {
                var ch;
                        this.layers.updateSettings(changes);
                        ch = {};
                        if (changes.data) {
                this.scene.data.remove();
                        this.scene.data = new Piechart_Data(this);
                        ch.data = true
                }
                if (changes.area) {
                if (changes.area.type) {
                this.log("Switching type to " + this.settings.area.type);
                        this.events.removeElement(this.scene.view);
                        this.scene.view = new Piechart_PieView(this);
                        this.events.addElement(this.scene.view);
                        ch.data = true;
                        ch.dataDeep = true
                }
                if (changes.area.initialPieId || changes.area.initialPieOffset) {
                this.navigator.setPie(this.settings.area.initialPieId, this.settings.area.initialPieOffset)
                }
                if (changes.area.initialSelectionIds) {
                this.setSelection(changes.area.initialSelectionIds)
                }
                }
                if (changes.labels || changes.pie || changes.slice || changes.interaction) {
                ch.pie = true
                }
                if (changes.title || changes.area) {
                this.onSizeChanged(this.scene.chartWidth, this.scene.chartHeight)
                }
                return this.events.notifySceneChanges(ch)
                };
                Piechart_Impl.prototype.onSizeChanged = function(clientWidth, clientHeight) {
                var ch, cw, height, th, tw, width, _ref, _ref1;
                        this.scene.leftMargin = 0;
                        this.scene.rightMargin = 0;
                        this.scene.bottomMargin = 0;
                        this.scene.topMargin = 0;
                        _ref = this.title.computeSize(this.layers.canvas.getContext("2d")), tw = _ref[0], th = _ref[1];
                        this.scene.topMargin = th;
                        _ref1 = this.credits.computeSize(this.layers.canvas.getContext("2d")), cw = _ref1[0], ch = _ref1[1];
                        this.scene.bottomMargin = ch;
                        height = clientHeight;
                        width = clientWidth;
                        this.scene.x0 = this.scene.leftMargin;
                        this.scene.y0 = this.scene.topMargin;
                        this.scene.width = width - this.scene.leftMargin - this.scene.rightMargin;
                        this.scene.height = height - this.scene.topMargin - this.scene.bottomMargin;
                        this.layers.updateSize();
                        if (this.events != null) {
                return this.events.notifySceneChanges({bounds: true})
                }
                };
                Piechart_Impl.prototype.save = function() {
                var selectionIds;
                        selectionIds = this.saveSelection();
                        return JSON.stringify({pie: this.navigator.getPie(), offset: this.navigator.getPieOffset(), selection: selectionIds})
                };
                Piechart_Impl.prototype.restore = function(stateStr, animate) {
                var pie;
                        if (!stateStr) {
                return
                }
                pie = JSON.parse(stateStr);
                        this.setPie(pie.pie, pie.offset, animate);
                        return this.setSelection(pie.selection)
                };
                Piechart_Impl.prototype.reloadData = function(deep) {
                this.log("Reload data");
                        this.scene.data.remove();
                        this.scene.data = new Piechart_Data(this);
                        return this.events.notifySceneChanges({data: true, dataDeep: deep})
                };
                Piechart_Impl.prototype.updateFilter = function(deep) {
                this.log("Update filter");
                        return this.events.notifySceneChanges({data: true, dataDeep: deep})
                };
                Piechart_Impl.prototype.setSelection = function(selection) {
                var n, realSelection, selectionIds, _i, _len;
                        this.log("Set selection");
                        realSelection = [];
                        selectionIds = [];
                        for (_i = 0, _len = selection.length; _i < _len; _i++) {
                n = selection[_i];
                        if (n instanceof Piechart_Slice) {
                realSelection.push(n)
                } else {
                if (Base_Helpers.isString(n)) {
                selectionIds.push(n)
                } else {
                this.error("SetSelection: Selection contents must be Piechart_Slice object or string, got " + n)
                }
                }
                }
                return this.selection.setSelection(realSelection, selectionIds, false, "api")
                };
                Piechart_Impl.prototype.saveSelection = function() {
                var s, selectionIds, _i, _len, _ref;
                        selectionIds = this.scene.selectionIds.splice(0);
                        _ref = this.scene.selection;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                        selectionIds.push(s.id)
                }
                return selectionIds
                };
                Piechart_Impl.prototype.setPie = function(root, offset, animate, origin) {
                if (animate == null) {
                animate = true
                }
                if (origin == null) {
                origin = "api"
                }
                this.log("Set pie");
                        return this.navigator.setPie(root, offset, origin)
                };
                Piechart_Impl.prototype.getPie = function() {
                return this.navigator.getPie()
                };
                Piechart_Impl.prototype.getActiveSlices = function() {
                var pie, r, _i, _len, _ref;
                        r = [];
                        _ref = this.scene.stack;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                pie = _ref[_i];
                        if (pie.parentSlice) {
                r.push(pie.parentSlice)
                }
                }
                return r
                };
                Piechart_Impl.prototype.getActivePies = function() {
                return this.scene.stack
                };
                Piechart_Impl.prototype.expandSlice = function(slice, origin) {
                return this.navigator.expandSlice(slice, origin)
                };
                Piechart_Impl.prototype.getSliceDimensions = function(sliceId, showPartial) {
                var pie, pos, rp, sid, slice, _i, _j, _len, _len1, _ref, _ref1;
                        if (!Base_Helpers.isArray(sliceId)) {
                this.error("getSliceDimensions: slice Id must be an array");
                        return null
                }
                if (sliceId.length < 2) {
                return null
                }
                if (!showPartial && this.scene.stack.length + 1 < sliceId.length) {
                return null
                }
                pos = 0;
                        _ref = this.scene.stack;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                pie = _ref[_i];
                        if (pie.id !== sliceId[pos]) {
                return null
                }
                pos += 1;
                        if (pos === sliceId.length - 1) {
                break
                }
                }
                sid = sliceId[pos];
                        _ref1 = pie.slices;
                        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                slice = _ref1[_j];
                        if (slice.id === sid) {
                rp = slice.renderParams;
                        if (!rp) {
                return null
                }
                return[pie.x, pie.y, rp[0], rp[1], rp[2], rp[3]]
                }
                }
                return null
                };
                Piechart_Impl.prototype.saveNavigation = function() {
                var pie;
                        pie = this.scene.peek();
                        if (!(pie && !pie.loading)) {
                return null
                }
                return[{pie: this.navigator.getPie(), offset: this.navigator.getPieOffset()}]
                };
                Piechart_Impl.prototype.restoreNavigation = function(state, animate, origin) {
                return this.navigator.setPie(state.pie, state.offset, origin)
                };
                Piechart_Impl.prototype.doChartUpdateNotify = function(origin) {
                Piechart_Impl.__super__.doChartUpdateNotify.call(this);
                        this.dispatchEventParams("pieChange", this.extendEventParams({origin: origin}), null);
                        return this.dispatchEventParams("pieReadyStateChanged", this.extendEventParams({origin: origin}), null)
                };
                Piechart_Impl.prototype.extendEventParams = function(p) {
                var pie;
                        pie = this.scene.peek();
                        p.pie = pie;
                        p.offset = pie.offset;
                        p.count = pie.count;
                        p.hoverSlice = this.scene.hoverSlice;
                        p.selection = this.scene.selection;
                        return p
                };
                Piechart_Impl.prototype.defaultClick = function(event) {
                var p, s;
                        s = event.clickSlice;
                        p = event.clickPie;
                        if (s) {
                if (s.url) {
                Base_Helpers.openUrl(s.url);
                        return event.preventDefault()
                } else {
                if (this.navigator.expandSlice(s, "user")) {
                return event.preventDefault()
                }
                }
                } else {
                if (p) {
                this.setSelection([], "user");
                        this.navigator.goCenter("user");
                        return event.preventDefault()
                }
                }
                };
                Piechart_Impl.prototype.defaultDoubleClick = function(event) {
                };
                return Piechart_Impl
        })(Base_Impl);
        var Facetchart_Impl, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        }, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Facetchart_Impl = (function(_super) {
        __extends(Facetchart_Impl, _super);
                Facetchart_Impl.prototype.api = null;
                function Facetchart_Impl(settings, api) {
                this.defaultDoubleClick = __bind(this.defaultDoubleClick, this);
                        this.defaultClick = __bind(this.defaultClick, this);
                        this.settings = new Facetchart_Settings(settings);
                        Facetchart_Impl.__super__.constructor.call(this, this.settings);
                        this.curState = null;
                        this.scene = new Facetchart_Scene(this.settings);
                        this.layers = new Linearchart_Layers(this);
                        this.initialize(api);
                        this.builder = new Facetchart_Builder(this);
                        this.renderer = new Facetchart_Renderer(this);
                        this.scrolling = new Facetchart_Scrolling(this);
                        this.selection = new Facetchart_Selection(this);
                        this.events.addElement(new Linearchart_Highlight(this));
                        this.events.addElement(new Facetchart_InfoPopup(this));
                        this.events.addElement(this.renderer);
                        this.events.addElement(this.selection);
                        this.events.addElement(this.scrolling);
                        this.events.addElement(new Facetchart_Styles(this));
                        this.events.addElement(new Linearchart_Highlights(this));
                        this.events.addElement(new Facetchart_Selection(this));
                        this.scene.data = new Piechart_Data(this, this.settings.data);
                        this.toolbar = new Facetchart_Toolbar(this.layers.container, this);
                        this.bottomAxisSettings = this.settings.facetAxis;
                        this.finalInitialize();
                        this.scrolling.setState(this.settings.area.initialPieId, this.settings.area.initialPieOffset, 0, "init")
                }
        Facetchart_Impl.prototype.onRemove = function() {
        this.layers = null;
                this.renderer = null;
                this.scene.data.remove();
                this.scene.data = null;
                return this.scene = null
        };
                Facetchart_Impl.prototype.onSettingsChanged = function(changes) {
                var ch;
                        this.layers.updateSettings(changes);
                        ch = {settings: true, settingsChanges: changes};
                        if (changes.data) {
                this.scene.data.remove();
                        this.scene.data = new Piechart_Data(this);
                        ch.data = true
                }
                if (changes.area) {
                if (changes.area.initialPieId || changes.area.initialPieOffset) {
                this.scrolling.setState(this.settings.area.initialPieId, this.settings.area.initialPieOffset, null, "api")
                }
                if (changes.area.initialSelectionIds) {
                this.setSelection(changes.area.initialSelectionIds)
                }
                }
                if (changes.labels || changes.series || changes.interaction) {
                ch.items = true
                }
                if (changes.toolbars) {
                this.toolbar.remove();
                        this.toolbar = new Facetchart_Toolbar(this.layers.container, this);
                        if (this.assetsLoaded) {
                this.toolbar.render()
                }
                }
                if (changes.title || changes.area || changes.toolbars || changes.valueAxis) {
                this.updateSize(true)
                }
                return this.events.notifySceneChanges(ch)
                };
                Facetchart_Impl.prototype.reloadData = function(deep) {
                this.log("Reload data");
                        this.scene.data.remove();
                        this.scene.data = new Piechart_Data(this);
                        return this.events.notifySceneChanges({data: true, dataDeep: deep})
                };
                Facetchart_Impl.prototype.updateFilter = function(deep) {
                this.log("Update filter");
                        return this.events.notifySceneChanges({data: true, dataDeep: deep})
                };
                Facetchart_Impl.prototype.setSelection = function(selection, origin) {
                var n, realSelection, selectionIds, _i, _len;
                        if (origin == null) {
                origin = "api"
                }
                this.log("Set selection");
                        realSelection = [];
                        selectionIds = [];
                        for (_i = 0, _len = selection.length; _i < _len; _i++) {
                n = selection[_i];
                        if (n instanceof Facetchart_Item) {
                realSelection.push(n)
                } else {
                if (Base_Helpers.isString(n)) {
                selectionIds.push(n)
                } else {
                this.error("SetSelection: Selection contents must be Facetchart_Item object or string, got " + n)
                }
                }
                }
                return this.selection.setSelection(realSelection, selectionIds, false, origin)
                };
                Facetchart_Impl.prototype.setPie = function(root, offset, count, animate) {
                if (count == null) {
                count = null
                }
                if (animate == null) {
                animate = true
                }
                this.log("Set pie");
                        return this.scrolling.setState(root, offset, count, "api")
                };
                Facetchart_Impl.prototype.getPie = function() {
                return this.scrolling.getState()[0]
                };
                Facetchart_Impl.prototype.getPieOffset = function() {
                return this.scrolling.getState()[1]
                };
                Facetchart_Impl.prototype.getActiveSlices = function() {
                var pie, r, _i, _len, _ref;
                        r = [];
                        _ref = this.scene.stack;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                pie = _ref[_i];
                        if (pie.parentItem) {
                r.push(pie.parentItem)
                }
                }
                return r
                };
                Facetchart_Impl.prototype.zoomOut = function(unused, animate, origin) {
                if (animate == null) {
                animate = true
                }
                if (origin == null) {
                origin = "api"
                }
                return this.scrolling.goUp(origin)
                };
                Facetchart_Impl.prototype.expandItem = function(item, origin) {
                var facet, id;
                        facet = item.facet;
                        if (facet === this.scene.peek()) {
                id = item.id;
                        if (item.expandable && this.scene.data.canExapnd(id)) {
                this.setSelection([]);
                        this.scrolling.drillDown(id, origin);
                        return true
                }
                }
                return false
                };
                Facetchart_Impl.prototype.saveNavigation = function() {
                var pie;
                        pie = this.scene.peek();
                        if (!pie || pie.loading || pie.count === 0 || this.scrolling.isActive()) {
                return null
                }
                return this.scrolling.getState()
                };
                Facetchart_Impl.prototype.restoreNavigation = function(state, animate, origin) {
                return this.scrolling.setState(state[0], state[1], state[2], origin)
                };
                Facetchart_Impl.prototype.save = function() {
                var s, selectionIds, state, _i, _len, _ref;
                        selectionIds = this.scene.selectionIds.splice(0);
                        _ref = this.scene.selection;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                        selectionIds.push(s.id)
                }
                state = this.scrolling.getState();
                        return JSON.stringify({pie: state[0], offset: state[1], count: state[2], selection: selectionIds})
                };
                Facetchart_Impl.prototype.restore = function(stateStr, animate) {
                var pie;
                        if (!stateStr) {
                return
                }
                pie = JSON.parse(stateStr);
                        this.setPie(pie.pie, pie.offset, pie.count, animate);
                        return this.setSelection(pie.selection)
                };
                Facetchart_Impl.prototype.doChartUpdateNotify = function(origin) {
                Facetchart_Impl.__super__.doChartUpdateNotify.call(this, origin);
                        this.dispatchEventParams("pieChange", this.extendEventParams({origin: origin}), null);
                        return this.dispatchEventParams("pieReadyStateChanged", this.extendEventParams({origin: origin}), null)
                };
                Facetchart_Impl.prototype.extendEventParams = function(p) {
                p.facet = this.scene.peek();
                        p.offset = p.facet.offset;
                        p.count = p.facet.count;
                        p.hoverItem = this.scene.hoverItem;
                        p.selection = this.scene.selection;
                        p.pie = p.facet;
                        p.clickSlice = p.clickItem;
                        p.clickPie = p.clickFacet;
                        return p
                };
                Facetchart_Impl.prototype.defaultClick = function(event) {
                var p, s;
                        s = event.clickSlice;
                        p = event.clickPie;
                        if (s) {
                if (s.url) {
                Base_Helpers.openUrl(s.url);
                        return event.preventDefault()
                } else {
                if (this.expandItem(s, "user")) {
                return event.preventDefault()
                }
                }
                }
                };
                Facetchart_Impl.prototype.defaultDoubleClick = function(event) {
                };
                return Facetchart_Impl
        })(Linearchart_Impl);
        var Timechart_MultiBar, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_MultiBar = (function(_super) {
        __extends(Timechart_MultiBar, _super);
                function Timechart_MultiBar(container, chart, settings) {
                Timechart_MultiBar.__super__.constructor.call(this, container, chart, settings)
                }
        Timechart_MultiBar.prototype.buildToolbar = function(name, container) {
        if (name === "infobar") {
        return new Timechart_Infobar({container: container}, this.chart)
        } else {
        if (name === "toolbar") {
        return new Timechart_Toolbar({container: container}, this.chart)
        } else {
        if (name === "toolbarAdv") {
        return new Timechart_ToolbarAdv({container: container, align: "valueAxis"}, this.chart)
        } else {
        if (name === "toolbarBare") {
        return new Timechart_ToolbarBare({container: container, align: "valueAxis"}, this.chart)
        } else {
        this.chart.error("Unrecognized toolbar: " + v);
                return null
        }
        }
        }
        }
        };
                return Timechart_MultiBar
        })(Base_MultiBar);
        var NetChart, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        NetChart = (function(_super) {
        __extends(NetChart, _super);
                NetChart._impl = null;
                NetChart._scene = null;
                NetChart.settings = null;
                function NetChart(settings) {
                this.themes = NetChart.themes;
                        this._impl = new Netchart_Impl(settings, this);
                        this.settings = this._impl.settings;
                        this._scene = this._impl.scene;
                        return this
                }
        NetChart.prototype.updateFilters = function() {
        this._impl.updateSettings({filters: {}}, "api");
                return this
        };
                NetChart.prototype.getNode = function(id) {
                return this._impl.getNode(id)
                };
                NetChart.prototype.showNode = function(id) {
                return this._impl.expandNode(id, 1)
                };
                NetChart.prototype.hideNode = function(id) {
                return this._impl.hideNode(id)
                };
                NetChart.prototype.expandNode = function(id) {
                return this._impl.expandNode(id)
                };
                NetChart.prototype.runMovingMessage = function(id1, id2, messageType, tick) {
                return this._impl.runMovingMessage(id1, id2, messageType, tick)
                };
                NetChart.prototype.addFocusNode = function(id, range) {
                return this._impl.addFocusNode(id, range)
                };
                NetChart.prototype.removeFocusNode = function(id) {
                return this._impl.removeFocusNode(id)
                };
                NetChart.prototype.clearFocus = function() {
                return this._impl.clearFocus()
                };
                NetChart.prototype.collapseNode = function(id) {
                return this._impl.collapseNode(id)
                };
                NetChart.prototype.lockNode = function(id, x, y) {
                return this._impl.lockNode(id, x, y)
                };
                NetChart.prototype.unlockNode = function(id) {
                return this._impl.unlockNode(id)
                };
                NetChart.prototype.selection = function(selected) {
                if (selected != null) {
                this._impl.setSelection(selected)
                }
                return this._scene.selection
                };
                NetChart.prototype.back = function() {
                return this._impl.back()
                };
                NetChart.prototype.zoomIn = function(objects, animate) {
                if (animate == null) {
                animate = true
                }
                return this._impl.zoomIn(objects, animate)
                };
                NetChart.prototype.closePopup = function() {
                return this._impl.closePopup()
                };
                NetChart.prototype.nodes = function() {
                return this._impl.getCurrentNodes()
                };
                NetChart.prototype.links = function() {
                return this._impl.getCurrentLinks()
                };
                NetChart.prototype.getNodeDimensions = function(node) {
                return this._impl.getNodeDimensions(node)
                };
                NetChart.prototype.exportData = function(visibleOnly, exportCoordinates) {
                if (visibleOnly == null) {
                visibleOnly = true
                }
                if (exportCoordinates == null) {
                exportCoordinates = true
                }
                return this._impl.exportData(visibleOnly, exportCoordinates)
                };
                return NetChart
        })(Base_Api);
        var PieChart, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        PieChart = (function(_super) {
        __extends(PieChart, _super);
                PieChart._impl = null;
                PieChart._scene = null;
                PieChart.settings = null;
                PieChart.themes = {flat: Piechart_Settings.FlatTheme, bevel: Piechart_Settings.BevelTheme, gradient: Piechart_Settings.GradientTheme, raised: Piechart_Settings.CanTheme};
                function PieChart(settings) {
                this.themes = PieChart.themes;
                        this._impl = new Piechart_Impl(settings, this);
                        this.settings = this._impl.settings;
                        this._scene = this._impl.scene;
                        return this
                }
        PieChart.prototype.updateFilter = function() {
        this._impl.updateFilter();
                return this
        };
                PieChart.prototype.selection = function(selected) {
                if (selected != null) {
                this._impl.setSelection(selected)
                }
                return this._scene.selection
                };
                PieChart.prototype.getPie = function() {
                return this._impl.getPie()
                };
                PieChart.prototype.getPieOffset = function() {
                return this._impl.navigator.getPieOffset()
                };
                PieChart.prototype.setPie = function(pieId, offset) {
                if (offset == null) {
                offset = 0
                }
                return this._impl.setPie(pieId, offset, "api")
                };
                PieChart.prototype.getActiveSlices = function() {
                return this._impl.getActiveSlices()
                };
                PieChart.prototype.getActivePies = function() {
                return this._impl.getActivePies()
                };
                PieChart.prototype.getActivePie = function() {
                var p;
                        p = this._impl.getActivePies();
                        return p[p.length - 1]
                };
                PieChart.prototype.back = function() {
                return this._impl.back()
                };
                PieChart.prototype.expandSlice = function(slice) {
                return this._impl.expandSlice(slice, "api")
                };
                PieChart.prototype.closePopup = function() {
                return this._impl.closePopup()
                };
                PieChart.prototype.getSliceDimensions = function(sliceId, showPartial) {
                if (showPartial == null) {
                showPartial = false
                }
                return this._impl.getSliceDimensions(sliceId, showPartial)
                };
                return PieChart
        })(Base_Api);
        var FacetChart, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        FacetChart = (function(_super) {
        __extends(FacetChart, _super);
                FacetChart._impl = null;
                FacetChart._scene = null;
                FacetChart.settings = null;
                FacetChart.themes = {};
                function FacetChart(settings) {
                this.themes = FacetChart.themes;
                        this._impl = new Facetchart_Impl(settings, this);
                        this.settings = this._impl.settings;
                        this._scene = this._impl.scene;
                        return this
                }
        FacetChart.prototype.updateFilter = function() {
        this._impl.updateFilter();
                return this
        };
                FacetChart.prototype.selection = function(selected) {
                if (selected != null) {
                this._impl.setSelection(selected)
                }
                return this._scene.selection
                };
                FacetChart.prototype.setPie = function(pieId, offset, count) {
                if (offset == null) {
                offset = 0
                }
                if (count == null) {
                count = null
                }
                return this._impl.setPie(pieId, offset, count, "api")
                };
                FacetChart.prototype.getActiveSlices = function() {
                return this._impl.getActiveSlices()
                };
                FacetChart.prototype.getPie = function() {
                return this._impl.getPie()
                };
                FacetChart.prototype.getPieOffset = function() {
                return this._impl.getPieOffset()
                };
                FacetChart.prototype.back = function() {
                return this._impl.back()
                };
                FacetChart.prototype.expandSlice = function(slice) {
                return this._impl.expandItem(slice, "api")
                };
                FacetChart.prototype.closePopup = function() {
                return this._impl.closePopup()
                };
                FacetChart.prototype.replaceSeries = function(series) {
                return this._impl.replaceSeries(series)
                };
                return FacetChart
        })(Base_Api);
        var Timechart_Impl, __bind = function(fn, me) {
        return function() {
        return fn.apply(me, arguments)
        }
        }, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        Timechart_Impl = (function(_super) {
        __extends(Timechart_Impl, _super);
                Timechart_Impl.prototype.scrolling = null;
                Timechart_Impl.prototype.renderer = null;
                Timechart_Impl.prototype.timeStart = 0;
                Timechart_Impl.prototype.timeEnd = 0;
                Timechart_Impl.prototype.displayUnit = null;
                Timechart_Impl.prototype.selectionStart = 0;
                Timechart_Impl.prototype.selectionEnd = 0;
                function Timechart_Impl(settings, api) {
                this.defaultRightClick = __bind(this.defaultRightClick, this);
                        this.defaultClick = __bind(this.defaultClick, this);
                        this.settings = new Timechart_Settings(settings);
                        Timechart_Impl.__super__.constructor.call(this, this.settings);
                        this.scene = new Timechart_Scene(this.settings);
                        this.initDataObjects();
                        this.layers = new Linearchart_Layers(this);
                        this.initialize(api);
                        this.toolbar = new Timechart_MultiBar(this.layers.container, this, this.settings.toolbars);
                        this.bottomAxisSettings = this.settings.timeAxis;
                        this.timeAxis = new Timechart_TimeAxis(this);
                        this.dataWarehouse = new Timechart_DataWarehouse(this);
                        this.renderer = new Timechart_Renderer(this, this.dataWarehouse);
                        this.scrolling = new Timechart_Scrolling(this);
                        this.events.addElement(this.scrolling);
                        this.events.addElement(this.timeAxis);
                        this.events.addElement(this.renderer);
                        this.events.addElement(new Timechart_ClickNotifier(this));
                        this.events.addElement(new Linearchart_Markers(this));
                        this.events.addElement(new Linearchart_Highlights(this));
                        this.selection = this.events.addElement(new Timechart_Selection(this));
                        this.infoPopup = this.events.addElement(new Timechart_InfoPopup(this));
                        this.events.addElement(new Timechart_TimeUpdater(this));
                        this.setupInitialDisplayPeriod();
                        this.notifyTimeChanged(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, "init");
                        this.finalInitialize()
                }
        Timechart_Impl.prototype.onRemove = function() {
        this.layers = null;
                this.renderer = null;
                this.scene.data = null;
                return this.scene = null
        };
                Timechart_Impl.prototype.setupInitialDisplayPeriod = function() {
                var ianchor, iperiod, iunit;
                        if (this.scene.displayUnit && (this.scene.timeStart || this.scene.timeEnd)) {
                return
                }
                ianchor = this.settings.area.initialDisplayAnchor;
                        iperiod = this.settings.area.initialDisplayPeriod;
                        iunit = this.settings.area.initialDisplayUnit;
                        return this.computeDisplayPeriod(iperiod, ianchor, iunit, (function(_this) {
                        return function(form, to, unit) {
                        _this.scene.setMessage("impl", null);
                                _this.scene.loading = false;
                                if (_this.scene.displayUnit != null) {
                        unit = _this.scene.displayUnit
                        }
                        if (!_this.scene.timeStart && !_this.scene.timeEnd) {
                        return _this.scrolling.setTimeRange(form, to, unit, false, "init", ianchor, iperiod)
                        }
                        }
                        })(this))
                };
                Timechart_Impl.prototype.initDataObjects = function() {
                var d, data, key, v, _i, _len, _ref, _ref1, _results;
                        _ref = this.scene.data;
                        for (key in _ref) {
                data = _ref[key];
                        data.remove()
                }
                this.scene.data = {};
                        this.scene.mainData = null;
                        _ref1 = this.settings.computedData;
                        _results = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                v = _ref1[_i];
                        d = new Timechart_Data(this, v);
                        if (!this.scene.mainData) {
                this.scene.mainData = d
                }
                _results.push(this.scene.data[v.name] = d)
                }
                return _results
                };
                Timechart_Impl.prototype.onSettingsChanged = function(changes) {
                var newUnit, s, updateToolbars;
                        this.layers.updateSettings(changes);
                        updateToolbars = changes.toolbars != null;
                        if (changes.data != null) {
                this.initDataObjects();
                        this.setupInitialDisplayPeriod();
                        updateToolbars = true
                } else {
                if (Base_Helpers.hasProp(changes, "area/displayUnits")) {
                s = new Timechart_TimeSetup(this.settings);
                        if (!s.isAllowedDisplayUnit(this.scene.displayUnit)) {
                newUnit = s.computeDisplayUnit(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, this.scene.timeStart, this.scene.timeEnd, this.scene);
                        this.scrolling.setTimeRangeSnap(this.scene.timeStart, this.scene.timeEnd, null, newUnit, true, "api", true, true)
                }
                }
                }
                if (updateToolbars) {
                this.toolbar.remove();
                        this.toolbar = new Timechart_MultiBar(this.layers.container, this);
                        if (this.assetsLoaded) {
                this.toolbar.render()
                }
                }
                if (changes.title || changes.toolbars || changes.valueAxis) {
                this.updateSize(true)
                }
                return this.events.notifySceneChanges({settings: true, time: true, settingsChanges: changes})
                };
                Timechart_Impl.prototype.addData = function(data, sourceId) {
                this.scene.data[sourceId].addData(null, data, true);
                        return this.events.notifySceneChanges({data: true})
                };
                Timechart_Impl.prototype.reloadData = function() {
                this.initDataObjects();
                        this.setupInitialDisplayPeriod();
                        return this.events.notifySceneChanges({data: true})
                };
                Timechart_Impl.prototype.save = function() {
                return JSON.stringify({from: this.timeStart, to: this.timeEnd, unit: this.displayUnit.toString(), selFrom: this.scene.selectionStart, selTo: this.scene.selectionEnd, anchor: this.scene.anchor, period: this.scene.period})
                };
                Timechart_Impl.prototype.restore = function(stateStr, animate) {
                var state, unit;
                        if (!stateStr) {
                return
                }
                state = JSON.parse(stateStr);
                        unit = Base_TimeStep.parse(state.unit);
                        if (!unit) {
                this.error("Restore state: illegal display  unit: " + state.unit);
                        return
                }
                this.scrolling.setTimeRange(state.from, state.to, unit, animate, "api", state.anchor, state.period);
                        return this.setSelection(state.selFrom, state.selTo)
                };
                Timechart_Impl.prototype.setSelection = function(from, to, origin) {
                if (origin == null) {
                origin = "api"
                }
                if (this.scene.selectionStart === from && this.scene.selectionEnd === to) {
                return
                }
                this.scene.selectionStart = from;
                        this.scene.selectionEnd = to;
                        this.events.notifySceneChanges({selection: true});
                        return this.notifySelectionChanged(origin)
                };
                Timechart_Impl.prototype.setTimeRange = function(f, t, u, a, origin) {
                if (origin == null) {
                origin = "api"
                }
                this.setSelection(null, null, origin);
                        return this.scrolling.setTimeRange(f, t, u, a, origin)
                };
                Timechart_Impl.prototype.setDisplayPeriod = function(displayPeriod, displayAnchor, displayUnit, animate, origin) {
                if (displayAnchor == null) {
                displayAnchor = null
                }
                if (displayUnit == null) {
                displayUnit = null
                }
                if (animate == null) {
                animate = true
                }
                if (origin == null) {
                origin = "api"
                }
                if (displayAnchor == null) {
                displayAnchor = this.scene.anchor
                }
                this.setSelection(null, null);
                        if (typeof displayAnchor === "string") {
                displayAnchor = displayAnchor.trim()
                }
                if (typeof displayPeriod === "string") {
                displayPeriod = displayPeriod.trim()
                }
                return this.computeDisplayPeriod(displayPeriod, displayAnchor, displayUnit, (function(_this) {
                return function(form, to, unit) {
                return _this.scrolling.setTimeRange(form, to, unit, animate, origin, displayAnchor, displayPeriod)
                }
                })(this))
                };
                Timechart_Impl.prototype.scrollIntoView = function(time) {
                return this.error("ScrollIntoView: not implemented")
                };
                Timechart_Impl.prototype.scroll = function(amount, animate) {
                var count, direction, from, s, to, unit, units, _ref;
                        units = amount.trim().split(" ");
                        if (units.length !== 3) {
                this.error("Incorrect scroll format: " + amount);
                        return
                }
                direction = units[0];
                        count = parseInt(units[1]);
                        unit = units[2];
                        if ((direction !== "<" && direction !== ">") || typeof count !== "number") {
                this.error("Scroll:Incorrect scroll format: " + amount);
                        return
                }
                s = new Timechart_TimeSetup(this.settings);
                        _ref = s.scroll(this.timeStart, this.timeEnd, this.displayUnit, direction, count, unit), from = _ref[0], to = _ref[1];
                        return this.scrolling.setTimeRange(from, to, this.displayUnit, animate, "api", null, this.scene.period)
                };
                Timechart_Impl.prototype.zoomOut = function(unit, animate, origin) {
                if (animate == null) {
                animate = true
                }
                if (origin == null) {
                origin = "api"
                }
                this.setSelection(null, null);
                        this.scrolling.zoomOut(unit, this.scene.timeStart, this.scene.timeEnd, animate, origin);
                        return this.scene.period = null
                };
                Timechart_Impl.prototype.zoomIn = function(unit, center, animate, origin) {
                if (center == null) {
                center = null
                }
                if (animate == null) {
                animate = true
                }
                if (origin == null) {
                origin = "api"
                }
                this.setSelection(null, null);
                        this.scrolling.zoomIn(unit, center, this.scene.timeStart, this.scene.timeEnd, animate, origin);
                        return this.scene.period = null
                };
                Timechart_Impl.prototype.setDisplayUnit = function(unitStr, animate, rescale, scaleCenter, origin) {
                var approxUnits, displayFrom, displayTo, from, maxUnits, s, to, unit, _ref, _ref1, _ref2;
                        if (origin == null) {
                origin = "api"
                }
                unit = Base_TimeStep.parse(unitStr);
                        if (unit == null) {
                return
                }
                if (!rescale) {
                maxUnits = this.settings.advanced.maxUnitsToDisplay;
                        approxUnits = (this.timeEnd - this.timeStart) / unit.approxTime();
                        while (approxUnits > maxUnits) {
                unit = unit.getBigger();
                        approxUnits = (this.timeEnd - this.timeStart) / unit.approxTime()
                }
                return this.scrolling.setTimeRange(this.timeStart, this.timeEnd, unit, false, origin, this.scene.anchor, this.scene.period)
                } else {
                this.scene.period = null;
                        if (scaleCenter == null) {
                scaleCenter = (this.timeStart + this.timeEnd) / 2
                }
                s = new Timechart_TimeSetup(this.settings);
                        _ref = this.scene.getDisplayLimits(), displayFrom = _ref[0], displayTo = _ref[1];
                        _ref1 = s.preventOverscale(this.scene, [unit], scaleCenter, - Infinity, Infinity, displayFrom, displayTo), from = _ref1[0], to = _ref1[1];
                        _ref2 = this.scrolling.computeTimeRangeExtend(from, to, unit), from = _ref2[0], to = _ref2[1];
                        return this.scrolling.setTimeRange(from, to, unit, animate, origin, this.scene.anchor, null)
                }
                };
                Timechart_Impl.prototype.notifyTimeChanged = function(from, to, unit, origin) {
                this.timeStart = from;
                        this.timeEnd = to;
                        this.displayUnit = unit;
                        return this.notifyChartUpdate(origin)
                };
                Timechart_Impl.prototype.saveNavigation = function() {
                if (!this.displayUnit) {
                return null
                }
                return[this.timeStart, this.timeEnd, this.displayUnit, this.scene.anchor, this.scene.period]
                };
                Timechart_Impl.prototype.restoreNavigation = function(state, animate, origin) {
                var anchor, period;
                        this.timeStart = state[0];
                        this.timeEnd = state[1];
                        this.displayUnit = state[2];
                        anchor = state[3];
                        period = state[4];
                        return this.scrolling.setTimeRange(this.timeStart, this.timeEnd, this.displayUnit, animate, origin, anchor, period)
                };
                Timechart_Impl.prototype.doChartUpdateNotify = function(origin) {
                Timechart_Impl.__super__.doChartUpdateNotify.call(this, origin);
                        return this.dispatchEventParams("timeChange", this.extendEventParams({origin: origin}), null)
                };
                Timechart_Impl.prototype.extendEventParams = function(p) {
                p.timeStart = this.timeStart;
                        p.timeEnd = this.timeEnd;
                        p.displayUnit = this.displayUnit != null ? this.displayUnit.toString() : null;
                        p.selectionStart = this.scene.selectionStart;
                        p.selectionEnd = this.scene.selectionEnd;
                        return p
                };
                Timechart_Impl.prototype.computeDisplayPeriod = function(periodStr, anchorStr, displayUnitStr, callback) {
                var dataLoaded, from, to, unit, _ref;
                        _ref = this.scrolling.computeDisplayPeriod(periodStr, anchorStr, displayUnitStr, this.scene.mainData.dataFrom, this.scene.mainData.dataTo), from = _ref[0], to = _ref[1], unit = _ref[2];
                        if ((from != null) && (to != null) && unit) {
                if ((from != null) && (to != null)) {
                return callback(from, to, unit)
                }
                }
                if ((this.scene.mainData.settings.dataFunction == null) && (this.scene.mainData.settings.url == null) && (this.scene.mainData.settings.urlByUnit == null) && (this.scene.mainData.settings.preloaded == null)) {
                this.error("Cannot compute data dependant display period, no data given. DisplayPeriod = " + periodStr + ", DisplayAnchor = " + anchorStr);
                        return
                }
                dataLoaded = (function(_this) {
                return function(dataFrom, dataTo, dataUnit, oldFrom, oldTo, oldUnit) {
                var displayUnit, _ref1;
                        if (_this.removed) {
                return
                }
                if (dataFrom === null || dataTo === null || (dataFrom === 0 && dataTo === 0 && _this.scene.mainData.noData)) {
                callback(oldFrom, oldTo, oldUnit);
                        return
                }
                _ref1 = _this.scrolling.computeDisplayPeriod(periodStr, anchorStr, displayUnitStr, dataFrom, dataTo), from = _ref1[0], to = _ref1[1], displayUnit = _ref1[2];
                        if (!((from != null) && (to != null))) {
                _this.error("Could not setup display time interval. Check your configuration.");
                        return
                }
                if (Timechart_TimeSetup.isSmallerOrEqualUnit(dataUnit, displayUnit.unit)) {
                return callback(from, to, displayUnit)
                } else {
                return _this.scene.mainData.determineDataLimits(displayUnit.unit, true, true, function(a, b, c) {
                return dataLoaded(a, b, c, dataFrom, dataTo, displayUnit)
                })
                }
                }
                })(this);
                        return this.scene.mainData.determineDataLimits(null, true, true, (function(_this) {
                        return function(a, b, c) {
                        return dataLoaded(a, b, c, 0, 0, null)
                        }
                        })(this))
                };
                Timechart_Impl.prototype.isThisDisplayPeriod = function(periodStr, anchorStr) {
                var from, to, unit, _ref;
                        if (!this.displayUnit) {
                return false
                }
                from = this.scene.mainData.dataFrom;
                        to = this.scene.mainData.dataTo;
                        _ref = this.scrolling.computeDisplayPeriod(periodStr, anchorStr, this.displayUnit, from, to), from = _ref[0], to = _ref[1], unit = _ref[2];
                        return from === this.timeStart && to === this.timeEnd
                };
                Timechart_Impl.prototype.defaultClick = function(event) {
                return this.setTimeRange(event.clickStart, event.clickEnd, null, true, "user")
                };
                Timechart_Impl.prototype.defaultRightClick = function(event) {
                this.infoPopup.show(event);
                        return event.preventDefault()
                };
                return Timechart_Impl
        })(Linearchart_Impl);
        var TimeChart, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
for (var key in parent) {
if (__hasProp.call(parent, key)) {
child[key] = parent[key]
        }
}
function ctor() {
this.constructor = child
        }
ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child
        };
        TimeChart = (function(_super) {
        __extends(TimeChart, _super);
                TimeChart.themes = {flat: Timechart_Settings.FlatTheme, round: Timechart_Settings.RoundTheme, gradient: Timechart_Settings.GradientTheme, "static": Timechart_Settings.StaticChart};
                TimeChart.prototype._impl = null;
                TimeChart.prototype._scene = null;
                TimeChart.prototype.settings = null;
                function TimeChart(settings) {
                this.themes = TimeChart.themes;
                        this._impl = new Timechart_Impl(settings, this);
                        this.settings = this._impl.settings;
                        this._scene = this._impl.scene;
                        return this
                }
        TimeChart.prototype.time = function(from, to, animate) {
        if (animate == null) {
        animate = true
        }
        if (from !== void 0 && to !== void 0) {
        this._impl.setTimeRange(from, to, null, animate)
        }
        return[this._impl.timeStart, this._impl.timeEnd]
        };
                TimeChart.prototype.setDisplayPeriod = function(period, anchor, animate) {
                return this._impl.setDisplayPeriod(period, anchor, null, animate)
                };
                TimeChart.prototype.displayUnit = function(unit, animate, rescale, rescaleCenter) {
                if (animate == null) {
                animate = true
                }
                if (rescale == null) {
                rescale = false
                }
                if (rescaleCenter == null) {
                rescaleCenter = null
                }
                if (unit != null) {
                this._impl.setDisplayUnit(unit, animate, rescale, rescaleCenter)
                }
                if (this._impl.displayUnit != null) {
                return this._impl.displayUnit.toString()
                } else {
                return null
                }
                };
                TimeChart.prototype.selection = function(from, to) {
                if (from !== void 0 && to !== void 0) {
                this._impl.setSelection(from, to)
                }
                return[this._scene.selectionStart, this._scene.selectionEnd]
                };
                TimeChart.prototype.back = function() {
                return this._impl.back()
                };
                TimeChart.prototype.scroll = function(amount, animate) {
                if (animate == null) {
                animate = true
                }
                return this._impl.scroll(amount, animate)
                };
                TimeChart.prototype.zoomOut = function(unit, animate) {
                if (unit == null) {
                unit = null
                }
                if (animate == null) {
                animate = true
                }
                return this._impl.zoomOut(unit, animate, "api")
                };
                TimeChart.prototype.zoomIn = function(unit, center, animate) {
                if (unit == null) {
                unit = null
                }
                if (center == null) {
                center = null
                }
                if (animate == null) {
                animate = true
                }
                return this._impl.zoomIn(unit, center, animate, "api")
                };
                TimeChart.prototype.replaceSeries = function(series) {
                return this._impl.replaceSeries(series)
                };
                return TimeChart
        })(Base_Api);
        this.TimeChart = TimeChart;
        this.NetChart = NetChart;
        this.PieChart = PieChart;
        this.FacetChart = FacetChart
}).call(this);